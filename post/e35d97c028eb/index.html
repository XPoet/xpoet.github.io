<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="XPoet"><meta name="description" content="XPoet&#39;s Blog"><meta name="author" content="XPoet"><title>JavaScript 数据结构与算法（十三）二叉搜索树 | XPoet&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/avatar.png"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/fontawesome.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/regular.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/solid.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/brands.min.css"><link rel="stylesheet" href="/css/custom.css"><script class="keep-theme-configurations">const KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"xpoet.cn",root:"/",language:"en",path:"search.json"},KEEP.theme_config={base_info:{primary_color:"#0066cc",title:"XPoet's Blog",author:"XPoet",avatar:"/images/avatar.png",logo:"/images/avatar.png",favicon:"/images/avatar.png"},menu:{home:"/",archives:"/archives",tags:"/tags",me:{children:[{about:"/about || fa-solid fa-user-graduate"},{links:"/links || fa-solid fa-link"},{tools:"/tools || fa-solid fa-tools"}]}},first_screen:{enable:!0,background_img:"/images/bg.svg",background_img_dark:"/images/bg2.svg",description:"黄色的森林分出两条路，我选择人迹更少的那一条，从此决定我一生的道路。",hitokoto:!1},social_contact:{enable:!0,links:{github:"https://github.com/XPoet",weixin:"img | /images/fp/fp-qrcode.webp",qq:null,weibo:null,zhihu:null,twitter:null,x:null,facebook:null,email:"i@xpoet.cn"}},scroll:{progress_bar:!1,percent:!0,hide_header:!0},home:{announcement:null,category:!0,tag:!0,post_datetime:"updated"},post:{author_badge:{enable:!0,level_badge:!1,custom_badge:"自由程序猿"},word_count:{wordcount:!0,min2read:!0},datetime_format:"YYYY-MM-DD HH:mm:ss",copyright_info:!0,share:!0,reward:{enable:!0,img_link:"/images/admire-code.png",text:null}},code_block:{tools:{enable:!0,style:"default"},highlight_theme:"default"},toc:{enable:!0,number:!0,expand_all:!0,init_open:!0,layout:"right"},website_count:{busuanzi_count:{enable:!0,site_uv:!0,site_pv:!0,page_pv:!0}},local_search:{enable:!0,preload:!0},comment:{enable:!0,use:"waline",valine:{appid:"ih2nzG3ilVNdLgJK4kBXTjOq-gzGzoHsz",appkey:"gdf6tXXLBTLg9qpjS2y6Tbw7",server_urls:null,placeholder:"吐槽一下..."},gitalk:{github_id:null,github_admins:null,repository:null,client_id:null,client_secret:null,proxy:null},twikoo:{env_id:null,region:null,version:"1.6.36"},waline:{server_url:"https://vercel-waline.xpoet.cn",reaction:!0,version:"3.2.1"},giscus:{repo:"XPoet/xpoet.github.io",repo_id:"MDEwOlJlcG9zaXRvcnkzMjk0NzQ2NzM=",category:"Announcements",category_id:"DIC_kwDOE6Nicc4CZnkm",reactions_enabled:!0},artalk:{server:null},disqus:{shortname:null}},rss:{enable:!0},lazyload:{enable:!0},cdn:{enable:!0,provider:"cdnjs"},pjax:{enable:!0},footer:{since:2020,word_count:!1,site_deploy:{enable:!0,provider:"github",url:"https://github.com/xpoet/xpoet.github.io"},record:{enable:!1,list:[{code:null,link:null}]}},inject:{enable:!0,css:["/css/custom.css"],js:[null]},root:"",source_data:{links:[{title:"宝藏博主们"},{name:"不知名艺术家",link:"https://jinzhanqi.com/",description:"love artist, love code.",avatar:"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{name:"爱·绮梦",link:"https://x.iqimeng.com/",description:"学而时习之 不亦说乎",avatar:"https://x.iqimeng.com/images/avatar.jpg"},{name:"Keep learning",link:"https://blog.gooday.press",description:"爱好学习，不断提升自我",avatar:"https://cdn.statically.io/gh/cemonliu/blogpic@main/avatar.svg"},{name:"CitingNutria",link:"https://citingnutria.github.io/",description:"まだ夢がある",avatar:"https://cdn.statically.io/gh/CitingNutria/image_hosting@master/avatar.jpg"},{name:"Xcbyao",link:"https://xcbyao.github.io/",description:"要么庸俗，要么孤独！",avatar:"https://xcbyao.github.io/images/avatar.png"},{name:"Ycr's Blog",link:"https://www.ycr10.cn/",description:"喜欢你的人一直有空，什么都懂，无所不能。",avatar:"https://www.ycr10.cn/wp-content/uploads/2022/02/cropped-Ycr_logo.jpg"},{name:"小龙的跋涉",link:"https://www.eduorg.ltd/",description:"但行好事，莫问前程",avatar:"https://cdn.statically.io/gh/Xiaolong00/raines-photo@master/blog/favicon.42reb4izcgs0.png"},{name:"recovxy",link:"https://naiv.xyz/",description:"在人生的中途，我发现我已经迷失了正路，走进了一座幽暗森林······",avatar:"https://naiv.xyz/assets/blogImg/logo.jpg"},{name:"KAI'S NOTE",link:"https://kainote.top/",description:"三天打鱼 (⊙ˍ⊙) 两天晒网",avatar:"https://s2.loli.net/2022/01/09/UtbhxHv2IA8jqwZ.jpg"},{name:"xustudyxu",link:"https://frxcat.fun/",description:"一起学习编程！",avatar:"https://cdn.statically.io/gh/xustudyxu/image-hosting@master/20220627/mmexport1656324824543.124zxwkqyzlc.webp"},{name:"CalvinHaynes 的博客",link:"https://blog.calvinhaynes.top/",description:"慢慢走才会快",avatar:"https://cdn.statically.io/gh/CalvinHaynes/ImageHub@main/Icon/avatar.jpg"},{name:"一座浮岛",link:"https://anlondon.cn/",description:"🤪我的小站🤪",avatar:"https://anlondon.cn/images/logo_my.png"},{name:"有意栽花花满枝",link:"https://blog.hjroyal.top",description:"心中有光、点亮生活",avatar:"https://blog.hjroyal.top/img/profile.webp"},{name:"荣 6 的博客",link:"http://rong6.cn/",description:"钻研信息技术的屑",avatar:"https://img2.huashi6.com/images/resource/u275992/2021/08/04/108889_59388969493.jpg?imageMogr2/quality/75/interlace/1/thumbnail/x1400/gravity/Center/crop/1400x1400/format/webp"},{name:"程序员小明",link:"https://mynamecoder.com",description:"一个很少加班的程序员",avatar:"https://mynamecoder.com/images/avatar.png"},{name:"倚栏听风",link:"https://iweek.eu.org/",description:"十八线运维的工作笔记。",avatar:"https://s1.vika.cn/space/2023/02/17/0c1c4a6b023b42f38aaf39d480206e26"},{name:"Ssk-wh`s Blog",link:"https://ssk-wh.github.io",avatar:"https://ssk-wh.github.io/images/logo.svg",description:"假如走运了呢"},{name:"XTZYJ の技术小屋",link:"https://xtzyj.top/",description:"办法总比困难多。",avatar:"https://xtzyj.top/favicon.ico"},{name:"灯火的博客",link:"https://blog.juniverse.top/",description:"不要懒惰",avatar:"https://blog.juniverse.top/images/lights-logo.jpg"},{name:"绯鞠的博客",link:"https://loli.fj.cn",description:"一只爱折腾的绯鞠",avatar:"https://loli.fj.cn/dist/images/avatar.gif"}],icons:{"稀土掘金":{svg:'<svg t="1717059555650" class="icon" viewBox="0 0 1316 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2653" width="16" height="16"><path d="M643.181714 247.698286l154.916572-123.172572L643.181714 0.256 643.072 0l-154.660571 124.269714 154.660571 123.245715 0.109714 0.182857z m0 388.461714h0.109715l399.579428-315.245714-108.361143-87.04-291.218285 229.888h-0.146286l-0.109714 0.146285L351.817143 234.093714l-108.251429 87.04 399.433143 315.136 0.146286-0.146285z m-0.146285 215.552l0.146285-0.146286 534.893715-422.034285 108.397714 87.04-243.309714 192L643.145143 1024 10.422857 525.056 0 516.754286l108.251429-86.893715L643.035429 851.748571z" fill="#1E80FF" p-id="2654"></path></svg>',link:"https://juejin.cn/user/2700056291193374"}},tools:[{category:"AIGC",anchorId:"QUlHQw0"},{name:"ChatGPT",link:"https://chat.openai.com/",description:"OpenAI 旗下 AI 聊天对话工具",image:"/images/tools/chatgpt.svg"},{name:"Gemini",link:"https://gemini.google.com/app",description:"Google 旗下 AI 聊天对话工具",image:"/images/tools/gemini.svg"},{name:"Kimi",link:"https://kimi.moonshot.cn/",description:"帮你看更大的世界",image:"/images/tools/kimi.svg"},{name:"Copilot",link:"https://copilot.microsoft.com/",description:"微软旗下的日常 AI 助手",image:"/images/tools/copilot.png"},{name:"文心一言",link:"https://yiyan.baidu.com/",description:"百度旗下 AI 聊天对话工具",image:"/images/tools/wenxinyiyan.png"},{name:"通义千问",link:"https://tongyi.aliyun.com/qianwen/",description:"阿里巴巴旗下 AI 聊天对话工具",image:"/images/tools/tongyiqianwen.svg"},{name:"讯飞星火",link:"https://xinghuo.xfyun.cn/",description:"科大讯飞星火认知 AI 大模型",image:"/images/tools/xinghuo.svg"},{name:"Midjourney",link:"https://www.midjourney.com/",description:"AI 图像和插画生成工具",image:"/images/tools/midjourney.png"},{name:"Adobe Firefly",link:"https://firefly.adobe.com/",description:"Adobe 推出的 AI 图像生成和编辑工具",image:"/images/tools/adobe-firefly.svg"},{name:"Stable Diffusion",link:"https://stability.ai/",description:"最强开源 AI 绘画工具",image:"/images/tools/stability.png"},{name:"Microsoft Designer",link:"https://designer.microsoft.com/home",description:"微软推出的在线设计海报和宣传图工具",image:"/images/tools/microsoft-designer.svg"},{name:"文心一格",link:"https://yige.baidu.com/",description:"百度出品的 AI 绘画工具",image:"/images/tools/wenxinyiyan.png"},{name:"AI Bot",link:"https://juejin.cn/bots",description:"稀土掘金 AI Bot 工具集合",image:null},{category:"技术社区",anchorId:"JUU2JThBJTgwJUU2JTlDJUFGJUU3JUE0JUJFJUU1JThDJUJB14"},{name:"稀土掘金",link:"https://juejin.cn/",description:"一个帮助开发者成长的社区",image:"/images/tools/juejin.svg"},{name:"V2EX",link:"https://www.v2ex.com/",description:"创意工作者们的社区",image:"/images/tools/v2ex.png"},{name:"思否",link:"https://segmentfault.com/",description:"中国领先的开发者技术社区",image:"/images/tools/segmentfault.svg"},{name:"博客园",link:"https://www.cnblogs.com/",description:"开发者的网上家园",image:"/images/tools/cnblogs.png"},{name:"W2Solo",link:"https://w2solo.com/",description:"中文独立开发者社区",image:null},{name:"电鸭社区",link:"https://eleduck.com/",description:"专注远程工作招聘交流",image:"/images/tools/dianyashequ.png"},{name:"StackOverflow",link:"https://stackoverflow.com/",description:"全球最大的技术问答社区",image:"/images/tools/stackoverflow.png"},{name:"开源中国",link:"https://www.oschina.net/",description:"目前国内最大的开源技术社区",image:"/images/tools/oschina.webp"},{name:"InfoQ",link:"https://www.infoq.cn/",description:"一个实践驱动的技术社区资讯站点",image:"/images/tools/infoq.png"},{name:"51CTO",link:"https://www.51cto.com/",description:"中国领先的 IT 技术网站",image:"/images/tools/51cto.webp"},{name:"CSDN",link:"https://www.csdn.net/",description:"中文最大的技术社区",image:"/images/tools/csdn.png"},{category:"部署托管",anchorId:"JUU5JTgzJUE4JUU3JUJEJUIyJUU2JTg5JTk4JUU3JUFFJUEx26"},{name:"GitHub Pages",link:"https://pages.github.com/",description:"通过 GitHub 托管和发布的公共网页",image:"/images/tools/github.svg"},{name:"Vercel",link:"https://vercel.com/",description:"Vercel's Frontend Cloud provides the developer experience and infrastructure to build, scale, and secure a faster, more personalized web.",image:"/images/tools/vercel.svg"},{name:"Cloudflare Pages",link:"https://developers.cloudflare.com/pages/",description:"Create full-stack applications that are instantly deployed to the Cloudflare global network.",image:"/images/tools/cloudflare.svg"},{name:"Netlify",link:"https://www.netlify.com/",description:"Netlify is the essential platform for the delivery of exceptional and dynamic web experiences, without limitations.",image:"/images/tools/netlify.svg"},{name:"Railway",link:"https://railway.app/",description:"Railway is the cloud for building, shipping, and monitoring applications.",image:"/images/tools/railway.svg"},{name:"Zeabur",link:"https://zeabur.com",description:"Say goodbye to deployment hassles. With Zeabur, bring your coding genius to life swiftly and smoothly.",image:"/images/tools/zeabur.png"}]},version:"4.2.5"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},KEEP.language_code_block={copy:"Copy code",copied:"Copied",fold:"Fold code block",folded:"Folded"},KEEP.language_copy_copyright={copy:"Copy copyright info",copied:"Copied",title:"Original post title",author:"Original post author",link:"Original post link"}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="XPoet's Blog" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container border-box"><div class="page-main-content border-box"><div class="page-main-content-top"><header class="header-wrapper"><div class="border-box header-content"><div class="left flex-start border-box"><a class="logo-image border-box" href="/"><img src="/images/avatar.png"> </a><a class="site-name border-box" href="/">XPoet&#39;s Blog</a></div><div class="right border-box"><div class="pc border-box"><ul class="menu-list border-box"><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/">HOME</a></li><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/archives">ARCHIVES</a></li><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/tags">TAGS</a></li><li class="menu-item flex-start border-box has-sub-menu"><a class="menu-text-color border-box" href="javascript:void(0);">ME <i class="menu-text-color collapse-icon fa-solid fa-angle-down"></i></a><ul class="sub-menu-list border-box"><li class="sub-menu-item border-box"><a class="menu-text-color border-box flex-start" href="/about"><i class="menu-text-color sub-menu-icon fa-solid fa-user-graduate"></i> ABOUT</a></li><li class="sub-menu-item border-box"><a class="menu-text-color border-box flex-start" href="/links"><i class="menu-text-color sub-menu-icon fa-solid fa-link"></i> LINKS</a></li><li class="sub-menu-item border-box"><a class="menu-text-color border-box flex-start" href="/tools"><i class="menu-text-color sub-menu-icon fa-solid fa-tools"></i> TOOLS</a></li></ul></li><li class="menu-item search search-popup-trigger"><i class="menu-text-color fas search fa-search"></i></li></ul></div><div class="mobile border-box flex-start"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list border-box"><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/">HOME</a></label></li><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">ARCHIVES</a></label></li><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/tags">TAGS</a></label></li><li class="drawer-menu-item border-box has-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="javascript:void(0);">ME </a><i class="right-side collapse-icon fa-solid fa-angle-left"></i></label><ul class="drawer-sub-menu-list border-box"><li class="sub-menu-item border-box"><a class="drawer-menu-text-color border-box flex-start" href="/about"><span class="sub-menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color sub-menu-icon fa-solid fa-user-graduate"></i> </span>ABOUT</a></li><li class="sub-menu-item border-box"><a class="drawer-menu-text-color border-box flex-start" href="/links"><span class="sub-menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color sub-menu-icon fa-solid fa-link"></i> </span>LINKS</a></li><li class="sub-menu-item border-box"><a class="drawer-menu-text-color border-box flex-start" href="/tools"><span class="sub-menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color sub-menu-icon fa-solid fa-tools"></i> </span>TOOLS</a></li></ul></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle border-box"><div class="main-content border-box"><div class="fade-in-down-animation"><div class="post-page-container border-box"><div class="post-content-container border-box"><div class="post-content-bottom border-box"><div class="post-title">JavaScript 数据结构与算法（十三）二叉搜索树</div><div class="post-header border-box"><div class="avatar-box border-box"><img src="/images/avatar.png"></div><div class="info-box"><div class="author border-box"><span class="name">XPoet</span> <span class="author-badge">自由程序猿</span></div><div class="meta-info border-box"><div class="post-meta-info-container border-box post"><div class="post-meta-info border-box"><span class="meta-info-item post-create-date"><i class="icon fa-solid fa-calendar-plus"></i>&nbsp; <span class="datetime">2020-08-06 16:10:00</span> </span><span class="meta-info-item post-update-date"><i class="icon fa-solid fa-file-pen"></i>&nbsp; <span class="datetime" data-updated="Thu May 23 2024 08:33:13 GMT+0000">2024-05-23 16:33:13</span> </span><span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;<ul class="post-category-ul"><li class="category-item"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul></span><span class="post-tag meta-info-item border-box"><ul class="post-tag-ul"><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">二叉搜索树</a></li></ul></span><span class="meta-info-item post-wordcount"><i class="icon fas fa-file-word"></i>&nbsp;<span>4.8k Words</span> </span><span class="meta-info-item post-min2read"><i class="icon fas fa-clock"></i>&nbsp;<span>20 Mins</span> </span><span class="meta-info-item post-pv"><i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div></div><div class="post-content keep-markdown-body"><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。</p><p>二叉搜索树是一棵二叉树，可以为空。</p><p>如果不为空，则满足以下性质：</p><ul><li>条件 1：非空左子树的所有键值小于其根节点的键值。比如三中节点 6 的所有非空左子树的键值都小于 6；</li><li>条件 2：非空右子树的所有键值大于其根节点的键值；比如三中节点 6 的所有非空右子树的键值都大于 6；</li><li>条件 3：左、右子树本身也都是二叉搜索树；</li></ul><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.1lhxcdph4vpc.png" alt="image"></p><p>如上图所示，树二和树三符合 3 个条件属于二叉树，树一不满足条件 3 所以不是二叉树。</p><p>总结：二叉搜索树的特点主要是较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中“搜索”的来源。</p><h3 id="二叉搜索树应用举例"><a href="#二叉搜索树应用举例" class="headerlink" title="二叉搜索树应用举例"></a>二叉搜索树应用举例</h3><p>下面是一个二叉搜索树：</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3l21fsg6qbc0.png" alt="image"></p><p>若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。</p><ul><li>第 1 次：将 10 与根节点 9 进行比较，由于 10 &gt; 9，所以 10 下一步与根节点 9 的右子节点 13 比较；</li><li>第 2 次：由于 10 &lt; 13，所以 10 下一步与父节点 13 的左子节点 11 比较；</li><li>第 3 次：由于 10 &lt; 11，所以 10 下一步与父节点 11 的左子节点 10 比较；</li><li>第 4 次：由于 10 &#x3D; 10，最终查找到数据 10。</li></ul><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.5x9xyvmbxy80.png" alt="image"></p><p>同样是 15 个数据，在排序好的数组中查询数据 10，需要查询 10 次：</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.2gqz4t2jekw0.png" alt="image"></p><p>其实：如果是排序好的数组，可以通过二分查找：第一次找 9，第二次找 13，第三次找 15…。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树。这就是数组二分法查找效率之所以高的原因。</p><h3 id="二叉搜索树的封装"><a href="#二叉搜索树的封装" class="headerlink" title="二叉搜索树的封装"></a>二叉搜索树的封装</h3><p>二叉搜索树有四个最基本的属性：指向节点的根（root），节点中的键（key）、左指针（right）、右指针（right）。</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.5vdbb5to1n40.png" alt="image"></p><p>所以，二叉搜索树中除了定义 root 属性外，还应定义一个节点内部类，里面包含每个节点中的 left、right 和 key 三个属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的常见操作："><a href="#二叉搜索树的常见操作：" class="headerlink" title="二叉搜索树的常见操作："></a>二叉搜索树的常见操作：</h4><ul><li><code>insert(key)</code> 向树中插入一个新的键。</li><li><code>search(key)</code> 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 <code>false</code>。</li><li><code>preOrderTraverse</code> 通过先序遍历方式遍历所有节点。</li><li><code>inOrderTraverse</code> 通过中序遍历方式遍历所有节点。</li><li><code>postOrderTraverse</code> 通过后序遍历方式遍历所有节点。</li><li><code>min</code> 返回树中最小的值&#x2F;键。</li><li><code>max</code> 返回树中最大的值&#x2F;键。</li><li><code>remove(key)</code> 从树中移除某个键。</li></ul><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>实现思路：</p><ul><li>首先根据传入的 key 创建节点对象。</li><li>然后判断根节点是否存在，不存在时通过：this.root &#x3D; newNode，直接把新节点作为二叉搜索树的根节点。</li><li>若存在根节点则重新定义一个内部方法 <code>insertNode()</code> 用于查找插入点。</li></ul><p>insert(key) 代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert(key) 插入数据</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insertNode() 的实现思路：</p><p>根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。</p><ul><li><p>当 newNode.key &lt; node.key 向左查找：</p><ul><li><p>情况 1：当 node 无左子节点时，直接插入：</p></li><li><p>情况 2：当 node 有左子节点时，递归调用 insertNode()，直到遇到无左子节点成功插入 newNode 后，不再符合该情况，也就不再调用 insertNode()，递归停止。</p></li></ul></li><li><p>当 newNode.key &gt;&#x3D; node.key 向右查找，与向左查找类似：</p><ul><li><p>情况 1：当 node 无右子节点时，直接插入：</p></li><li><p>情况 2：当 node 有右子节点时，依然递归调用 insertNode()，直到遇到传入 insertNode 方法 的 node 无右子节点成功插入 newNode 为止。</p></li></ul></li></ul><p>insertNode(root, node) 代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">insertNode</span>(<span class="params">root, node</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">key</span> &lt; root.<span class="property">key</span>) &#123; <span class="comment">// 往左边查找插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      root.<span class="property">left</span> = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(root.<span class="property">left</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 往右边查找插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      root.<span class="property">right</span> = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(root.<span class="property">right</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h4><p>这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：</p><ul><li>先序遍历；</li><li>中序遍历；</li><li>后序遍历；</li></ul><p>还有层序遍历，使用较少。</p><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p>先序遍历的过程为：</p><p>首先，遍历根节点；<br>然后，遍历其左子树；<br>最后，遍历其右子树；</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.69ooahvtbbo0.png" alt="image"></p><p>如上图所示，二叉树的节点遍历顺序为：A -&gt; B -&gt; D -&gt; H -&gt; I -&gt; E -&gt; C -&gt; F -&gt; G。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历（根左右 DLR）</span></span><br><span class="line"><span class="title function_">preorderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">preorderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">preorderTraversalNode</span>(<span class="params">node, result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  result.<span class="title function_">push</span>(node.<span class="property">key</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">preorderTraversalNode</span>(node.<span class="property">left</span>, result);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">preorderTraversalNode</span>(node.<span class="property">right</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p><p>首先，遍历其左子树；<br>然后，遍历根（父）节点；<br>最后，遍历其右子树；</p><p>过程图解：</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.762l4sxdr7o0.png" alt="image"></p><p>输出节点的顺序应为：3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 14 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 25。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历（左根右 LDR）</span></span><br><span class="line"><span class="title function_">inorderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">inorderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inorderTraversalNode</span>(<span class="params">node, result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">inorderTraversalNode</span>(node.<span class="property">left</span>, result);</span><br><span class="line">  result.<span class="title function_">push</span>(node.<span class="property">key</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">inorderTraversalNode</span>(node.<span class="property">right</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p><p>首先，遍历其左子树；<br>然后，遍历其右子树；<br>最后，遍历根（父）节点；</p><p>过程图解：</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.5lqmen4jds80.png" alt="image"></p><p>输出节点的顺序应为：3 -&gt; 6 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 9 -&gt; 7 -&gt; 12 -&gt; 14 -&gt; 13 -&gt; 18 -&gt; 25 -&gt; 20 -&gt; 15 -&gt; 11。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历（左右根 LRD）</span></span><br><span class="line"><span class="title function_">postorderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">postorderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">postorderTraversalNode</span>(<span class="params">node, result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">postorderTraversalNode</span>(node.<span class="property">left</span>, result);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">postorderTraversalNode</span>(node.<span class="property">right</span>, result);</span><br><span class="line">  result.<span class="title function_">push</span>(node.<span class="property">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。</p><h4 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h4><h5 id="查找最大值或最小值"><a href="#查找最大值或最小值" class="headerlink" title="查找最大值或最小值"></a>查找最大值或最小值</h5><p>在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左&#x2F;右查找就能得到最值，如下图所示：</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3h3yfhyqgi00.png" alt="image"></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// min() 获取二叉搜索树最小值</span></span><br><span class="line"><span class="title function_">min</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">  <span class="keyword">while</span> (node.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    node = node.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node.<span class="property">key</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max() 获取二叉搜索树最大值</span></span><br><span class="line"><span class="title function_">max</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">  <span class="keyword">while</span> (node.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    node = node.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node.<span class="property">key</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找特定值"><a href="#查找特定值" class="headerlink" title="查找特定值"></a>查找特定值</h5><p>查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的 key 值与之比较，若 node.key &lt; root 则向左查找，若 node.key &gt; root 就向右查找，直到找到或查找到 null 为止。这里可以使用递归实现，也可以采用循环来实现。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search(key) 查找二叉搜索树中是否有相同的 key，存在返回 true，否则返回 false</span></span><br><span class="line"><span class="title function_">search</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过递归实现</span></span><br><span class="line"><span class="title function_">searchNode</span>(<span class="params">node, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (key &lt; node.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(node.<span class="property">left</span>, key);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(node.<span class="property">right</span>, key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 while 循环实现</span></span><br><span class="line"><span class="title function_">search2</span>(<span class="params">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      node = node.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      node = node.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>实现思路：</p><p>第一步：先找到需要删除的节点，若没找到，则不需要删除；</p><p>首先定义变量 current 用于保存需要删除的节点、变量 parent 用于保存它的父节点、变量 isLeftChild 保存 current 是否为 parent 的左节点，这样方便之后删除节点时改变相关节点的指向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line"><span class="keyword">let</span> parentNode = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild</span></span><br><span class="line"><span class="keyword">while</span> (currentNode.<span class="property">key</span> !== key) &#123;</span><br><span class="line">  parentNode = currentNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 小于，往左查找</span></span><br><span class="line">  <span class="keyword">if</span> (key &lt; currentNode.<span class="property">key</span>) &#123;</span><br><span class="line">    isLeftChild = <span class="literal">true</span>;</span><br><span class="line">    currentNode = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则往右查找</span></span><br><span class="line">    isLeftChild = <span class="literal">false</span>;</span><br><span class="line">    currentNode = currentNode.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到最后都没找到相等的节点，返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (currentNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：删除找到的指定节点，后分 3 种情况：</p><ul><li>删除的是叶子节点；</li><li>删除的是只有一个子节点的节点；</li><li>删除的是有两个子节点的节点；</li></ul><h5 id="删除的是叶子节点"><a href="#删除的是叶子节点" class="headerlink" title="删除的是叶子节点"></a>删除的是叶子节点</h5><p>删除的是叶子节点分两种情况：</p><ul><li><p>叶子节点也是根节点</p><p>当该叶子节点为根节点时，如下图所示，此时 current &#x3D;&#x3D; this.root，直接通过：this.root &#x3D; null，删除根节点。</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.1j9353rx9b7k.png" alt="image"></p></li><li><p>叶子节点不为根节点</p><p>当该叶子节点不为根节点时也有两种情况，如下图所示</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3r99a6ocvug0.png" alt="image"></p><p>若 current &#x3D; 8，可以通过：parent.left &#x3D; null，删除节点 8；</p><p>若 current &#x3D; 10，可以通过：parent.right &#x3D; null，删除节点 10；</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、删除的是叶子节点的情况</span></span><br><span class="line"><span class="keyword">if</span> (currentNode.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; currentNode.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">    parentNode.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parentNode.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、删除的是只有一个子节点的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="删除的是只有一个子节点的节点"><a href="#删除的是只有一个子节点的节点" class="headerlink" title="删除的是只有一个子节点的节点"></a>删除的是只有一个子节点的节点</h5><p>有六种情况：</p><p>当 current 存在左子节点时（current.right &#x3D;&#x3D; null）：</p><ul><li><p>情况 1：current 为根节点（current &#x3D;&#x3D; this.root），如节点 11，此时通过：this.root &#x3D; current.left，删除根节点 11；</p></li><li><p>情况 2：current 为父节点 parent 的左子节点（isLeftChild &#x3D;&#x3D; true），如节点 5，此时通过：parent.left &#x3D; current.left，删除节点 5；</p></li><li><p>情况 3：current 为父节点 parent 的右子节点（isLeftChild &#x3D;&#x3D; false），如节点 9，此时通过：parent.right &#x3D; current.left，删除节点 9；</p></li></ul><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.27lwqd0qfnpc.png" alt="image"></p><p>当 current 存在右子节点时（current.left &#x3D; null）：</p><ul><li><p>情况 4：current 为根节点（current &#x3D;&#x3D; this.root），如节点 11，此时通过：this.root &#x3D; current.right，删除根节点 11。</p></li><li><p>情况 5：current 为父节点 parent 的左子节点（isLeftChild &#x3D;&#x3D; true），如节点 5，此时通过：parent.left &#x3D; current.right，删除节点 5；</p></li><li><p>情况 6：current 为父节点 parent 的右子节点（isLeftChild &#x3D;&#x3D; false），如节点 9，此时通过：parent.right &#x3D; current.right，删除节点 9；</p></li></ul><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3edzg72fx7y0.png" alt="image"></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、删除的是只有一个子节点的节点</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.<span class="property">right</span> === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在左节点</span></span><br><span class="line">  <span class="comment">//-- 2.1、currentNode 只存在&lt;左节点&gt;的情况</span></span><br><span class="line">  <span class="comment">//---- 2.1.1、currentNode 等于 root</span></span><br><span class="line">  <span class="comment">//---- 2.1.2、parentNode.left 等于 currentNode</span></span><br><span class="line">  <span class="comment">//---- 2.1.3、parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">    parentNode.<span class="property">left</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parentNode.<span class="property">right</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.<span class="property">left</span> === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在右节点</span></span><br><span class="line">  <span class="comment">//-- 2.2、currentNode 只存在&lt;右节点&gt;的情况</span></span><br><span class="line">  <span class="comment">//---- 2.1.1 currentNode 等于 root</span></span><br><span class="line">  <span class="comment">//---- 2.1.1 parentNode.left 等于 currentNode</span></span><br><span class="line">  <span class="comment">//---- 2.1.1 parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">    parentNode.<span class="property">left</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parentNode.<span class="property">right</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="删除的是有两个子节点的节点"><a href="#删除的是有两个子节点的节点" class="headerlink" title="删除的是有两个子节点的节点"></a>删除的是有两个子节点的节点</h5><p>这种情况十分复杂，首先依据以下二叉搜索树，讨论这样的问题：</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4g0geeyv6ya0.png" alt="image"></p><p><strong>删除节点 9</strong></p><p>在保证删除节点 9 后原二叉树仍为二叉搜索树的前提下，有两种方式：</p><ul><li>方式 1：从节点 9 的左子树中选择一合适的节点替代节点 9，可知节点 8 符合要求；</li><li>方式 2：从节点 9 的右子树中选择一合适的节点替代节点 9，可知节点 10 符合要求；</li></ul><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.73rduwimfvo0.png" alt="image"></p><p><strong>删除节点 7</strong></p><p>在保证删除节点 7 后原二叉树仍为二叉搜索树的前提下，也有两种方式：</p><ul><li>方式 1：从节点 7 的左子树中选择一合适的节点替代节点 7，可知节点 5 符合要求；</li><li>方式 2：从节点 7 的右子树中选择一合适的节点替代节点 7，可知节点 8 符合要求；</li></ul><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.2h9hjd5bhwo0.png" alt="image"></p><p><strong>删除节点 15</strong></p><p>在保证删除节点 15 后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：</p><ul><li>方式 1：从节点 15 的左子树中选择一合适的节点替代节点 15，可知节点 14 符合要求；</li><li>方式 2：从节点 15 的右子树中选择一合适的节点替代节点 15，可知节点 18 符合要求；</li></ul><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4f5tzwdvueq0.png" alt="image"></p><p>相信你已经发现其中的规律了！</p><p>规律总结：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点下面的子节点中找到一个合适的节点，来替换当前的节点。</p><p>若用 current 表示需要删除的节点，则合适的节点指的是：</p><ul><li>current 左子树中比 current 小一点点的节点，即 current 左子树中的最大值；</li><li>current 右子树中比 current 大一点点的节点，即 current 右子树中的最小值；</li></ul><h6 id="前驱-amp-后继"><a href="#前驱-amp-后继" class="headerlink" title="前驱&amp;后继"></a>前驱&amp;后继</h6><p>在二叉搜索树中，这两个特殊的节点有特殊的名字：</p><ul><li>比 current 小一点点的节点，称为 current 节点的前驱。比如下图中的节点 5 就是节点 7 的前驱；</li><li>比 current 大一点点的节点，称为 current 节点的后继。比如下图中的节点 8 就是节点 7 的后继；</li></ul><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.71vg0g9z7io0.png" alt="image"></p><p>查找需要被删除的节点 current 的后继时，需要在 current 的右子树中查找最小值，即在 current 的右子树中一直向左遍历查找；</p><p>查找前驱时，则需要在 current 的左子树中查找最大值，即在 current 的左子树中一直向右遍历查找。</p><p>下面只讨论查找 current 后继的情况，查找前驱的原理相同，这里暂不讨论。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 3、删除的是有两个子节点的节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、找到后续节点</span></span><br><span class="line">    <span class="keyword">let</span> successor = <span class="variable language_">this</span>.<span class="title function_">getSuccessor</span>(currentNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断是否为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.<span class="property">left</span> = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.<span class="property">right</span> = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将后续的左节点改为被删除的左节点</span></span><br><span class="line">    successor.<span class="property">left</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取后续节点，即从要删除的节点的右边开始查找最小的值</span></span><br><span class="line"><span class="title function_">getSuccessor</span>(<span class="params">delNode</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义变量，保存要找到的后续</span></span><br><span class="line">  <span class="keyword">let</span> successor = delNode;</span><br><span class="line">  <span class="keyword">let</span> current = delNode.<span class="property">right</span>;</span><br><span class="line">  <span class="keyword">let</span> successorParent = delNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找 current 的右子树节点</span></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    successorParent = successor;</span><br><span class="line">    successor = current;</span><br><span class="line">    current = current.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断寻找到的后续节点是否直接就是要删除节点的 right</span></span><br><span class="line">  <span class="keyword">if</span> (successor !== delNode.<span class="property">right</span>) &#123;</span><br><span class="line">    successorParent.<span class="property">left</span> = successor.<span class="property">right</span>;</span><br><span class="line">    successor.<span class="property">right</span> = delNode.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">  <span class="keyword">let</span> parentNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild</span></span><br><span class="line">  <span class="keyword">while</span> (currentNode.<span class="property">key</span> !== key) &#123;</span><br><span class="line"></span><br><span class="line">    parentNode = currentNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于，往左查找</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; currentNode.<span class="property">key</span>) &#123;</span><br><span class="line">      isLeftChild = <span class="literal">true</span>;</span><br><span class="line">      currentNode = currentNode.<span class="property">left</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则往右查找</span></span><br><span class="line">      isLeftChild = <span class="literal">false</span>;</span><br><span class="line">      currentNode = currentNode.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最后都没找到相等的节点，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、删除的是叶子节点的情况</span></span><br><span class="line">  <span class="keyword">if</span> (currentNode.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; currentNode.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、删除的是只有一个子节点的节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.<span class="property">right</span> === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在左节点</span></span><br><span class="line">    <span class="comment">//-- 2.1、currentNode 只存在&lt;左节点&gt;的情况</span></span><br><span class="line">    <span class="comment">//---- 2.1.1、currentNode 等于 root</span></span><br><span class="line">    <span class="comment">//---- 2.1.2、parentNode.left 等于 currentNode</span></span><br><span class="line">    <span class="comment">//---- 2.1.3、parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.<span class="property">left</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.<span class="property">right</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.<span class="property">left</span> === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在右节点</span></span><br><span class="line">    <span class="comment">//-- 2.2、currentNode 只存在&lt;右节点&gt;的情况</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 currentNode 等于 root</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 parentNode.left 等于 currentNode</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.<span class="property">left</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.<span class="property">right</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、删除的是有两个子节点的节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、找到后续节点</span></span><br><span class="line">    <span class="keyword">let</span> successor = <span class="variable language_">this</span>.<span class="title function_">getSuccessor</span>(currentNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断是否为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.<span class="property">left</span> = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.<span class="property">right</span> = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将后续的左节点改为被删除的左节点</span></span><br><span class="line">    successor.<span class="property">left</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取后续节点，即从要删除的节点的右边开始查找最小的值</span></span><br><span class="line"><span class="title function_">getSuccessor</span>(<span class="params">delNode</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义变量，保存要找到的后续</span></span><br><span class="line">  <span class="keyword">let</span> successor = delNode;</span><br><span class="line">  <span class="keyword">let</span> current = delNode.<span class="property">right</span>;</span><br><span class="line">  <span class="keyword">let</span> successorParent = delNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找 current 的右子树节点</span></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    successorParent = successor;</span><br><span class="line">    successor = current;</span><br><span class="line">    current = current.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断寻找到的后续节点是否直接就是要删除节点的 right</span></span><br><span class="line">  <span class="keyword">if</span> (successor !== delNode.<span class="property">right</span>) &#123;</span><br><span class="line">    successorParent.<span class="property">left</span> = successor.<span class="property">right</span>;</span><br><span class="line">    successor.<span class="property">right</span> = delNode.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>二叉搜索树的缺陷：当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树由 11 7 15 组成，如下图所示：</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.1nkd51rg5dz4.png" alt="image"></p><p>当插入一组有序数据：6 5 4 3 2 就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。</p><p><img lazyload alt="image" data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.154bnlgtd5z4.png" alt="image"></p><p>非平衡树</p><ul><li>比较好的二叉搜索树，它的数据应该是左右均匀分布的。</li><li>但是插入连续数据后，二叉搜索树中的数据分布就变得不均匀了，我们称这种树为非平衡树。</li><li>对于一棵平衡二叉树来说，插入&#x2F;查找等操作的效率是 O(log n)。</li><li>而对于一棵非平衡二叉树来说，相当于编写了一个链表，查找效率变成了 O(n)。</li></ul><p>树的平衡性</p><p>为了能以较快的时间 O(log n) 来操作一棵树，我们需要保证树总是平衡的：</p><ul><li>起码大部分是平衡的，此时的时间复杂度也是接近 O(log n) 的；</li><li>这就要求树中每个节点左边的子孙节点的个数，应该尽可能地等于右边的子孙节点的个数；</li></ul><p>常见的平衡树</p><ul><li>AVL 树：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于 AVL 树是平衡树，所以它的时间复杂度也是 O(log n)。但是它的整体效率不如红黑树，开发中比较少用。</li><li>红黑树：同样通过一些特性来保持树的平衡，时间复杂度也是 O(log n)。进行插入&#x2F;删除等操作时，性能优于 AVL 树，所以平衡树的应用基本都是红黑树。</li></ul></div><div class="post-copyright-info-container border-box"><div class="copyright-info-content border-box"><div class="copyright-info-top border-box"><div class="copyright-post-title border-box text-ellipsis">JavaScript 数据结构与算法（十三）二叉搜索树</div><div class="copyright-post-link border-box text-ellipsis">post/e35d97c028eb/</div></div><div class="copyright-info-bottom border-box"><div class="copyright-post-author bottom-item"><div class="type">Author</div><div class="content">XPoet</div></div><div class="post-time bottom-item"><div class="type">Published</div><div class="content">2020-08-06 16:10</div></div><div class="post-license bottom-item"><div class="type">License</div><div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed" target="_blank"><i class="fa-brands fa-creative-commons"></i> <i class="fa-brands fa-creative-commons-by"></i> <i class="fa-brands fa-creative-commons-nc"></i> <i class="fa-brands fa-creative-commons-sa"></i></a></div></div></div><i class="copyright-bg fa-solid fa-copyright"></i></div><div class="copy-copyright-info flex-center tooltip" data-tooltip-content="Copy copyright info" data-tooltip-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div><div class="post-bottom-tags-and-share border-box"><div><ul class="post-tags-box border-box"><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">二叉搜索树</a></li></ul></div><div><div class="post-share-container border-box"><ul class="share-list-wrap border-box"><li class="qq share-item border-box flex-center tooltip" data-tooltip-content="Share to QQ"><i class="fa-brands fa-qq"></i></li><li class="wechat share-item border-box flex-center tooltip tooltip-img" data-tooltip-content="Share to WeChat" data-tooltip-img-tip="Scan by WeChat" data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"><i class="fa-brands fa-weixin"></i></li><li class="weibo share-item border-box flex-center tooltip" data-tooltip-content="Share to WeiBo"><i class="fa-brands fa-weibo"></i></li></ul></div></div></div><div class="reward-author-container border-box flex-center"><div class="reward-btn border-box flex-center tooltip tooltip-img" data-tooltip-img-url="/images/admire-code.png" data-tooltip-img-trigger="click" data-tooltip-img-style="top: -6px;"><i class="fa-solid fa-gift"></i>&nbsp;REWARD AUTHOR</div></div><div class="post-nav border-box"><div class="prev-post"><a class="prev" rel="prev" href="/post/b47bb8401ee1/" title="JavaScript 数据结构与算法（十四）图"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">JavaScript 数据结构与算法（十四）图</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="next-post"><a class="next" rel="next" href="/post/070b16d562fc/" title="JavaScript 数据结构与算法（十二）二叉树"><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">JavaScript 数据结构与算法（十二）二叉树</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comments-container border-box"><div id="comments-anchor" class="comment-area-title border-box"><i class="fas fa-comments"></i>&nbsp;Comments</div><div class="comment-plugin-fail border-box"><span class="fail-tip">Comment plugin failed to load</span> <button class="reload keep-button">Click to reload</button></div><div class="comment-plugin-loading flex-center border-box"><i class="loading-icon fa-solid fa-spinner fa-spin"></i> <span class="load-tip">Loading comment plugin</span></div><script data-pjax>window.KeepCommentPlugin={},window.KeepCommentPlugin.hideLoading=()=>{document.querySelector(".comments-container .comment-plugin-loading").style.display="none"},window.KeepCommentPlugin.loadFailHandle=()=>{window.KeepCommentPlugin.hideLoading();const e=document.querySelector(".comments-container .comment-plugin-fail");e.style.display="flex",e.querySelector(".reload").addEventListener("click",()=>{window.location.reload()})}</script><div class="waline-comment-container"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/3.2.1/waline.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/3.2.1/waline-meta.css"><div id="waline-comment"></div><script data-pjax>window.KeepCommentPlugin.walineOptions=JSON.parse("{}".replace(/&#34;/g,'"')),window.KeepCommentPlugin.walineOptions.el="#waline-comment",window.KeepCommentPlugin.walineOptions.comment=".post-comments-count",window.KeepCommentPlugin.walineOptions.serverURL="https://vercel-waline.xpoet.cn",window.KeepCommentPlugin.walineOptions.lang="en",window.KeepCommentPlugin.walineOptions.reaction=!0</script><script data-pjax async type="module">import{init}from"https://cdnjs.cloudflare.com/ajax/libs/waline/3.2.1/waline.js";window.KeepCommentPlugin.initWaline=()=>{init?(init(window.KeepCommentPlugin.walineOptions),window.KeepCommentPlugin.hideLoading()):setTimeout(()=>{window.KeepCommentPlugin.initWaline()},1e3)},setTimeout(()=>{window.KeepCommentPlugin.initWaline()},1200)</script></div></div></div></div><div class="pc-post-toc right-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.1.</span> <span class="nav-text">二叉搜索树应用举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">二叉搜索树的封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="nav-number">1.2.1.</span> <span class="nav-text">二叉搜索树的常见操作：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.2.</span> <span class="nav-text">插入数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.3.</span> <span class="nav-text">遍历数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">先序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">后序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.4.</span> <span class="nav-text">查找数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC%E6%88%96%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">查找最大值或最小值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%89%B9%E5%AE%9A%E5%80%BC"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">查找特定值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.5.</span> <span class="nav-text">删除数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%9A%84%E6%98%AF%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">删除的是叶子节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%9A%84%E6%98%AF%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">删除的是只有一个子节点的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%9A%84%E6%98%AF%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">删除的是有两个子节点的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E9%A9%B1-amp-%E5%90%8E%E7%BB%A7"><span class="nav-number">1.2.5.3.1.</span> <span class="nav-text">前驱&amp;后继</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">完整实现</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">平衡树</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom border-box"><footer class="footer border-box"><div class="copyright-info info-item">&copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024 &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">XPoet</a></div><div class="theme-info info-item">Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a></div><div class="deploy-info info-item"><a target="_blank" rel="nofollow" href="https://github.com/xpoet/xpoet.github.io">This site is deployed on <span class="tooltip" data-tooltip-content="GitHub Pages"><img src="/images/brands/github.png"></span></a></div><div class="count-info info-item"><span class="count-item border-box uv"><span class="item-type border-box">Unique Visitor</span> <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span> </span><span class="count-item border-box pv"><span class="item-type border-box">Page View</span> <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span></span></div></footer></div></div><div class="post-tools right-toc"><div class="post-tools-container border-box"><ul class="post-tools-list border-box"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li><li class="tools-item flex-center full-screen"><i class="fa-solid fa-expand"></i></li></ul></div></div><div class="side-tools"><div class="side-tools-container border-box"><ul class="side-tools-list side-tools-show-handle border-box"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-toggle-theme-mode flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list border-box"><li class="tools-item toggle-show-toc-tablet flex-center"><i class="fas fa-list"></i></li><li class="tools-item go-to-comments-tablet flex-center"><i class="fas fa-comment"></i></li><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center show-arrow"><i class="arrow fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><div class="tablet-post-toc-mask"><div class="tablet-post-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.1.</span> <span class="nav-text">二叉搜索树应用举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">二叉搜索树的封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="nav-number">1.2.1.</span> <span class="nav-text">二叉搜索树的常见操作：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.2.</span> <span class="nav-text">插入数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.3.</span> <span class="nav-text">遍历数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">先序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">后序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.4.</span> <span class="nav-text">查找数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC%E6%88%96%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">查找最大值或最小值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%89%B9%E5%AE%9A%E5%80%BC"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">查找特定值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.5.</span> <span class="nav-text">删除数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%9A%84%E6%98%AF%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">删除的是叶子节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%9A%84%E6%98%AF%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">删除的是只有一个子节点的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%9A%84%E6%98%AF%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">删除的是有两个子节点的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E9%A9%B1-amp-%E5%90%8E%E7%BB%A7"><span class="nav-number">1.2.5.3.1.</span> <span class="nav-text">前驱&amp;后继</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">完整实现</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">平衡树</span></a></li></ol></div></div></div></div></main><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/header-shrink.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/back2top.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/toggle-theme.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/code-block.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/libs/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/local-search.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/lazyload.min.js"></script><div class="pjax"><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/post-helper.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/toc.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/copyright-info.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/share.min.js"></script></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.initExecute()})})</script></body></html>