<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="XPoet"><meta name="description" content="XPoet&#39;s Blog"><meta name="author" content="XPoet"><title>零基础入门 JavaScript 算法 | XPoet&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/avatar.png"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/fontawesome.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/regular.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/solid.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/brands.min.css"><link rel="stylesheet" href="/css/custom.css"><script class="keep-theme-configurations">const KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"xpoet.cn",root:"/",language:"en",path:"search.json"},KEEP.theme_config={base_info:{primary_color:"#0066cc",title:"XPoet's Blog",author:"XPoet",avatar:"/images/avatar.png",logo:"/images/avatar.png",favicon:"/images/avatar.png"},menu:{home:"/",archives:"/archives",tags:"/tags",me:{children:[{about:"/about || fa-solid fa-user-graduate"},{links:"/links || fa-solid fa-link"},{tools:"/tools || fa-solid fa-tools"}]}},first_screen:{enable:!0,background_img:"/images/bg.svg",background_img_dark:"/images/bg2.svg",description:"黄色的森林分出两条路，我选择人迹更少的那一条，从此决定我一生的道路。",hitokoto:!1},social_contact:{enable:!0,links:{github:"https://github.com/XPoet",weixin:"img | /images/fp/fp-qrcode.webp",qq:null,weibo:null,zhihu:null,twitter:null,x:null,facebook:null,email:"i@xpoet.cn"}},scroll:{progress_bar:!1,percent:!0,hide_header:!0},home:{announcement:null,category:!0,tag:!0,post_datetime:"updated"},post:{author_badge:{enable:!0,level_badge:!1,custom_badge:"自由程序猿"},word_count:{wordcount:!0,min2read:!0},datetime_format:"YYYY-MM-DD HH:mm:ss",copyright_info:!0,share:!0,reward:{enable:!0,img_link:"/images/admire-code.png",text:null}},code_block:{tools:{enable:!0,style:"default"},highlight_theme:"default"},toc:{enable:!0,number:!0,expand_all:!0,init_open:!0,layout:"right"},website_count:{busuanzi_count:{enable:!0,site_uv:!0,site_pv:!0,page_pv:!0}},local_search:{enable:!0,preload:!0},comment:{enable:!0,use:"waline",valine:{appid:"ih2nzG3ilVNdLgJK4kBXTjOq-gzGzoHsz",appkey:"gdf6tXXLBTLg9qpjS2y6Tbw7",server_urls:null,placeholder:"吐槽一下..."},gitalk:{github_id:null,github_admins:null,repository:null,client_id:null,client_secret:null,proxy:null},twikoo:{env_id:null,region:null,version:"1.6.36"},waline:{server_url:"https://vercel-waline.xpoet.cn",reaction:!0,version:"3.2.1"},giscus:{repo:"XPoet/xpoet.github.io",repo_id:"MDEwOlJlcG9zaXRvcnkzMjk0NzQ2NzM=",category:"Announcements",category_id:"DIC_kwDOE6Nicc4CZnkm",reactions_enabled:!0},artalk:{server:null},disqus:{shortname:null}},rss:{enable:!0},lazyload:{enable:!0},cdn:{enable:!0,provider:"cdnjs"},pjax:{enable:!0},footer:{since:2020,word_count:!1,site_deploy:{enable:!0,provider:"github",url:"https://github.com/xpoet/xpoet.github.io"},record:{enable:!1,list:[{code:null,link:null}]}},inject:{enable:!0,css:["/css/custom.css"],js:[null]},root:"",source_data:{links:[{title:"宝藏博主们"},{name:"不知名艺术家",link:"https://jinzhanqi.com/",description:"love artist, love code.",avatar:"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{name:"爱·绮梦",link:"https://x.iqimeng.com/",description:"学而时习之 不亦说乎",avatar:"https://x.iqimeng.com/images/avatar.jpg"},{name:"Keep learning",link:"https://blog.gooday.press",description:"爱好学习，不断提升自我",avatar:"https://cdn.statically.io/gh/cemonliu/blogpic@main/avatar.svg"},{name:"CitingNutria",link:"https://citingnutria.github.io/",description:"まだ夢がある",avatar:"https://cdn.statically.io/gh/CitingNutria/image_hosting@master/avatar.jpg"},{name:"Xcbyao",link:"https://xcbyao.github.io/",description:"要么庸俗，要么孤独！",avatar:"https://xcbyao.github.io/images/avatar.png"},{name:"Ycr's Blog",link:"https://www.ycr10.cn/",description:"喜欢你的人一直有空，什么都懂，无所不能。",avatar:"https://www.ycr10.cn/wp-content/uploads/2022/02/cropped-Ycr_logo.jpg"},{name:"小龙的跋涉",link:"https://www.eduorg.ltd/",description:"但行好事，莫问前程",avatar:"https://cdn.statically.io/gh/Xiaolong00/raines-photo@master/blog/favicon.42reb4izcgs0.png"},{name:"recovxy",link:"https://naiv.xyz/",description:"在人生的中途，我发现我已经迷失了正路，走进了一座幽暗森林······",avatar:"https://naiv.xyz/assets/blogImg/logo.jpg"},{name:"KAI'S NOTE",link:"https://kainote.top/",description:"三天打鱼 (⊙ˍ⊙) 两天晒网",avatar:"https://s2.loli.net/2022/01/09/UtbhxHv2IA8jqwZ.jpg"},{name:"xustudyxu",link:"https://frxcat.fun/",description:"一起学习编程！",avatar:"https://cdn.statically.io/gh/xustudyxu/image-hosting@master/20220627/mmexport1656324824543.124zxwkqyzlc.webp"},{name:"CalvinHaynes 的博客",link:"https://blog.calvinhaynes.top/",description:"慢慢走才会快",avatar:"https://cdn.statically.io/gh/CalvinHaynes/ImageHub@main/Icon/avatar.jpg"},{name:"一座浮岛",link:"https://anlondon.cn/",description:"🤪我的小站🤪",avatar:"https://anlondon.cn/images/logo_my.png"},{name:"有意栽花花满枝",link:"https://blog.hjroyal.top",description:"心中有光、点亮生活",avatar:"https://blog.hjroyal.top/img/profile.webp"},{name:"荣 6 的博客",link:"http://rong6.cn/",description:"钻研信息技术的屑",avatar:"https://img2.huashi6.com/images/resource/u275992/2021/08/04/108889_59388969493.jpg?imageMogr2/quality/75/interlace/1/thumbnail/x1400/gravity/Center/crop/1400x1400/format/webp"},{name:"程序员小明",link:"https://mynamecoder.com",description:"一个很少加班的程序员",avatar:"https://mynamecoder.com/images/avatar.png"},{name:"倚栏听风",link:"https://iweek.eu.org/",description:"十八线运维的工作笔记。",avatar:"https://s1.vika.cn/space/2023/02/17/0c1c4a6b023b42f38aaf39d480206e26"},{name:"Ssk-wh`s Blog",link:"https://ssk-wh.github.io",avatar:"https://ssk-wh.github.io/images/logo.svg",description:"假如走运了呢"},{name:"XTZYJ の技术小屋",link:"https://xtzyj.top/",description:"办法总比困难多。",avatar:"https://xtzyj.top/favicon.ico"},{name:"灯火的博客",link:"https://blog.juniverse.top/",description:"不要懒惰",avatar:"https://blog.juniverse.top/images/lights-logo.jpg"},{name:"绯鞠的博客",link:"https://loli.fj.cn",description:"一只爱折腾的绯鞠",avatar:"https://loli.fj.cn/dist/images/avatar.gif"}],icons:{"稀土掘金":{svg:'<svg t="1717059555650" class="icon" viewBox="0 0 1316 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2653" width="16" height="16"><path d="M643.181714 247.698286l154.916572-123.172572L643.181714 0.256 643.072 0l-154.660571 124.269714 154.660571 123.245715 0.109714 0.182857z m0 388.461714h0.109715l399.579428-315.245714-108.361143-87.04-291.218285 229.888h-0.146286l-0.109714 0.146285L351.817143 234.093714l-108.251429 87.04 399.433143 315.136 0.146286-0.146285z m-0.146285 215.552l0.146285-0.146286 534.893715-422.034285 108.397714 87.04-243.309714 192L643.145143 1024 10.422857 525.056 0 516.754286l108.251429-86.893715L643.035429 851.748571z" fill="#1E80FF" p-id="2654"></path></svg>',link:"https://juejin.cn/user/2700056291193374"}},tools:[{category:"AIGC",anchorId:"QUlHQw0"},{name:"ChatGPT",link:"https://chat.openai.com/",description:"OpenAI 旗下 AI 聊天对话工具",image:"/images/tools/chatgpt.svg"},{name:"Gemini",link:"https://gemini.google.com/app",description:"Google 旗下 AI 聊天对话工具",image:"/images/tools/gemini.svg"},{name:"Kimi",link:"https://kimi.moonshot.cn/",description:"帮你看更大的世界",image:"/images/tools/kimi.svg"},{name:"Copilot",link:"https://copilot.microsoft.com/",description:"微软旗下的日常 AI 助手",image:"/images/tools/copilot.png"},{name:"文心一言",link:"https://yiyan.baidu.com/",description:"百度旗下 AI 聊天对话工具",image:"/images/tools/wenxinyiyan.png"},{name:"通义千问",link:"https://tongyi.aliyun.com/qianwen/",description:"阿里巴巴旗下 AI 聊天对话工具",image:"/images/tools/tongyiqianwen.svg"},{name:"讯飞星火",link:"https://xinghuo.xfyun.cn/",description:"科大讯飞星火认知 AI 大模型",image:"/images/tools/xinghuo.svg"},{name:"Midjourney",link:"https://www.midjourney.com/",description:"AI 图像和插画生成工具",image:"/images/tools/midjourney.png"},{name:"Adobe Firefly",link:"https://firefly.adobe.com/",description:"Adobe 推出的 AI 图像生成和编辑工具",image:"/images/tools/adobe-firefly.svg"},{name:"Stable Diffusion",link:"https://stability.ai/",description:"最强开源 AI 绘画工具",image:"/images/tools/stability.png"},{name:"Microsoft Designer",link:"https://designer.microsoft.com/home",description:"微软推出的在线设计海报和宣传图工具",image:"/images/tools/microsoft-designer.svg"},{name:"文心一格",link:"https://yige.baidu.com/",description:"百度出品的 AI 绘画工具",image:"/images/tools/wenxinyiyan.png"},{name:"AI Bot",link:"https://juejin.cn/bots",description:"稀土掘金 AI Bot 工具集合",image:null},{category:"技术社区",anchorId:"JUU2JThBJTgwJUU2JTlDJUFGJUU3JUE0JUJFJUU1JThDJUJB14"},{name:"稀土掘金",link:"https://juejin.cn/",description:"一个帮助开发者成长的社区",image:"/images/tools/juejin.svg"},{name:"V2EX",link:"https://www.v2ex.com/",description:"创意工作者们的社区",image:"/images/tools/v2ex.png"},{name:"思否",link:"https://segmentfault.com/",description:"中国领先的开发者技术社区",image:"/images/tools/segmentfault.svg"},{name:"博客园",link:"https://www.cnblogs.com/",description:"开发者的网上家园",image:"/images/tools/cnblogs.png"},{name:"W2Solo",link:"https://w2solo.com/",description:"中文独立开发者社区",image:null},{name:"电鸭社区",link:"https://eleduck.com/",description:"专注远程工作招聘交流",image:"/images/tools/dianyashequ.png"},{name:"StackOverflow",link:"https://stackoverflow.com/",description:"全球最大的技术问答社区",image:"/images/tools/stackoverflow.png"},{name:"开源中国",link:"https://www.oschina.net/",description:"目前国内最大的开源技术社区",image:"/images/tools/oschina.webp"},{name:"InfoQ",link:"https://www.infoq.cn/",description:"一个实践驱动的技术社区资讯站点",image:"/images/tools/infoq.png"},{name:"51CTO",link:"https://www.51cto.com/",description:"中国领先的 IT 技术网站",image:"/images/tools/51cto.webp"},{name:"CSDN",link:"https://www.csdn.net/",description:"中文最大的技术社区",image:"/images/tools/csdn.png"},{category:"部署托管",anchorId:"JUU5JTgzJUE4JUU3JUJEJUIyJUU2JTg5JTk4JUU3JUFFJUEx26"},{name:"GitHub Pages",link:"https://pages.github.com/",description:"通过 GitHub 托管和发布的公共网页",image:"/images/tools/github.svg"},{name:"Vercel",link:"https://vercel.com/",description:"Vercel's Frontend Cloud provides the developer experience and infrastructure to build, scale, and secure a faster, more personalized web.",image:"/images/tools/vercel.svg"},{name:"Cloudflare Pages",link:"https://developers.cloudflare.com/pages/",description:"Create full-stack applications that are instantly deployed to the Cloudflare global network.",image:"/images/tools/cloudflare.svg"},{name:"Netlify",link:"https://www.netlify.com/",description:"Netlify is the essential platform for the delivery of exceptional and dynamic web experiences, without limitations.",image:"/images/tools/netlify.svg"},{name:"Railway",link:"https://railway.app/",description:"Railway is the cloud for building, shipping, and monitoring applications.",image:"/images/tools/railway.svg"},{name:"Zeabur",link:"https://zeabur.com",description:"Say goodbye to deployment hassles. With Zeabur, bring your coding genius to life swiftly and smoothly.",image:"/images/tools/zeabur.png"}]},version:"4.2.5"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},KEEP.language_code_block={copy:"Copy code",copied:"Copied",fold:"Fold code block",folded:"Folded"},KEEP.language_copy_copyright={copy:"Copy copyright info",copied:"Copied",title:"Original post title",author:"Original post author",link:"Original post link"}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="XPoet's Blog" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container border-box"><div class="page-main-content border-box"><div class="page-main-content-top"><header class="header-wrapper"><div class="border-box header-content"><div class="left flex-start border-box"><a class="logo-image border-box" href="/"><img src="/images/avatar.png"> </a><a class="site-name border-box" href="/">XPoet&#39;s Blog</a></div><div class="right border-box"><div class="pc border-box"><ul class="menu-list border-box"><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/">HOME</a></li><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/archives">ARCHIVES</a></li><li class="menu-item flex-start border-box"><a class="menu-text-color border-box" href="/tags">TAGS</a></li><li class="menu-item flex-start border-box has-sub-menu"><a class="menu-text-color border-box" href="javascript:void(0);">ME <i class="menu-text-color collapse-icon fa-solid fa-angle-down"></i></a><ul class="sub-menu-list border-box"><li class="sub-menu-item border-box"><a class="menu-text-color border-box flex-start" href="/about"><i class="menu-text-color sub-menu-icon fa-solid fa-user-graduate"></i> ABOUT</a></li><li class="sub-menu-item border-box"><a class="menu-text-color border-box flex-start" href="/links"><i class="menu-text-color sub-menu-icon fa-solid fa-link"></i> LINKS</a></li><li class="sub-menu-item border-box"><a class="menu-text-color border-box flex-start" href="/tools"><i class="menu-text-color sub-menu-icon fa-solid fa-tools"></i> TOOLS</a></li></ul></li><li class="menu-item search search-popup-trigger"><i class="menu-text-color fas search fa-search"></i></li></ul></div><div class="mobile border-box flex-start"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list border-box"><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/">HOME</a></label></li><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">ARCHIVES</a></label></li><li class="drawer-menu-item border-box not-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="/tags">TAGS</a></label></li><li class="drawer-menu-item border-box has-sub-menu"><label class="drawer-menu-label border-box"><a class="drawer-menu-text-color left-side flex-start border-box" href="javascript:void(0);">ME </a><i class="right-side collapse-icon fa-solid fa-angle-left"></i></label><ul class="drawer-sub-menu-list border-box"><li class="sub-menu-item border-box"><a class="drawer-menu-text-color border-box flex-start" href="/about"><span class="sub-menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color sub-menu-icon fa-solid fa-user-graduate"></i> </span>ABOUT</a></li><li class="sub-menu-item border-box"><a class="drawer-menu-text-color border-box flex-start" href="/links"><span class="sub-menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color sub-menu-icon fa-solid fa-link"></i> </span>LINKS</a></li><li class="sub-menu-item border-box"><a class="drawer-menu-text-color border-box flex-start" href="/tools"><span class="sub-menu-icon-wrap border-box flex-center"><i class="drawer-menu-text-color sub-menu-icon fa-solid fa-tools"></i> </span>TOOLS</a></li></ul></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle border-box"><div class="main-content border-box"><div class="fade-in-down-animation"><div class="post-page-container border-box"><div class="post-content-container border-box"><div class="post-content-bottom border-box"><div class="post-title">零基础入门 JavaScript 算法</div><div class="post-header border-box"><div class="avatar-box border-box"><img src="/images/avatar.png"></div><div class="info-box"><div class="author border-box"><span class="name">XPoet</span> <span class="author-badge">自由程序猿</span></div><div class="meta-info border-box"><div class="post-meta-info-container border-box post"><div class="post-meta-info border-box"><span class="meta-info-item post-create-date"><i class="icon fa-solid fa-calendar-plus"></i>&nbsp; <span class="datetime">2024-05-23 16:00:32</span> </span><span class="meta-info-item post-update-date"><i class="icon fa-solid fa-file-pen"></i>&nbsp; <span class="datetime" data-updated="Thu May 23 2024 15:01:12 GMT+0000">2024-05-23 23:01:12</span> </span><span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;<ul class="post-category-ul"><li class="category-item"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul></span><span class="post-tag meta-info-item border-box"><ul class="post-tag-ul"><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a></li></ul></span><span class="meta-info-item post-wordcount"><i class="icon fas fa-file-word"></i>&nbsp;<span>22.2k Words</span> </span><span class="meta-info-item post-min2read"><i class="icon fas fa-clock"></i>&nbsp;<span>86 Mins</span> </span><span class="meta-info-item post-pv"><i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div></div><div class="post-content keep-markdown-body"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提及算法，可能会有很多前端同学觉得这是一个距离自己日常工作较远的领域，认为算法并没有那么重要。事实上，这种看法是片面的，算法不仅仅是计算机科学中的一个重要概念，在前端开发中也有着广泛的应用和巨大的价值。</p><p>一个精心设计的算法可以大幅度提高应用的性能和效率，例如：如何在大量数据中快速找到指定信息、如何高效地处理用户输入、如何在动画效果中保持流畅的用户体验、如何让页面加载更快、响应更灵敏等等场景，这些都依赖于对算法的理解和应用。掌握算法能够让我们在面对复杂问题时，具备更强的分析能力和解决策略。</p><p>本文是一篇对前端同学相对友好的入门算法文章，提供一条易于理解的学习路径，从经典的排序、搜索等基础算法开始，逐步深入，再到一些高级算法设计思想，结合 LeetCode 真题实战案例分析，帮助你理解算法背后的实现逻辑，以及如何将其灵活应用于实际的前端开发场景中。</p><p>学习算法，不仅能提高编程能力，对求职面试也有很大帮助，微软、字节跳动、腾讯等公司就特别喜欢问算法。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>简单来说，排序算法用于将一组乱序的元素按照升序或降序的顺序重新排列。其性能通常通过时间复杂度、空间复杂度、稳定性等指标来衡量。</p><p>JavaScript 语言中的自带的排序：数组的 <code>sort</code> 方法。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序（Bubble Sort）是一种简单的比较排序算法。它重复地遍历待排序数组，每次比较相邻的两个元素，如果顺序相反则进行交换。这样，每一轮遍历都会将最大（或最小）的元素“冒泡”到顶端，直到整个数组都排序完成，最终达到完全有序。</p><p>步骤：</p><ol><li><strong>遍历数组</strong>：从头到尾遍历数组，比较相邻的两个元素。</li><li><strong>比较相邻元素</strong>：每次比较相邻的两个元素，如果它们的顺序不正确（比如，前一个元素大于后一个元素），则交换它们。</li><li><strong>重复遍历</strong>：重复上述步骤，直到没有任何一对元素需要交换，即数组已经完全排序。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查输入是否为数组且长度大于 1，若不满足条件，则直接返回原数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最后一个未排序元素的索引</span></span><br><span class="line">    <span class="keyword">let</span> lastIndex = array.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当还有未排序的元素时，执行排序过程</span></span><br><span class="line">    <span class="keyword">while</span> (lastIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化交换标志为 true，若本轮未发生交换，则排序完成</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 记录最后一次交换元素的位置，初始设置为未排序部分的末尾</span></span><br><span class="line">        <span class="keyword">const</span> k = lastIndex</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历未排序部分的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="comment">// 若当前元素大于其后面的元素，则交换它们的位置</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span> <span class="comment">// 发生了交换，将标志设置为 false</span></span><br><span class="line">                lastIndex = j <span class="comment">// 记录最后一次交换的位置</span></span><br><span class="line">                ;[array[j], array[j + <span class="number">1</span>]] = [array[j + <span class="number">1</span>], array[j]] <span class="comment">// 交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若本轮未发生交换，则数组已经有序，直接退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回排序后的数组</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bubbleSort</span>([<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>冒泡排序有几种可以优化的空间：</p><ul><li><strong>优化遍历范围</strong>：在每一轮排序中，可以观察到最后一次交换发生的位置之后的元素已经是有序的，因此可以将下一轮排序的范围限定在上一轮最后一次交换的位置之前。这样可以减少不必要的比较和交换操作。</li><li><strong>添加标志位</strong>：如果在一轮排序过程中没有发生任何元素的交换，说明数组已经是有序的，可以提前结束排序过程。</li><li><strong>针对部分有序数组的优化</strong>：如果数组在初始状态下已经接近有序，可以记录下每轮排序中最后一次交换的位置，然后下一轮排序时只需要遍历到该位置即可，这样可以大大减少排序的比较次数。</li><li><strong>鸡尾酒排序（双向冒泡排序）</strong>：在一次排序过程中，既从左到右比较交换，又从右到左比较交换，可以在某些特定情况下提升效率。</li></ul><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n)<br>当输入数据已经是有序时，冒泡排序可以通过设置一个标志变量来检测是否发生了交换操作，如果在某一趟排序中没有交换操作发生，说明数组已经有序，因此可以提前结束排序过程。此时，最优时间复杂度为 O(n)。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n^2)<br>在最坏情况下，输入数据是逆序的，此时需要进行 n-1 趟排序，每一趟排序中需要进行的比较次数逐渐减少，总比较次数为 n(n-1)&#x2F;2，因此最坏时间复杂度为 O(n^2)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n^2)<br>在一般情况下，冒泡排序的比较和交换操作的次数与输入数据的初始排列状态有关，但总体而言其时间复杂度仍为 O(n^2)。</p></li></ul><p>空间复杂度：</p><p>冒泡排序是一种<strong>原地排序算法</strong>，它在排序过程中只需要常数级的额外空间，即只使用了少量的辅助变量，因此其空间复杂度为 O(1)。</p><p>稳定性：</p><p>冒泡排序是一种<strong>稳定排序算法</strong>。在排序过程中，如果两个相等的元素相互比较，它们不会交换位置，因此相等元素的相对位置不会改变。</p><p>冒泡排序由于其简单易懂的特性，常用于教学和小规模数据集的排序，但由于其较低的效率，通常不适合大规模数据集的排序任务。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序（Selection Sort）是一种简单的比较排序算法。它的基本思想是在未排序数组中找到最小（或最大）的元素，然后将其放置到数组的起始位置，接着在剩余的未排序部分中继续寻找最小（或最大）的元素，依次类推，直到所有元素都排序完成。</p><p>步骤：</p><ol><li><p><strong>初始状态：</strong> 将整个序列看作两部分，一部分是未排序的，一部分是已排序的（初始时已排序部分为空）。</p></li><li><p><strong>遍历未排序部分：</strong> 遍历未排序部分，找到最小（或最大）的元素。</p></li><li><p><strong>交换元素：</strong> 将找到的最小（或最大）元素与未排序部分的第一个元素交换位置，使得找到的最小元素成为已排序部分的最后一个元素。</p></li><li><p><strong>扩大已排序部分：</strong> 将已排序部分的长度增加 1，未排序部分的长度减少 1。</p></li><li><p><strong>重复：</strong> 重复以上步骤，直到所有元素都已经排序完毕。</p></li></ol><p>这个过程类似于每次从一堆未排序的卡片中选出最小（或最大）的卡片，然后放到已排序的卡片堆中。选择排序的特点是每次遍历都只进行一次交换操作，因此相对于其他排序算法，它的交换次数较少。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层循环，遍历整个数组，每次找到当前未排序部分的最小元素并放到已排序部分的末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i <span class="comment">// 设置当前循环最小元素索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层循环，从当前元素的下一个位置开始遍历，找到未排序部分的最小元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素比最小元素索引小，则更新最小元素索引</span></span><br><span class="line">            <span class="keyword">if</span> (array[minIndex] &gt; array[j]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换最小元素到当前位置</span></span><br><span class="line">        <span class="title function_">swap</span>(array, i, minIndex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = array[left]</span><br><span class="line">    array[left] = array[right]</span><br><span class="line">    array[right] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">selectionSort</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n^2)<br>无论输入数据的初始排列状态如何，选择排序总是需要进行 n(n-1)&#x2F;2 次比较，因此最优时间复杂度为 O(n^2)。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n^2)<br>同样地，在最坏情况下，选择排序仍需要进行 n(n-1)&#x2F;2 次比较，所以最坏时间复杂度为 O(n^2)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n^2)<br>由于选择排序每一趟排序所需的比较次数固定，因此其平均时间复杂度也为 O(n^2)。</p></li></ul><p>空间复杂度：</p><p>选择排序是一种<strong>原地排序算法</strong>，只需要常数级的辅助空间（通常是用于交换元素的临时变量），因此其空间复杂度为 O(1)。</p><p>稳定性：</p><p>选择排序通常<strong>不是稳定排序</strong>。在选择排序过程中，每次从未排序部分选择最小（或最大）元素并将其与未排序部分的第一个元素交换时，如果相等元素存在，原有的相对顺序可能会被打破。例如：</p><ul><li>初始数组：[3, 2, 2, 1]</li><li>第一次选择：选择最小元素 1，与第一个元素 3 交换，结果：[1, 2, 2, 3]</li><li>第二次选择：选择最小元素 2，与第二个元素 2 交换，结果：[1, 2, 2, 3]</li></ul><p>虽然这个例子没有改变相同元素的相对顺序，但在某些情况下，如处理：[2, 3, 1, 2]，第二个“2”会被提前，与第一个“2”交换，导致顺序改变。</p><p>选择排序由于其简单性和恒定的空间复杂度，适用于对内存空间要求较高但对时间效率要求不高的场景。然而，由于其 O(n^2) 的时间复杂度，选择排序在处理大规模数据集时效率较低，通常不作为首选的排序算法。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序（Insertion Sort）是一种简单的比较排序算法。它的基本思想是将待排序数组分成<strong>已排序</strong>和<strong>未排序</strong>两部分，初始时已排序部分只有一个元素（即数组的第一个元素），然后从未排序部分依次取出元素，将其插入到已排序部分的正确位置，直到所有元素都被插入完成。</p><blockquote><p>插入排序类似扑克牌思想，想象在打扑克牌，拿起来第一张，放哪里无所谓，再拿起来一张，比第一张小，放左边，继续拿，可能是中间数，就插在中间，依次把牌拿完。</p></blockquote><p>步骤：</p><ol><li><strong>初始已排序部分</strong>：初始时，将待排序数组的第一个元素视为已排序部分，其余元素视为未排序部分。</li><li><strong>遍历未排序部分</strong>：从第二个元素开始，依次遍历未排序部分的元素。</li><li><strong>插入到已排序部分</strong>：对于每个未排序部分的元素，将其与已排序部分的元素逐个比较，找到正确的插入位置。</li><li><strong>重复插入</strong>：将元素插入到已排序部分的正确位置后，已排序部分的长度增加 1，未排序部分的长度减少 1，继续重复上述步骤，直到所有元素都被插入完成。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环从 1 开始，0 位置为默认的已排序的序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = array[i] <span class="comment">// 保存当前需要排序的元素</span></span><br><span class="line">        <span class="keyword">let</span> j = i</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置</span></span><br><span class="line">        <span class="keyword">while</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将找到的位置插入元素</span></span><br><span class="line">        array[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">insertSort</span>([<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n)<br>当输入数据已经有序时，插入排序每次只需要比较一次即可确定元素的位置，无需进行交换操作。此时，最优时间复杂度为 O(n)。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n^2)<br>在最坏情况下，输入数据是逆序的。此时，插入排序需要进行大量的比较和移动操作，每次插入元素时都需要将其与已经排序的部分进行比较并移动其他元素。因此最坏时间复杂度为 O(n^2)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n^2)<br>在一般情况下，插入排序的比较和移动操作次数与输入数据的初始排列状态有关，但总体而言，其平均时间复杂度为 O(n^2)。</p></li></ul><p>空间复杂度：</p><p>插入排序是一种<strong>原地排序算法</strong>，它在排序过程中只需要常数级的额外空间（用于存储待插入的元素的临时变量），因此其空间复杂度为 O(1)。</p><p>稳定性：</p><p>插入排序是一种<strong>稳定排序算法</strong>。在插入过程中，如果待插入的元素与已排序部分的某个元素相等，插入排序会将待插入的元素放在相等元素的后面，从而保持相等元素的相对顺序不变。</p><p>插入排序由于其简单性和对小规模数据集的高效性，常用于对小型数组进行排序或在其他更复杂的排序算法（如快速排序、归并排序）的过程中处理小数据块。然而，由于其 O(n^2) 的时间复杂度，插入排序在处理大规模数据集时效率较低。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序（Shell Sort）是一种改进的插入排序算法，也被称为“缩小增量排序”。它的基本思想是通过定义一个间隔序列（称为增量序列），将待排序数组分成若干个子序列，对每个子序列进行插入排序。随着排序的进行，增量序列逐渐缩小，直到增量为 1，最后对整个数组进行插入排序。</p><p>步骤：</p><ol><li><strong>选择增量序列</strong>：定义一个增量序列，确定每个增量值（间隔），通常以递减的方式选择。</li><li><strong>分组排序</strong>：将待排序数组根据当前增量值分成若干个子序列，对每个子序列进行插入排序。</li><li><strong>逐步缩小增量</strong>：重复上述步骤，逐步缩小增量值，直到增量为 1。</li><li><strong>最终排序</strong>：当增量为 1 时，对整个数组进行一次插入排序，完成排序过程。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hillSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果输入不是数组或者数组长度小于等于 1，直接返回原数组，不需要排序</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一层循环：确定增量的大小，每次增量的大小减半</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>); gap &gt;= <span class="number">1</span>; gap = <span class="built_in">parseInt</span>(gap &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">// 对每个分组使用插入排序，相当于将插入排序的 1 换成了 gap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = array[i] <span class="comment">// 保存当前元素</span></span><br><span class="line">      <span class="keyword">let</span> j = i</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第二层循环：对当前分组进行插入排序</span></span><br><span class="line">      <span class="comment">// 如果 j - gap &gt;= 0 并且前一个元素大于当前元素，则进行交换</span></span><br><span class="line">      <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; array[j - gap] &gt; temp) &#123;</span><br><span class="line">        array[j] = array[j - gap] <span class="comment">// 将前一个元素后移</span></span><br><span class="line">        j -= gap <span class="comment">// 继续比较下一个分组内的元素</span></span><br><span class="line">      &#125;</span><br><span class="line">      array[j] = temp <span class="comment">// 插入元素到正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array <span class="comment">// 返回排序后的数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">hillSort</span>([<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><p>希尔排序的时间复杂度较为复杂，与所选的增量序列（gap sequence）有很大关系。常见的增量序列有希尔增量序列、Hibbard 增量序列、Sedgewick 增量序列等。以下是几种常见增量序列的时间复杂度分析：</p><ul><li><p><strong>希尔增量序列</strong>（gap &#x3D; n&#x2F;2, n&#x2F;4, …, 1）：最坏时间复杂度：O(n^2)</p></li><li><p><strong>Hibbard 增量序列</strong>（gap &#x3D; 2^k - 1）：最坏时间复杂度：O(n^(3&#x2F;2))</p></li><li><p><strong>Sedgewick 增量序列</strong>（一种较为复杂的序列）：最坏时间复杂度：O(n^(4&#x2F;3))</p></li><li><p><strong>更优的增量序列</strong>：有些优化过的增量序列可以达到 O(n log^2 n) 的最坏时间复杂度。</p></li></ul><p>由于增量序列的选择对希尔排序的时间复杂度有很大的影响，所以具体的时间复杂度因实现而异，但通常在 O(n^2) 和 O(n log^2 n) 之间。</p><p>空间复杂度：</p><p>希尔排序是一种<strong>原地排序算法</strong>，其空间复杂度为 O(1)，只需要常数级的额外空间。</p><p>稳定性：</p><p>希尔排序<strong>不是稳定排序</strong>。在排序过程中，元素可能会跨越多个位置进行交换，因此相同元素的相对顺序可能会被打乱。</p><p>希尔排序由于其高效性和相对简单的实现，在实际应用中有一定的优势，特别是在数据规模较大时。它通过对插入排序的改进，大大减少了数据移动的次数，从而提高了排序的效率。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序（Merge Sort）是一种基于分治法的高效排序算法。其基本思想是将数组分成更小的子数组，分别对这些子数组进行排序，然后再将它们合并起来，以得到一个有序的数组。</p><p>步骤：</p><ol><li><strong>分割（Divide）</strong>：将数组从中间分成两个子数组（递归地分割直到子数组的长度为 1）。</li><li><strong>排序（Conquer）</strong>：对每个子数组进行排序。因为子数组的长度为 1，所以它们是有序的。</li><li><strong>合并（Combine）</strong>：将两个有序的子数组合并成一个有序的数组。重复这个过程，直到所有的子数组被合并成一个完整的有序数组。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于 0，直接返回，不需要排序</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>) <span class="comment">// 找到中间索引值</span></span><br><span class="line">  <span class="keyword">const</span> left = array.<span class="title function_">slice</span>(<span class="number">0</span>, mid) <span class="comment">// 截取左半部分</span></span><br><span class="line">  <span class="keyword">const</span> right = array.<span class="title function_">slice</span>(mid, length) <span class="comment">// 截取右半部分</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right)) <span class="comment">// 递归分解后，进行排序合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">leftArray, rightArray</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> leftLength = leftArray.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> rightLength = rightArray.<span class="property">length</span></span><br><span class="line">  <span class="keyword">let</span> il = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> ir = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; leftLength &amp;&amp; ir &lt; rightLength) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftArray[il] &lt; rightArray[ir]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(leftArray[il++])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(rightArray[ir++])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; leftLength) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(leftArray[il++])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。</span></span><br><span class="line">  <span class="keyword">while</span> (ir &lt; rightLength) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(rightArray[ir++])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergeSort</span>([<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>基本过程：</p><ol><li><strong>分割</strong>：将待排序数组分成两半。</li><li><strong>递归排序</strong>：对每一半分别进行递归排序。</li><li><strong>合并</strong>：合并两个有序子数组以形成一个有序的整体。</li></ol><p>时间复杂度：</p><ol><li><strong>最优时间复杂度</strong>：O(n log n)</li><li><strong>最坏时间复杂度</strong>：O(n log n)</li><li><strong>平均时间复杂度</strong>：O(n log n)</li></ol><p>归并排序在最优、最坏和平均情况下的时间复杂度都是 O(n log n)，因为它始终将数组分成两半，然后对每一半进行排序，再合并结果。</p><p>空间复杂度：</p><p>归并排序的空间复杂度为 O(n)，这是因为归并排序在合并过程中需要一个额外的数组来暂存数据。对于递归实现，还需要考虑递归调用的栈空间，但总的额外空间仍然是 O(n)。</p><p>稳定性：</p><p>归并排序是一种<strong>稳定排序算法</strong>。在合并两个有序子数组的过程中，如果两个元素相等，先将前一个数组的元素放入结果数组中，从而保持相等元素的相对顺序不变。</p><p>归并排序由于其稳定性和 O(n log n) 的时间复杂度，常用于处理大规模数据集，尤其是在需要稳定排序的情况下。虽然归并排序的空间复杂度较高，但其分治策略使其在许多应用中表现出色。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序（Quick Sort）是一种高效的排序算法，基于分治法。它通过选择一个”基准”（pivot）元素，并将数组分成两部分，其中一部分的所有元素都小于基准，另一部分的所有元素都大于基准。然后递归地对这两部分进行排序。</p><p>步骤：</p><ol><li><strong>选择基准</strong>：从数组中选择一个元素作为基准（pivot）。</li><li><strong>分区</strong>：重新排列数组，使得所有小于基准的元素在基准的左边，所有大于基准的元素在基准的右边（相等的元素可以放在任一侧）。此时基准元素处于其正确的位置。</li><li><strong>递归排序</strong>：递归地对基准左边的子数组和右边的子数组进行排序。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于 0，直接返回，不需要排序</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择基准</span></span><br><span class="line">  <span class="keyword">const</span> pivot = array[array.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  <span class="comment">// 使用两个数组 left 和 right 来存储小于和大于基准的元素</span></span><br><span class="line">  <span class="keyword">const</span> left = []</span><br><span class="line">  <span class="keyword">const</span> right = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分区过程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(array[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归地排序左右子数组并合并</span></span><br><span class="line">  <span class="keyword">return</span> [...<span class="title function_">quickSort</span>(left), pivot, ...<span class="title function_">quickSort</span>(right)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">quickSort</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n log n)<br>当每次划分的子数组都比较均匀时，递归树的高度为 log n，每层的操作复杂度为 O(n)，所以最优时间复杂度为 O(n log n)。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n^2)<br>在最坏情况下，每次划分的子数组高度不均匀，例如每次选择的基准（pivot）是最大或最小元素，这会导致递归树退化为链表形式，时间复杂度为 O(n^2)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n log n)<br>在实际应用中，快速排序的平均性能通常很好，期望时间复杂度为 O(n log n)，因为随机选择基准或使用“三数取中”等方法可以有效避免最坏情况。</p></li></ul><p>空间复杂度：</p><p>快速排序的空间复杂度主要取决于递归调用栈的深度：</p><ul><li><p><strong>平均空间复杂度</strong>：O(log n)<br>在理想情况下，递归调用栈的深度为 log n，因此空间复杂度为 O(log n)。</p></li><li><p><strong>最坏空间复杂度</strong>：O(n)<br>在最坏情况下，递归调用栈的深度为 n，因此空间复杂度为 O(n)。</p></li></ul><p>稳定性：</p><p>快速排序<strong>不是稳定排序</strong>。在排序过程中，元素的相对顺序可能会被改变，因为基准元素的交换可能会使得相等的元素顺序颠倒。</p><p>快速排序因其高效性和较好的平均性能，广泛应用于各种排序任务。通过随机选择基准或“三数取中”等方法，可以有效地改善其性能，避免最坏情况的发生。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序（Heap Sort）是一种基于二叉堆数据结构的比较排序算法。堆排序可以分为两个阶段：构建初始堆和在堆上进行排序操作。</p><p>步骤：</p><ol><li><strong>构建最大堆</strong>：将无序数组构建成一个最大堆（max heap），最大堆是一个完全二叉树，其中每个节点的值都大于或等于其子节点的值。</li><li><strong>排序</strong>：交换堆顶元素（最大值）和堆的最后一个元素，并将堆的大小减少 1。然后对堆的根节点进行调整，使其重新成为最大堆。<br>重复上述步骤，直到堆中剩余元素只剩一个，即完成排序。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> n = array.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建最大堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">heapify</span>(array, n, i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逐一从堆中取出元素，并对剩余元素重新堆化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 将堆顶（最大值）和堆的最后一个元素交换</span></span><br><span class="line">    ;[array[<span class="number">0</span>], array[i]] = [array[i], array[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对堆的剩余部分重新堆化</span></span><br><span class="line">    <span class="title function_">heapify</span>(array, i, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆化函数，维护堆的性质</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapify</span>(<span class="params">array, n, i</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> largest = i <span class="comment">// 假设当前节点是最大值</span></span><br><span class="line">  <span class="keyword">const</span> left = <span class="number">2</span> * i + <span class="number">1</span> <span class="comment">// 左子节点</span></span><br><span class="line">  <span class="keyword">const</span> right = <span class="number">2</span> * i + <span class="number">2</span> <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果左子节点大于当前节点，则更新最大值</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt; n &amp;&amp; array[left] &gt; array[largest]) &#123;</span><br><span class="line">    largest = left</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果右子节点大于当前节点，则更新最大值</span></span><br><span class="line">  <span class="keyword">if</span> (right &lt; n &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">    largest = right</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果最大值不是当前节点，则交换并继续堆化</span></span><br><span class="line">  <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">    ;[array[i], array[largest]] = [array[largest], array[i]]</span><br><span class="line">    <span class="title function_">heapify</span>(array, n, largest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">heapSort</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n log n)<br>在最优情况下，堆排序的时间复杂度为 O(n log n)，因为构建最大堆和进行堆排序的时间复杂度都是 O(n log n)。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n log n)<br>在最坏情况下，堆排序的时间复杂度也是 O(n log n)。无论输入数据的顺序如何，都需要将数据构建成最大堆，然后进行排序。</p></li><li><p><strong>平均时间复杂度</strong>：O(n log n)</p></li></ul><p>空间复杂度：</p><p>堆排序是一种<strong>原地排序算法</strong>，它只需要常数级别的额外空间来存储堆的数据结构，因此其空间复杂度为 O(1)。</p><p>稳定性：</p><p>堆排序<strong>不是稳定排序算法</strong>。在堆排序中，可能会破坏相同元素的相对顺序，因此它不是稳定的排序算法。</p><p>堆排序由于其高效性和原地排序的特性，常用于需要稳定且较高性能的排序任务。虽然堆排序的实现相对复杂，但它的时间复杂度稳定在 O(n log n)，在实践中具有较好的性能表现。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序（Radix Sort）是一种非比较性的排序算法，它根据关键字的每个位的值来排序。基数排序适用于元素都是整数的数组，其中每个元素都有相同的位数或范围。基本思想是将待排序的元素按照位数进行分组，然后按照每一位的顺序依次排序。</p><p>步骤：</p><ol><li><p><strong>按照最低有效位进行排序</strong>：从最低位（个位）开始，将元素按照该位的值进行分组（例如 0 到 9），并按照顺序重新排列。</p></li><li><p><strong>依次对更高位进行排序</strong>：对每一位重复上述排序过程，直到按照最高位排序完成。</p></li><li><p><strong>合并分组</strong>：每次按照位数排序后，将所有分组合并为一个数组，形成新的待排序数组。</p></li><li><p><strong>重复步骤 1~3</strong>，直到所有位都被处理完毕。</p></li></ol><p>示例：</p><p>假设我们有一个无序数组 <code>[170, 45, 75, 90, 802, 24, 2, 66]</code>，使用基数排序对其进行排序：</p><ol><li><p><strong>按照个位进行排序</strong>：<br>将数字按照个位的值进行分组：<code>[170, 90, 802, 2], [24], [45, 75], [66]</code>，并按照顺序重新排列：<code>[170, 90, 802, 2, 24, 45, 75, 66]</code>。</p></li><li><p><strong>按照十位进行排序</strong>：<br>将数字按照十位的值进行分组：<code>[802, 2], [24], [45, 66], [75], [170, 90]</code>，并按照顺序重新排列：<code>[802, 2, 24, 45, 66, 75, 170, 90]</code>。</p></li><li><p><strong>按照百位进行排序</strong>（如果有的话）。</p></li><li><p>排序完成，得到有序数组 <code>[2, 24, 45, 66, 75, 90, 170, 802]</code>。</p></li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数字的指定位数上的数字</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDigit</span>(<span class="params">num, place</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(num) / <span class="number">10</span> ** place) % <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数字的位数（最大位数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">digitCount</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">log10</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(num))) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中最大数字的位数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mostDigits</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> maxDigits = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    maxDigits = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxDigits, <span class="title function_">digitCount</span>(nums[i]))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxDigits</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">radixSort</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> maxDigitCount = <span class="title function_">mostDigits</span>(nums)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; maxDigitCount; k++) &#123;</span><br><span class="line">    <span class="comment">// 创建 10 个桶（0 到 9）</span></span><br><span class="line">    <span class="keyword">const</span> digitBuckets = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">() =&gt;</span> [])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数字放入相应的桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> digit = <span class="title function_">getDigit</span>(nums[i], k)</span><br><span class="line">      digitBuckets[digit].<span class="title function_">push</span>(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并所有桶中的数字成为新的待排序数组</span></span><br><span class="line">    nums = [].<span class="title function_">concat</span>(...digitBuckets)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">radixSort</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n * k)<br>最优情况下，每个关键字的位数相同，基数排序的时间复杂度为 O(n * k)，其中 n 是元素个数，k 是关键字的位数。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n * k)<br>最坏情况下，基数排序的时间复杂度仍然为 O(n * k)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n * k)<br>基数排序的平均时间复杂度也为 O(n * k)，其中 k 通常为常数。</p></li></ul><p>基数排序的时间复杂度主要取决于关键字的位数和元素个数，与元素的大小范围无关。</p><p>空间复杂度：</p><p>基数排序的空间复杂度取决于辅助存储空间的使用，通常需要一个额外的数组来存储中间结果。因此，其空间复杂度为 O(n + k)，其中 n 是元素个数，k 是关键字的范围（通常是 10）。</p><p>稳定性：</p><p>基数排序是一种<strong>稳定排序算法</strong>。在基数排序过程中，相同位数的元素根据其原始顺序进行排序，不会改变相等元素的相对位置，因此是稳定的。</p><p>基数排序适用于处理整数或字符串等具有固定位数的元素集合。它的时间复杂度相对较低，并且是稳定排序算法，因此在一些特定的排序场景中具有一定的优势。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序（Counting Sort）是一种非比较性的排序算法，适用于待排序元素都属于一个有限范围的整数。计数排序的基本思想是通过统计待排序数组中每个元素出现的次数，然后根据统计信息将元素放置到正确的位置上。</p><p>步骤：</p><ol><li><strong>统计元素出现次数</strong>：遍历待排序数组，统计每个元素出现的次数，存储在一个辅助数组中。</li><li><strong>累加统计次数</strong>：对统计数组进行累加，使得每个位置存储的值表示小于等于该值的元素的个数。</li><li><strong>根据统计信息排序</strong>：遍历待排序数组，根据统计数组中的信息，将元素放置到正确的位置上。</li></ol><p>示例：</p><p>假设我们有一个无序数组 <code>[4, 2, 2, 8, 3, 3, 1]</code>，使用计数排序对其进行排序：</p><ol><li><p><strong>统计元素出现次数</strong>：统计数组中每个元素的出现次数：<code>[1:1, 2:2, 3:2, 4:1, 8:1]</code>。</p></li><li><p><strong>累加统计次数</strong>：将统计数组中的值进行累加：<code>[1:1, 2:3, 3:5, 4:6, 8:7]</code>，表示小于等于每个元素的个数。</p></li><li><p><strong>根据统计信息排序</strong>：根据累加统计次数，将待排序数组中的元素放置到正确的位置上，得到有序数组 <code>[1, 2, 2, 3, 3, 4, 8]</code>。</p></li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countingSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="comment">// 找到待排序数组中的最大值和最小值</span></span><br><span class="line">  <span class="keyword">let</span> min = array[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> max = array[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &lt; min) min = array[i]</span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) max = array[i]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建统计数组，长度为 max - min + 1</span></span><br><span class="line">  <span class="keyword">const</span> countArray = <span class="keyword">new</span> <span class="title class_">Array</span>(max - min + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计每个元素出现的次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    countArray[array[i] - min]++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据统计信息对元素进行排序</span></span><br><span class="line">  <span class="keyword">let</span> sortedIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; countArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (countArray[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      array[sortedIndex] = i + min</span><br><span class="line">      sortedIndex++</span><br><span class="line">      countArray[i]--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countingSort</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n + k)<br>最优情况下，计数排序的时间复杂度为 O(n + k)，其中 n 是元素个数，k 是元素的范围。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n + k)<br>最坏情况下，计数排序的时间复杂度仍然为 O(n + k)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n + k)<br>计数排序的平均时间复杂度也为 O(n + k)。</p></li></ul><p>计数排序的时间复杂度主要取决于元素的范围，而与元素的个数无关。</p><p>空间复杂度：</p><p>计数排序的空间复杂度取决于额外的计数数组和输出数组。因此，其空间复杂度为 O(n + k)，其中 n 是元素个数，k 是元素的范围。</p><p>稳定性：</p><p>计数排序是一种<strong>稳定排序算法</strong>。在计数排序中，相同元素的相对顺序不会改变，因此是稳定的。</p><p>计数排序适用于对一定范围内的整数进行排序，并且适合于元素范围不是很大的情况下。由于其时间复杂度和空间复杂度均为线性，因此在一些特定的排序场景中具有较好的性能表现。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>搜索算法简单来说就是用于找出数组中某个元素的下标。</p><p>JavaScript 语言中的自带的搜索：数组的 <code>indexOf</code> 方法。</p><h3 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h3><p>顺序搜索（Sequential Search）算法是一种简单的搜索算法，它按顺序检查列表中的每个元素，直到找到目标元素或遍历完整个列表。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sequentialSearch</span>(<span class="params">array, target</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历数组中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素等于目标元素，则返回当前元素的索引</span></span><br><span class="line">        <span class="keyword">if</span> (array[i] === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果未找到目标元素，则返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sequentialSearch</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">0</span>)) <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sequentialSearch</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>顺序搜索的时间复杂度为 O(n)，其中 n 是列表的长度。</p><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>二分搜索（Binary Search）是一种高效的搜索算法，适用于有序数组。该算法通过重复将搜索范围缩小为一半来找到目标值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr, target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span> <span class="comment">// 搜索范围的最低索引</span></span><br><span class="line">  <span class="keyword">let</span> high = arr.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// 搜索范围的最高索引</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((low + high) / <span class="number">2</span>) <span class="comment">// 中间索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid <span class="comment">// 找到目标元素，返回索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span> <span class="comment">// 目标元素在右半部分，调整搜索范围的最低索引</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span> <span class="comment">// 目标元素在左半部分，调整搜索范围的最高索引</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span> <span class="comment">// 目标元素未找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">0</span>)) <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>二分搜索的时间复杂度为 O(log n)，其中 n 是数组的长度。</p><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分而治之（分治法）是一种常见的算法设计思想，其核心是将一个大问题分解成小的子问题，分别解决这些子问题，然后将子问题的解合并起来得到原问题的解。这种思想在很多算法中都有广泛的应用，特别是在解决递归问题时很常见。</p><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol><li><strong>分解（Divide）</strong>：将原问题划分成若干个规模较小的子问题。</li><li><strong>解决（Conquer）</strong>：递归地解决这些子问题，如果子问题规模足够小，则直接求解。</li><li><strong>合并（Combine）</strong>：将子问题的解合并成原问题的解。</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>排序算法：如<strong>归并排序</strong>和<strong>快速排序</strong>。</li><li>搜索算法：如<strong>二分搜索</strong>。</li><li>数据压缩：如哈夫曼编码。</li><li>分布式计算：如 MapReduce 等。</li></ul><h4 id="分而治之的应用"><a href="#分而治之的应用" class="headerlink" title="分而治之的应用"></a>分而治之的应用</h4><h5 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/description/">LeetCode #169 简单<i class="fas fa-external-link-alt"></i></a></p><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code>，返回其中的多数元素。多数元素是指在数组中出现次数大于 <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [3, 2, 3]<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [2, 2, 1, 1, 1, 2, 2]<br>输出：2</p></blockquote><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><p>解题步骤：</p><ol><li><strong>分解</strong>：将数组分成左右两部分。</li><li><strong>解决子问题</strong>：递归地在左右两部分中分别找出多数元素。</li><li><strong>合并</strong>：<ul><li>如果左右部分的多数元素相同，则该元素即为整个数组的多数元素。</li><li>如果左右部分的多数元素不同，则需要统计这两个元素在整个数组中的出现次数，出现次数较多的元素即为多数元素。</li></ul></li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">majorityElement</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="comment">// 辅助函数：统计元素在给定区间内的出现次数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">countInRange</span>(<span class="params">nums, num, left, right</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nums[i] === num) &#123;</span><br><span class="line">            count++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 分治算法主函数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">majorityElementRec</span>(<span class="params">nums, left, right</span>) &#123;</span><br><span class="line">      <span class="comment">// 基本情况：只有一个元素时</span></span><br><span class="line">      <span class="keyword">if</span> (left === right) &#123;</span><br><span class="line">         <span class="keyword">return</span> nums[left]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将数组分成左右两部分</span></span><br><span class="line">      <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">const</span> leftMajority = <span class="title function_">majorityElementRec</span>(nums, left, mid)</span><br><span class="line">      <span class="keyword">const</span> rightMajority = <span class="title function_">majorityElementRec</span>(nums, mid + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果左右部分的多数元素相同，则返回该元素</span></span><br><span class="line">      <span class="keyword">if</span> (leftMajority === rightMajority) &#123;</span><br><span class="line">         <span class="keyword">return</span> leftMajority</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 否则统计左右多数元素在整个区间内的出现次数</span></span><br><span class="line">      <span class="keyword">const</span> leftCount = <span class="title function_">countInRange</span>(nums, leftMajority, left, right)</span><br><span class="line">      <span class="keyword">const</span> rightCount = <span class="title function_">countInRange</span>(nums, rightMajority, left, right)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回出现次数较多的元素</span></span><br><span class="line">      <span class="keyword">return</span> leftCount &gt; rightCount ? leftMajority : rightMajority</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用递归函数，从整个数组开始</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">majorityElementRec</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">majorityElement</span>([<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 输出：3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">majorityElement</span>([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])) <span class="comment">// 输出：2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">majorityElement</span>([<span class="number">1</span>])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">majorityElement</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])) <span class="comment">// 输出：1</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>时间复杂度</strong>：O(n log n)，每次递归将数组分为两部分，类似于归并排序，每层的合并操作需要线性时间，递归深度为 log n，因此总时间复杂度为 O(n log n)。</p></li><li><p><strong>空间复杂度</strong>：O(log n)，递归调用栈的深度为 log n，因此空间复杂度为 O(log n)（不包括输入和输出所占用的空间）。</p></li></ul><h5 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/description">LeetCode #912 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [5, 2, 3, 1]<br>输出：[1, 2, 3, 5]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [5, 1, 1, 2, 0, 0]<br>输出：[0, 0, 1, 1, 2, 5]</p></blockquote><p>要将一个整数数组进行排序，我们可以使用分而治之的思想，这里我们选择<strong>归并排序</strong>作为实现方法，归并排序是一种稳定的排序算法。</p><p>解题步骤：</p><ol><li><strong>递归终止条件</strong>：当数组长度小于等于 1 时，返回数组本身，因为它已经是有序的。</li><li><strong>分解数组</strong>：找到数组的中点，将数组分成左右两部分。</li><li><strong>递归排序</strong>：递归地对左右两部分进行排序。</li><li><strong>合并</strong>：合并两个有序的子数组成一个有序的数组。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortArray</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="comment">// 主函数，调用归并排序函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">mergeSort</span>(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="comment">// 基本情况：如果数组长度小于等于 1，直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (nums.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算中点</span></span><br><span class="line">   <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 分别对左右两部分进行排序</span></span><br><span class="line">   <span class="keyword">const</span> left = <span class="title function_">mergeSort</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>, mid))</span><br><span class="line">   <span class="keyword">const</span> right = <span class="title function_">mergeSort</span>(nums.<span class="title function_">slice</span>(mid))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并排序好的左右两部分</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">merge</span>(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> sortedArray = []</span><br><span class="line">   <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并两个有序数组</span></span><br><span class="line">   <span class="keyword">while</span> (i &lt; left.<span class="property">length</span> &amp;&amp; j &lt; right.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left[i] &lt; right[j]) &#123;</span><br><span class="line">         sortedArray.<span class="title function_">push</span>(left[i])</span><br><span class="line">         i++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         sortedArray.<span class="title function_">push</span>(right[j])</span><br><span class="line">         j++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将剩余的元素添加到结果数组</span></span><br><span class="line">   <span class="keyword">while</span> (i &lt; left.<span class="property">length</span>) &#123;</span><br><span class="line">      sortedArray.<span class="title function_">push</span>(left[i])</span><br><span class="line">      i++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (j &lt; right.<span class="property">length</span>) &#123;</span><br><span class="line">      sortedArray.<span class="title function_">push</span>(right[j])</span><br><span class="line">      j++</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sortedArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortArray</span>([<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// 输出：[1, 2, 3, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortArray</span>([<span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>])) <span class="comment">// 输出：[0, 0, 1, 1, 2, 5]</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(N log N)，因为数组每次都被分成两部分，并且每次合并操作的时间复杂度为 O(N)。</li><li><strong>空间复杂度</strong>：O(N)，因为归并排序需要额外的空间来存储合并后的数组。</li></ul><h5 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">LeetCode #53 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [-2, 1, -3, 4, -1, 2, 1, -5, 4]<br>输出：6<br>解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [1]<br>输出：1</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [5, 4, -1, 7, 8]<br>输出：23</p></blockquote><p>解决最大子数组和问题，分而治之的思想是一种有效的方法。分而治之的基本思想是将问题分解成子问题，分别解决这些子问题，然后合并这些子问题的解来得到原问题的解。在这个问题中，我们将数组分成两个部分，然后递归地求解左右两部分的最大子数组和，并合并两部分的结果。</p><p>解题步骤：</p><ol><li><strong>递归终止条件</strong>：当数组长度为 1 时，返回数组的唯一元素。</li><li><strong>分解数组</strong>：找到数组的中点，将数组分成左右两部分。</li><li><strong>递归求解</strong>：递归地计算左半部分和右半部分的最大子数组和。</li><li><strong>合并</strong>：计算跨越中间的最大子数组和，包括：<ul><li>从中点向左扫描的最大子数组和。</li><li>从中点向右扫描的最大子数组和。</li><li>跨越中点的最大子数组和等于左半部分的最大和加上右半部分的最大和。</li></ul></li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxSubArray</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 分治法求解最大子数组和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">divideAndConquer</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divideAndConquer</span>(<span class="params">nums, left, right</span>) &#123;</span><br><span class="line">    <span class="comment">// 基本情况：如果只有一个元素，返回该元素</span></span><br><span class="line">    <span class="keyword">if</span> (left === right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算中间点</span></span><br><span class="line">    <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归求解左半部分和右半部分的最大子数组和</span></span><br><span class="line">    <span class="keyword">const</span> leftMax = <span class="title function_">divideAndConquer</span>(nums, left, mid)</span><br><span class="line">    <span class="keyword">const</span> rightMax = <span class="title function_">divideAndConquer</span>(nums, mid + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算跨越中间点的最大子数组和</span></span><br><span class="line">    <span class="keyword">const</span> crossMax = <span class="title function_">maxCrossingSubArray</span>(nums, left, mid, right)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回三个部分中最大的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftMax, rightMax, crossMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxCrossingSubArray</span>(<span class="params">nums, left, mid, right</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算左半部分的最大子数组和</span></span><br><span class="line">    <span class="keyword">let</span> leftSum = -<span class="title class_">Infinity</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = mid; i &gt;= left; i--) &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; leftSum) &#123;</span><br><span class="line">            leftSum = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算右半部分的最大子数组和</span></span><br><span class="line">    <span class="keyword">let</span> rightSum = -<span class="title class_">Infinity</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; rightSum) &#123;</span><br><span class="line">            rightSum = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回跨越中间点的最大子数组和</span></span><br><span class="line">    <span class="keyword">return</span> leftSum + rightSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSubArray</span>([-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>])) <span class="comment">// 输出：6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSubArray</span>([<span class="number">1</span>])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSubArray</span>([<span class="number">5</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>])) <span class="comment">// 输出：23</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n log n)：每次分治将问题分成两个子问题，类似于归并排序，每次合并时需要线性的时间来计算跨越中间的最大子数组和。</li><li><strong>空间复杂度</strong>：O(log n)：递归调用的深度为 log n，因此空间复杂度为 O(log n)（不包括输入和输出所占用的空间）。</li></ul><h5 id="数组中的第-K-个最大元素"><a href="#数组中的第-K-个最大元素" class="headerlink" title="数组中的第 K 个最大元素"></a>数组中的第 K 个最大元素</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description">LeetCode #215 中等<i class="fas fa-external-link-alt"></i></a></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>示例 1:</p><blockquote><p>输入: [3, 2, 1, 5, 6, 4], k &#x3D; 2<br>输出：5</p></blockquote><p>示例 2:</p><blockquote><p>输入: [3, 2, 3, 1, 2, 4, 5, 5, 6], k &#x3D; 4<br>输出：4</p></blockquote><p>为了找到数组中的第 <code>k</code> 个最大元素，并且实现时间复杂度为 O(n) 的算法，我们可以使用<strong>快速选择算法（Quickselect）</strong>。快速选择算法是快速排序的变种，通过分而治之的方法来选择特定的第 <code>k</code> 个元素。</p><p>解题步骤：</p><ol><li><strong>选择一个主元（pivot）</strong>：通常选择数组的最后一个元素作为主元。</li><li><strong>分区</strong>：使用 Lomuto 分区方案，将数组重新排列，使得主元的位置是其最终位置，同时确保左边的元素都小于等于主元，右边的元素都大于主元。</li><li><strong>递归搜索</strong>：<ul><li>如果主元的位置正好是我们需要找的位置，直接返回主元。</li><li>如果主元的位置大于目标位置，在左半部分继续搜索。</li><li>如果主元的位置小于目标位置，在右半部分继续搜索。</li></ul></li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findKthLargest</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="comment">// 目标是找到第 k 大的元素，即排序后第 (n-k) 小的元素</span></span><br><span class="line">    <span class="keyword">const</span> targetIndex = nums.<span class="property">length</span> - k;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>, targetIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSelect</span>(<span class="params">nums, left, right, targetIndex</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="keyword">const</span> pivotIndex = <span class="title function_">partition</span>(nums, left, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pivotIndex === targetIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; targetIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">quickSelect</span>(nums, pivotIndex + <span class="number">1</span>, right, targetIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">quickSelect</span>(nums, left, pivotIndex - <span class="number">1</span>, targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">nums, left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> pivot = nums[right];</span><br><span class="line">    <span class="keyword">let</span> i = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">            [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [nums[i], nums[right]] = [nums[right], nums[i]];</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findKthLargest</span>([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>], <span class="number">2</span>)); <span class="comment">// 输出：5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findKthLargest</span>([<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">4</span>)); <span class="comment">// 输出：4</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：平均情况为 O(n)，因为每次分区都会将数组分成两部分。然而，在最坏情况下（例如数组已经有序时），时间复杂度可能达到 O(n^2)。</li><li><strong>空间复杂度</strong>：O(1)，因为快速选择是就地排序的算法，不需要额外的空间来存储数组。递归调用的栈空间为 O(log n)。</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划是一种解决复杂问题的方法，通过将问题分解成更小的子问题，<strong>并利用子问题的重叠性，避免重复计算</strong>，从而提高效率。动态规划的核心思想是利用已计算的结果来构建解决方案，从而减少不必要的计算。</p><h4 id="基本步骤-1"><a href="#基本步骤-1" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol><li><strong>定义子问题</strong>：将原问题分解为若干子问题，确定这些子问题的状态和状态之间的转移关系。</li><li><strong>确定状态转移方程</strong>：根据子问题的定义，找出当前状态与之前状态的关系，即状态转移方程。</li><li><strong>初始化</strong>：确定初始状态的值。</li><li><strong>填表计算</strong>：利用状态转移方程，从初始状态出发，逐步计算每个子问题的值，通常使用一个表格（数组）来存储子问题的解。</li><li><strong>返回结果</strong>：根据问题的要求，从表格中提取最终的结果。</li></ol><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>动态规划主要用于解决以下几类问题：</p><ul><li><strong>最优化问题</strong>：如最短路径、最大子序列和等问题。</li><li><strong>计数问题</strong>：如统计符合某些条件的方案数量。</li><li><strong>序列问题</strong>：如最长递增子序列、最长公共子序列等问题。</li><li><strong>划分问题</strong>：如背包问题、划分等问题。</li></ul><h4 id="动态规划的应用"><a href="#动态规划的应用" class="headerlink" title="动态规划的应用"></a>动态规划的应用</h4><h5 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">LeetCode #70 简单<i class="fas fa-external-link-alt"></i></a></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：</p><blockquote><p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol></blockquote><p>示例 2：</p><blockquote><p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></blockquote><p>解题步骤：</p><ol><li><strong>定义状态</strong>：定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示达到第 <code>i</code> 阶的方法总数。</li><li><strong>初始条件</strong>：知道 <code>dp[0] = 1</code>（到达第 0 阶的方法是站在原地）和 <code>dp[1] = 1</code>（到达第 1 阶的方法只有一种）。</li><li><strong>状态转移方程</strong>：为了到达第 <code>i</code> 阶，可以从第 <code>i-1</code> 阶迈一步或者从第 <code>i-2</code> 阶迈两步，所以 <code>dp[i] = dp[i-1] + dp[i-2]</code>。</li><li><strong>最终结果</strong>：<code>dp[n]</code> 表示达到第 <code>n</code> 阶的方法总数。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">climbStairs</span>(<span class="params">n</span>) &#123;</span><br><span class="line">   <span class="comment">// 如果楼梯阶数为 0 或 1，直接返回 n</span></span><br><span class="line">   <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建一个 dp 数组来存储每个台阶的方法数</span></span><br><span class="line">   <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始条件</span></span><br><span class="line">   dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算每个台阶的方法数</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回到达第 n 阶的方法总数</span></span><br><span class="line">   <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">climbStairs</span>(<span class="number">2</span>)) <span class="comment">// 输出：2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">climbStairs</span>(<span class="number">3</span>)) <span class="comment">// 输出：3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">climbStairs</span>(<span class="number">4</span>)) <span class="comment">// 输出：5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">climbStairs</span>(<span class="number">5</span>)) <span class="comment">// 输出：8</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)，因为只需遍历一次数组。</li><li><strong>空间复杂度</strong>：O(n)，需要一个长度为 <code>n+1</code> 的数组来存储每一阶的方法数。</li></ul><h5 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">LeetCode #300 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3, 6, 2, 7]</code> 是数组 <code>[0, 3, 1, 6, 2, 2, 7]</code> 的子序列。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [10, 9, 2, 5, 3, 7, 101, 18]<br>输出：4<br>解释：最长递增子序列是 [2, 3, 7, 101]，因此长度为 4。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [0, 1, 0, 3, 2, 3]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [7, 7, 7, 7, 7, 7, 7]<br>输出：1</p></blockquote><p>解题步骤：</p><ol><li><strong>定义状态</strong>：定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长递增子序列的长度。</li><li><strong>初始化</strong>：每个位置的初始值为 1，因为每个位置都至少可以是一个长度为 1 的子序列。</li><li><strong>状态转移方程</strong>：对于每个 <code>nums[i]</code>，遍历其之前的元素 <code>nums[j]</code> (0 ≤ j &lt; i)，如果 <code>nums[i] &gt; nums[j]</code>，则更新 <code>dp[i] = max(dp[i], dp[j] + 1)</code>，表示在 <code>nums[j]</code> 的子序列上追加 <code>nums[i]</code>。</li><li><strong>最终结果</strong>：数组 <code>dp</code> 中的最大值即为最长递增子序列的长度。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLIS</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// dp 数组，每个位置初始化为 1</span></span><br><span class="line">   <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算每个位置的最长递增子序列长度</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">            dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回 dp 数组中的最大值</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>([<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>])) <span class="comment">// 输出：4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 输出：4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>([<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>])) <span class="comment">// 输出：1</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n^2)，因为我们需要嵌套循环遍历每个元素对。</li><li><strong>空间复杂度</strong>：O(n)，需要一个长度为 <code>n</code> 的数组来存储每个位置的最长子序列长度。</li></ul><h5 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/description/">LeetCode #198 中等<i class="fas fa-external-link-alt"></i></a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><blockquote><p>输入：[1, 2, 3, 1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4。</p></blockquote><p>示例 2：</p><blockquote><p>输入：[2, 7, 9, 3, 1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12。</p></blockquote><p>解题步骤：</p><ol><li><strong>定义状态</strong>：定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示到达第 <code>i</code> 个房子时可以偷窃到的最高金额。</li><li><strong>初始条件</strong>：如果只有一个房子，那么可以偷窃的最高金额就是该房子的金额，即 <code>dp[0] = nums[0]</code>。如果有两个房子，则可以偷窃的最高金额是这两个房子中金额较大的那个，即 <code>dp[1] = Math.max(nums[0], nums[1])</code>。</li><li><strong>状态转移方程</strong>：对于每个房子 <code>i</code>，有两种选择：偷窃该房子（然后加上 <code>i-2</code> 房子的最高金额）或者不偷窃该房子（直接取 <code>i-1</code> 房子的最高金额）。状态转移方程为 <code>dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])</code>。</li><li><strong>最终结果</strong>：数组 <code>dp</code> 中的最后一个值即为可以偷窃到的最高金额。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rob</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> n = nums.<span class="property">length</span></span><br><span class="line">   <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">   <span class="comment">// dp 数组，每个位置初始化为 0</span></span><br><span class="line">   <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始条件</span></span><br><span class="line">   dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">   dp[<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 填充 dp 数组</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">      dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回 dp 数组的最后一个值</span></span><br><span class="line">   <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">rob</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// 输出：4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">rob</span>([<span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// 输出：12</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)，因为需要遍历一次数组。</li><li><strong>空间复杂度</strong>：O(n)，因为需要一个长度为 <code>n</code> 的数组来存储每个位置的最高金额。</li></ul><p>优化空间复杂度：</p><p>注意到我们在状态转移时，只需要前两个状态的值，所以可以将空间复杂度优化为 O(1)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rob</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> n = nums.<span class="property">length</span></span><br><span class="line">   <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> prev1 = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> prev2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = <span class="title class_">Math</span>.<span class="title function_">max</span>(prev1, prev2 + nums[i])</span><br><span class="line">      prev2 = prev1</span><br><span class="line">      prev1 = current</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> prev1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">rob</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// 输出：4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">rob</span>([<span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// 输出：12</span></span><br></pre></td></tr></table></figure><p>优化后的算法分析：</p><ul><li><strong>时间复杂度</strong>：O(n)，因为需要遍历一次数组。</li><li><strong>空间复杂度</strong>：O(1)，因为只需要常量空间来存储前两个状态的值。</li></ul><p>通过上述方法，我们可以有效地计算出不触动警报装置的情况下，可以偷窃到的最高金额。优化后的代码在空间复杂度上更高效。</p><h5 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/">LeetCode #322 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>coins</code>，表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><blockquote><p>输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3<br>解释：11 &#x3D; 5 + 5 + 1</p></blockquote><p>示例 2：</p><blockquote><p>输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1</p></blockquote><p>示例 3：</p><blockquote><p>输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0</p></blockquote><p>解题步骤：</p><ol><li><strong>定义状态</strong>：定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示凑成金额 <code>i</code> 所需的最少硬币个数。</li><li><strong>初始化</strong>：<code>dp[0] = 0</code>，因为凑成金额 <code>0</code> 所需的硬币数是 <code>0</code>。其他 <code>dp[i]</code> 初始化为一个较大的值（如 <code>Infinity</code>），表示还没有计算出结果。</li><li><strong>状态转移方程</strong>：对于每个金额 <code>i</code>，尝试使用每种硬币 <code>coin</code>，更新 <code>dp[i] = Math.min(dp[i], dp[i - coin] + 1)</code>，表示从金额 <code>i - coin</code> 加上一个 <code>coin</code> 的硬币数量。</li><li><strong>最终结果</strong>：如果 <code>dp[amount]</code> 仍然是初始值 <code>Infinity</code>，则表示无法凑成该金额，返回 <code>-1</code>，否则返回 <code>dp[amount]</code>。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">coinChange</span>(<span class="params">coins, amount</span>) &#123;</span><br><span class="line">   <span class="comment">// 创建一个 dp 数组，初始化为 Infinity</span></span><br><span class="line">   <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(amount + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="title class_">Infinity</span>)</span><br><span class="line">   dp[<span class="number">0</span>] = <span class="number">0</span> <span class="comment">// 初始化金额为 0 时的最少硬币数为 0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 填充 dp 数组</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i - coin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i], dp[i - coin] + <span class="number">1</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果 dp[amount] 还是 Infinity，表示无法凑成该金额，返回 -1</span></span><br><span class="line">   <span class="keyword">return</span> dp[amount] === <span class="title class_">Infinity</span> ? -<span class="number">1</span> : dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">coinChange</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], <span class="number">11</span>)) <span class="comment">// 输出：3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">coinChange</span>([<span class="number">2</span>], <span class="number">3</span>)) <span class="comment">// 输出：-1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">coinChange</span>([<span class="number">1</span>], <span class="number">0</span>)) <span class="comment">// 输出：0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">coinChange</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">7</span>)) <span class="comment">// 输出：2 (3 + 4)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">coinChange</span>([<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>], <span class="number">27</span>)) <span class="comment">// 输出：4 (10 + 10 + 5 + 2)</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n * m)，其中 <code>n</code> 是金额 <code>amount</code>，<code>m</code> 是硬币种类数。</li><li><strong>空间复杂度</strong>：O(n)，需要一个长度为 <code>amount + 1</code> 的数组来存储每个金额的最少硬币数。</li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是全局最优的算法。贪心算法的核心是贪心选择性质，即<strong>每一步的局部最优选择最终能够导致全局最优解</strong>。</p><h4 id="基本步骤-2"><a href="#基本步骤-2" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol><li><strong>建立数学模型</strong>：将问题抽象为数学模型，明确所需的解和约束条件。</li><li><strong>选择贪心策略</strong>：根据问题的特性，选择一个贪心策略，即在每一步选择中，采取局部最优的选择。</li><li><strong>证明贪心选择的正确性</strong>：证明所选的贪心策略能够得到问题的最优解，通常通过数学归纳法或反证法证明。</li><li><strong>实施贪心算法</strong>：从初始状态开始，按照贪心策略逐步推进，直到达到问题的约束条件或无法继续推进为止。</li><li><strong>构造解</strong>：根据选择的步骤，构造出问题的解。</li></ol><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>贪心算法通常用于以下几类问题：</p><ul><li><strong>最优化问题</strong>：如最小生成树、最短路径等问题。</li><li><strong>活动选择问题</strong>：如区间调度、任务安排等问题。</li><li><strong>资源分配问题</strong>：如背包问题的某些变种、最大子序列和等问题。</li><li><strong>图论问题</strong>：如 Dijkstra 算法求最短路径，Kruskal 算法和 Prim 算法求最小生成树。</li></ul><h4 id="贪心算法的应用"><a href="#贪心算法的应用" class="headerlink" title="贪心算法的应用"></a>贪心算法的应用</h4><h5 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/description/">LeetCode #455 简单<i class="fas fa-external-link-alt"></i></a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code>。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code>，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1:</p><blockquote><p>输入: g &#x3D; [1, 2, 3], s &#x3D; [1, 1]<br>输出：1<br>解释：<br>你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1, 2, 3。<br>虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。<br>所以你应该输出 1。</p></blockquote><p>示例 2:</p><blockquote><p>输入: g &#x3D; [1, 2], s &#x3D; [1, 2, 3]<br>输出：2<br>解释：<br>你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1, 2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出 2。</p></blockquote><p>先对孩子的满足度和饼干的大小排序，然后依次为每个孩子分配满足其满足度的最小饼干。</p><p>解题步骤：</p><ol><li><strong>排序</strong>：将孩子的胃口数组 <code>g</code> 和饼干尺寸数组 <code>s</code> 分别进行排序。</li><li><strong>匹配</strong>：使用两个指针，一个指向孩子的胃口数组，另一个指向饼干尺寸数组。依次尝试用当前最小的饼干去满足当前最小的胃口。</li><li><strong>更新指针</strong>：如果当前饼干可以满足当前孩子的胃口，两个指针都移动到下一个。如果不能，则只移动饼干的指针，尝试用下一个较大的饼干去满足当前孩子的胃口。</li><li><strong>结束条件</strong>：当两个指针都到达数组末尾时，匹配结束，返回满足孩子的数量。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findContentChildren</span>(<span class="params">g, s</span>) &#123;</span><br><span class="line">   <span class="comment">// 对孩子的胃口数组和饼干尺寸数组进行排序</span></span><br><span class="line">   g.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">   s.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> i = <span class="number">0</span> <span class="comment">// 孩子的指针</span></span><br><span class="line">   <span class="keyword">let</span> j = <span class="number">0</span> <span class="comment">// 饼干的指针</span></span><br><span class="line">   <span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 满足的孩子数量</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当孩子和饼干都没有处理完时进行匹配</span></span><br><span class="line">   <span class="keyword">while</span> (i &lt; g.<span class="property">length</span> &amp;&amp; j &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[j] &gt;= g[i]) &#123;</span><br><span class="line">         <span class="comment">// 当前饼干可以满足当前孩子</span></span><br><span class="line">         count++</span><br><span class="line">         i++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 无论是否满足，都尝试下一个饼干</span></span><br><span class="line">      j++</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findContentChildren</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findContentChildren</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 输出：2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findContentChildren</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findContentChildren</span>([<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])) <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n log n + m log m)，其中 <code>n</code> 是孩子数组的长度，<code>m</code> 是饼干数组的长度。这是因为排序需要 O(n log n) 和 O(m log m)。</li><li><strong>空间复杂度</strong>：O(1)，只需要常量级别的额外空间。</li></ul><h5 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/description/">LeetCode #860 简单<i class="fas fa-external-link-alt"></i></a></p><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code>，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code>，否则返回 <code>false</code>。</p><p>示例 1：</p><blockquote><p>输入：bills &#x3D; [5, 5, 5, 10, 20]<br>输出：true<br>解释：<br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。</p></blockquote><p>示例 2：</p><blockquote><p>输入：bills &#x3D; [5, 5, 10, 10, 20]<br>输出：false<br>解释：<br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。</p></blockquote><p>遍历顾客给的钱，优先使用手中的大额钞票找零，从而保留小额钞票以应对后续的找零需求。</p><p>解题步骤：</p><ol><li><strong>初始化钱箱</strong>：使用两个变量 <code>five</code> 和 <code>ten</code> 来分别表示手中拥有的 5 美元和 10 美元的数量，初始值为 0。</li><li><strong>遍历账单</strong>：遍历顾客付的每一张账单。</li><li><strong>处理账单</strong>：<ul><li>如果顾客付的是 5 美元，直接收下。</li><li>如果顾客付的是 10 美元，需要找零，检查是否有足够的 5 美元找零，如果有则找零，否则无法找零，返回 false。</li><li>如果顾客付的是 20 美元，需要找零，优先使用 10 美元找零，然后再用 5 美元找零，如果都无法找零，则返回 false。</li></ul></li><li><strong>返回结果</strong>：遍历结束后，如果能够给每个顾客正确找零，则返回 true，否则返回 false。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lemonadeChange</span>(<span class="params">bills</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> five = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> ten = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> bill <span class="keyword">of</span> bills) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bill === <span class="number">5</span>) &#123;</span><br><span class="line">         <span class="comment">// 顾客付 5 美元，直接收下</span></span><br><span class="line">         five++</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bill === <span class="number">10</span>) &#123;</span><br><span class="line">         <span class="comment">// 顾客付 10 美元，尝试找零，优先使用 10 美元找零</span></span><br><span class="line">         <span class="keyword">if</span> (five === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 无法找零，返回 false</span></span><br><span class="line">         &#125;</span><br><span class="line">         five--</span><br><span class="line">         ten++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 顾客付 20 美元，尝试找零，优先使用 10 美元找零，再使用 5 美元找零</span></span><br><span class="line">         <span class="keyword">if</span> (ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ten--</span><br><span class="line">            five--</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            five -= <span class="number">3</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 无法找零，返回 false</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lemonadeChange</span>([<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>])) <span class="comment">// 输出：true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lemonadeChange</span>([<span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>])) <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是账单的数量，我们需要遍历一次账单数组。</li><li><strong>空间复杂度</strong>：O(1)，只需要常数级别的额外空间来存储 5 美元和 10 美元的数量。</li></ul><h5 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/description/">LeetCode #55 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个非负整数数组 <code>nums</code>，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [2, 3, 1, 1, 4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [3, 2, 1, 0, 4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0，所以永远不可能到达最后一个下标。</p></blockquote><p>从前往后遍历数组，维护当前能够到达的最远位置，如果在某一步能够到达或超过数组的最后一个位置，则返回 <code>true</code>。</p><p>解题步骤：</p><ol><li><strong>初始化</strong>：定义一个变量 <code>maxReach</code>，表示当前能够到达的最远位置，初始值为 <code>0</code>。</li><li><strong>遍历数组</strong>：从头到尾遍历数组的每个位置，检查当前位置是否能够到达。如果当前位置大于 <code>maxReach</code>，说明不能到达当前位置，返回 <code>false</code>。</li><li><strong>更新最远可达位置</strong>：如果当前位置在可达范围内，更新 <code>maxReach</code> 为 <code>max(maxReach, i + nums[i])</code>。</li><li><strong>检查是否可达</strong>：如果在遍历过程中，<code>maxReach</code> 大于或等于数组的最后一个下标，返回 <code>true</code>。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">canJump</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> maxReach = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果当前下标超过了能到达的最远位置</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; maxReach) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新能到达的最远位置</span></span><br><span class="line">      maxReach = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxReach, i + nums[i])</span><br><span class="line">      <span class="comment">// 如果能到达或超过最后一个下标</span></span><br><span class="line">      <span class="keyword">if</span> (maxReach &gt;= nums.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canJump</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>])) <span class="comment">// 输出：true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canJump</span>([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>])) <span class="comment">// 输出：false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canJump</span>([<span class="number">0</span>])) <span class="comment">// 输出：true (只有一个元素，已经在最后一个下标)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canJump</span>([<span class="number">2</span>, <span class="number">0</span>])) <span class="comment">// 输出：true (可以直接到达最后一个下标)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canJump</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])) <span class="comment">// 输出：true (每步都能跳到最后)</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>canJump</code> 函数</strong>：主函数，判断是否能够到达最后一个下标。</li><li>**初始化 <code>maxReach</code>**：定义变量 <code>maxReach</code> 表示当前能够到达的最远位置，初始值为 <code>0</code>。</li><li><strong>遍历数组</strong>：<ul><li>对于每个位置 <code>i</code>，检查是否超过了 <code>maxReach</code>。如果是，返回 <code>false</code>，表示不能到达该位置。</li><li>否则，更新 <code>maxReach</code> 为 <code>max(maxReach, i + nums[i])</code>，表示当前能够到达的最远位置。</li></ul></li><li><strong>检查终止条件</strong>：如果 <code>maxReach</code> 已经大于或等于数组的最后一个下标，返回 <code>true</code>。</li><li><strong>返回结果</strong>：遍历结束后，如果没有返回 <code>true</code>，则返回 <code>false</code>。</li></ol><ul><li><strong>时间复杂度</strong>：O(n)，因为我们需要遍历一次数组。</li><li><strong>空间复杂度</strong>：O(1)，只需要常量级别的额外空间。</li></ul><h5 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/description/">LeetCode #435 中等<i class="fas fa-external-link-alt"></i></a></p><p>给定一个区间的集合 <code>intervals</code>，其中 <code>intervals[i] = [starti, endi]</code> 。返回需要移除区间的最小数量，使剩余区间互不重叠。</p><p>示例 1:</p><blockquote><p>输入: intervals &#x3D; [[1, 2], [2, 3], [3, 4], [1, 3]]<br>输出：1<br>解释: 移除 [1, 3] 后，剩下的区间没有重叠。</p></blockquote><p>示例 2:</p><blockquote><p>输入: intervals &#x3D; [[1, 2], [1,2], [1,2]]<br>输出：2<br>解释: 你需要移除两个 [1, 2] 来使剩下的区间没有重叠。</p></blockquote><p>示例 3:</p><blockquote><p>输入: intervals &#x3D; [[1, 2], [2, 3]]<br>输出：0<br>解释：你不需要移除任何区间，因为它们已经是无重叠的了。</p></blockquote><p>先按照区间的结束时间排序，然后依次选择结束时间最早且不与前一个选择的区间重叠的区间。对于这个问题，我们要尽可能多地保留区间，从而使得需要移除的区间数量最小。</p><p>解题步骤：</p><ol><li><strong>排序</strong>：首先将区间按照结束时间 <code>end</code> 进行排序。这样可以保证每次选择的区间结束时间尽可能早，以便留出更多的空间给后面的区间。</li><li><strong>贪心选择</strong>：使用一个变量 <code>end</code> 来记录上一个选择的区间的结束时间。初始化 <code>end</code> 为负无穷大。</li><li><strong>遍历区间</strong>：依次遍历排序后的区间，如果当前区间的起始时间 <code>start</code> 大于等于 <code>end</code>，说明这个区间可以保留，同时更新 <code>end</code> 为当前区间的结束时间 <code>end</code>。否则，这个区间需要移除。</li><li><strong>统计结果</strong>：遍历结束后，计算需要移除的区间数量。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">intervals</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (intervals.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 按区间的结束时间进行排序</span></span><br><span class="line">   intervals.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] - b[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> end = -<span class="title class_">Infinity</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> [start, finish] <span class="keyword">of</span> intervals) &#123;</span><br><span class="line">      <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">         <span class="comment">// 当前区间可以保留，更新结束时间</span></span><br><span class="line">         end = finish</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 当前区间与上一个区间重叠，需要移除</span></span><br><span class="line">         count++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eraseOverlapIntervals</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>]])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eraseOverlapIntervals</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]])) <span class="comment">// 输出：2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eraseOverlapIntervals</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]])) <span class="comment">// 输出：0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eraseOverlapIntervals</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">5</span>]])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eraseOverlapIntervals</span>([[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">6</span>]])) <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>eraseOverlapIntervals</code> 函数</strong>：主函数，计算需要移除的区间数量。</li><li><strong>排序</strong>：将区间按照结束时间进行排序，使得每次选择的区间结束时间尽可能早。</li><li><strong>初始化变量</strong>：<code>count</code> 用于记录需要移除的区间数量，<code>end</code> 初始化为负无穷大。</li><li><strong>遍历区间</strong>：<ul><li>如果当前区间的起始时间 <code>start</code> 大于等于 <code>end</code>，说明这个区间可以保留，并更新 <code>end</code> 为当前区间的结束时间 <code>finish</code>。</li><li>否则，这个区间与上一个区间重叠，需要移除，增加 <code>count</code> 计数器。</li></ul></li><li><strong>返回结果</strong>：遍历结束后，返回需要移除的区间数量 <code>count</code>。</li></ol><ul><li><strong>时间复杂度</strong>：O(n log n)，因为我们需要对区间进行排序。</li><li><strong>空间复杂度</strong>：O(1)，不需要额外的空间，除了用于存储输入的区间列表。</li></ul><h5 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/description/">LeetCode #135 困难<i class="fas fa-external-link-alt"></i></a></p><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。</p><p>示例 1：</p><blockquote><p>输入：ratings &#x3D; [1, 0, 2]<br>输出：5<br>解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</p></blockquote><p>示例 2：</p><blockquote><p>输入：ratings &#x3D; [1, 2, 2]<br>输出：4<br>解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。<br>第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</p></blockquote><p>先从左到右扫描数组，确保右边的评分更高的孩子获得更多糖果；再从右到左扫描数组，确保左边的评分更高的孩子获得更多糖果。</p><p>解题步骤：</p><ol><li><strong>初始化</strong>：创建一个数组 <code>candies</code>，初始化每个孩子的糖果数为 1，表示每个孩子至少有一个糖果。</li><li><strong>从左到右遍历</strong>：检查每个孩子与前一个孩子的评分，如果当前孩子的评分比前一个孩子高，则更新当前孩子的糖果数为 <code>candies[i-1] + 1</code>。</li><li><strong>从右到左遍历</strong>：检查每个孩子与后一个孩子的评分，如果当前孩子的评分比后一个孩子高且糖果数不大于后一个孩子，则更新当前孩子的糖果数为 <code>candies[i+1] + 1</code>。</li><li><strong>计算总糖果数</strong>：遍历 <code>candies</code> 数组，求和得到最少需要的糖果数。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">candy</span>(<span class="params">ratings</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> n = ratings.<span class="property">length</span></span><br><span class="line">   <span class="keyword">const</span> candies = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从左到右遍历，保证右边孩子评分高的糖果更多</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">         candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从右到左遍历，保证左边孩子评分高的糖果更多</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">         candies[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(candies[i], candies[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算总糖果数</span></span><br><span class="line">   <span class="keyword">return</span> candies.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, candy</span>) =&gt;</span> sum + candy, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">candy</span>([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])) <span class="comment">// 输出：5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">candy</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])) <span class="comment">// 输出：4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">candy</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])) <span class="comment">// 输出：7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">candy</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])) <span class="comment">// 输出：15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">candy</span>([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])) <span class="comment">// 输出：15</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>candy</code> 函数</strong>：主函数，计算最少需要的糖果数。</li><li><strong>初始化 <code>candies</code> 数组</strong>：每个孩子至少分配 1 个糖果。</li><li><strong>从左到右遍历</strong>：<ul><li>如果当前孩子的评分高于前一个孩子，则当前孩子的糖果数等于前一个孩子的糖果数加 1。</li></ul></li><li><strong>从右到左遍历</strong>：<ul><li>如果当前孩子的评分高于后一个孩子且糖果数不大于后一个孩子，则更新当前孩子的糖果数为 <code>candies[i + 1] + 1</code>。</li></ul></li><li><strong>计算总糖果数</strong>：通过遍历 <code>candies</code> 数组求和得到最少需要的糖果数。</li></ol><ul><li><strong>时间复杂度</strong>：O(n)，因为我们需要遍历两次数组，每次遍历的时间复杂度都是 O(n)。</li><li><strong>空间复杂度</strong>：O(n)，因为我们需要额外的数组 <code>candies</code> 来存储每个孩子的糖果数。</li></ul><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>回溯算法是一种通过逐步构建解决方案的方法，当遇到某一步无法继续前进时，回溯算法会回退到上一步，尝试其他的选择，直到找到问题的解决方案或确定无解。回溯算法通常通过深度优先搜索的方式实现。</p><h4 id="基本步骤-3"><a href="#基本步骤-3" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol><li><strong>选择决策树</strong>：将问题抽象成一个决策树，每个节点代表一个决策点。</li><li><strong>深度优先搜索</strong>：从根节点开始，采用深度优先搜索的方式探索决策树的所有分支。</li><li><strong>做出选择</strong>：在每个节点处，根据问题的限制条件，做出一个选择。</li><li><strong>检查约束条件</strong>：检查当前选择是否满足问题的约束条件，如果满足则继续探索，否则回溯到上一步。</li><li><strong>标记路径</strong>：在探索过程中，记录已经探索过的路径，避免重复探索。</li><li><strong>撤销选择</strong>：在回溯时，撤销当前节点的选择，回到上一层继续探索其他分支。</li><li><strong>判断终止条件</strong>：当到达叶子节点或者无法继续探索时，判断是否找到了问题的解决方案。</li></ol><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>回溯算法通常用于以下几类问题：</p><ul><li><strong>组合问题</strong>：如组合总和、组合总和 II 等问题。</li><li><strong>排列问题</strong>：如全排列、字符串的全排列等问题。</li><li><strong>搜索问题</strong>：如解数独、N 皇后问题等。</li><li><strong>子集问题</strong>：如子集、子集 II 等问题。</li></ul><h4 id="回溯算法的应用"><a href="#回溯算法的应用" class="headerlink" title="回溯算法的应用"></a>回溯算法的应用</h4><h5 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">LeetCode #46 中等<i class="fas fa-external-link-alt"></i></a></p><p>给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列。你可以按任意顺序返回答案。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [1, 2, 3]<br>输出：[[1, 2, 3], [1, 3, 2], [2, 1 ,3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [0, 1]<br>输出：[[0, 1], [1, 0]]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [1]<br>输出：[[1]]</p></blockquote><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数互不相同</li></ul><p>解题步骤：</p><ol><li><strong>初始化结果集</strong>：创建一个结果数组 <code>result</code> 来存储所有的排列。</li><li><strong>回溯函数</strong>：定义一个回溯函数 <code>backtrack</code>，参数为当前路径 <code>path</code> 和剩余可选择的数字 <code>choices</code>。</li><li><strong>终止条件</strong>：当路径长度等于输入数组长度时，表明我们找到了一种排列，将其加入结果集。</li><li><strong>选择和探索</strong>：遍历剩余可选择的数字，将每个数字加入当前路径，并递归调用回溯函数，传递更新后的路径和剩余可选择的数字。</li><li><strong>回溯</strong>：在递归调用结束后，撤销上一步选择，进行下一轮选择和探索。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">permute</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> result = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">         result.<span class="title function_">push</span>([...path])</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; choices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">         path.<span class="title function_">push</span>(choices[i])</span><br><span class="line">         <span class="title function_">backtrack</span>(path, choices.<span class="title function_">slice</span>(<span class="number">0</span>, i).<span class="title function_">concat</span>(choices.<span class="title function_">slice</span>(i + <span class="number">1</span>)))</span><br><span class="line">         path.<span class="title function_">pop</span>()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="title function_">backtrack</span>([], nums)</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">0</span>, <span class="number">1</span>])) <span class="comment">// 输出：[[0,1],[1,0]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">1</span>])) <span class="comment">// 输出：[[1]]</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>permute</code> 函数</strong>：主函数，接收输入数组 <code>nums</code>，返回所有的排列。</li><li><strong>初始化结果集</strong>：创建一个空数组 <code>result</code> 来存储所有的排列结果。</li><li><strong><code>backtrack</code> 函数</strong>：递归函数，构建排列。参数 <code>path</code> 表示当前路径，<code>choices</code> 表示当前剩余的可选择数字。</li><li><strong>终止条件</strong>：当路径长度等于输入数组长度时，将当前路径加入结果集。</li><li><strong>选择和探索</strong>：遍历剩余可选择的数字，将每个数字加入当前路径，递归调用 <code>backtrack</code> 函数，并传递更新后的路径和剩余可选择的数字。</li><li><strong>回溯</strong>：在递归调用结束后，撤销上一步选择，通过 <code>path.pop()</code> 将最后一个元素移除，进行下一轮选择和探索。</li></ol><ul><li><strong>时间复杂度</strong>：O(n * n!)，其中 n 是输入数组的长度。总共有 n! 种排列，每种排列需要 O(n) 的时间来构建。</li><li><strong>空间复杂度</strong>：O(n)，用于存储递归调用栈和临时路径。</li></ul><h5 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/description/">LeetCode 78 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>nums</code>，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。</p><p>解集不能包含重复的子集。你可以按任意顺序返回解集。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [1, 2, 3]<br>输出：[[], [1], [2], [1,2], [3], [1, 3], [2, 3], [1, 2, 3]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [0]<br>输出：[[], [0]]</p></blockquote><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素互不相同</li></ul><p>解题步骤：</p><ol><li><strong>初始化结果集</strong>：创建一个结果数组 <code>result</code> 来存储所有的子集。</li><li><strong>回溯函数</strong>：定义一个回溯函数 <code>backtrack</code>，参数为当前路径 <code>path</code> 和起始索引 <code>start</code>。</li><li><strong>添加当前路径到结果集</strong>：将当前路径 <code>path</code> 的拷贝加入结果集 <code>result</code>。</li><li><strong>选择和探索</strong>：从起始索引开始遍历 <code>nums</code> 数组，将每个数字加入当前路径，并递归调用回溯函数，传递更新后的路径和新的起始索引。</li><li><strong>回溯</strong>：在递归调用结束后，撤销上一步选择，进行下一轮选择和探索。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">subsets</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> result = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">path, start</span>) &#123;</span><br><span class="line">      <span class="comment">// 将当前路径加入结果集</span></span><br><span class="line">      result.<span class="title function_">push</span>([...path])</span><br><span class="line">      <span class="comment">// 从当前索引开始遍历 nums 数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">         <span class="comment">// 将当前数字加入路径</span></span><br><span class="line">         path.<span class="title function_">push</span>(nums[i])</span><br><span class="line">         <span class="comment">// 递归调用回溯函数，传递更新后的路径和新的起始索引</span></span><br><span class="line">         <span class="title function_">backtrack</span>(path, i + <span class="number">1</span>)</span><br><span class="line">         <span class="comment">// 回溯，撤销上一步选择</span></span><br><span class="line">         path.<span class="title function_">pop</span>()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化回溯</span></span><br><span class="line">   <span class="title function_">backtrack</span>([], <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subsets</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 输出：[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subsets</span>([<span class="number">0</span>])) <span class="comment">// 输出：[[], [0]]</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>subsets</code> 函数</strong>：主函数，接收输入数组 <code>nums</code>，返回所有的子集。</li><li><strong>初始化结果集</strong>：创建一个空数组 <code>result</code> 来存储所有的子集结果。</li><li><strong><code>backtrack</code> 函数</strong>：递归函数，构建子集。参数 <code>path</code> 表示当前路径，<code>start</code> 表示起始索引。</li><li><strong>添加当前路径到结果集</strong>：将当前路径 <code>path</code> 的拷贝加入结果集 <code>result</code>。</li><li><strong>选择和探索</strong>：从起始索引开始遍历 <code>nums</code> 数组，将每个数字加入当前路径 <code>path</code>，递归调用 <code>backtrack</code> 函数，并传递更新后的路径和新的起始索引 <code>i + 1</code>。</li><li><strong>回溯</strong>：在递归调用结束后，撤销上一步选择，通过 <code>path.pop()</code> 将最后一个元素移除，进行下一轮选择和探索。</li></ol><ul><li><strong>时间复杂度</strong>：O(n * 2^n)，其中 n 是输入数组的长度。总共有 2^n 个子集，每个子集的平均长度为 n&#x2F;2。</li><li><strong>空间复杂度</strong>：O(n)，用于存储递归调用栈和临时路径。</li></ul><h5 id="单词拆分-II"><a href="#单词拆分-II" class="headerlink" title="单词拆分 II"></a>单词拆分 II</h5><p>题目来源：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break-ii/description/">LeetCode #140 困难<i class="fas fa-external-link-alt"></i></a></p><p>给定一个字符串 <code>s</code> 和一个字符串字典 <code>wordDict</code>，在字符串 <code>s</code> 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序返回所有这些可能的句子。</p><p>注意：词典中的同一个单词可能在分段中被重复使用多次。</p><p>示例 1：</p><blockquote><p>输入：s &#x3D; “catsanddog”, wordDict &#x3D; [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出：[“cats and dog”, “cat sand dog”]</p></blockquote><p>示例 2：</p><blockquote><p>输入：s &#x3D; “pineapplepenapple”, wordDict &#x3D; [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出：[“pine apple pen apple”, “pineapple pen apple”, “pine applepen apple”]<br>解释：注意你可以重复使用字典中的单词。</p></blockquote><p>示例 3：</p><blockquote><p>输入：s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出：[]</p></blockquote><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li><li><code>wordDict</code> 中所有字符串都不同</li></ul><p>要解决这个问题，我们可以使用回溯算法结合动态规划进行优化。具体来说，我们需要递归地尝试在字符串 <code>s</code> 中插入空格来构成单词，同时使用缓存来存储已经计算过的结果，避免重复计算。</p><p>解题步骤：</p><ol><li><strong>定义缓存</strong>：使用一个对象 <code>memo</code> 来存储已经计算过的子问题的结果。</li><li><strong>定义回溯函数</strong>：递归函数 <code>backtrack</code>，参数为当前子字符串 <code>s</code>。</li><li><strong>递归终止条件</strong>：如果当前子字符串 <code>s</code> 在缓存中，直接返回缓存中的结果；如果 <code>s</code> 为空字符串，返回包含一个空字符串的数组。</li><li><strong>遍历匹配</strong>：遍历词典中的单词，如果当前子字符串 <code>s</code> 以该单词开头，则递归处理剩余部分的字符串，并将结果组合起来。</li><li><strong>更新缓存</strong>：将当前子字符串的结果存入缓存中，并返回该结果。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wordBreak</span>(<span class="params">s, wordDict</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> wordSet = <span class="keyword">new</span> <span class="title class_">Set</span>(wordDict)</span><br><span class="line">   <span class="keyword">const</span> memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">s</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果当前子字符串已经在缓存中，直接返回缓存的结果</span></span><br><span class="line">      <span class="keyword">if</span> (memo[s] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> memo[s]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果子字符串为空，返回包含一个空字符串的数组</span></span><br><span class="line">      <span class="keyword">if</span> (s === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> result = []</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历词典中的每个单词</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> wordSet) &#123;</span><br><span class="line">         <span class="keyword">if</span> (s.<span class="title function_">startsWith</span>(word)) &#123;</span><br><span class="line">            <span class="keyword">const</span> subResult = <span class="title function_">backtrack</span>(s.<span class="title function_">slice</span>(word.<span class="property">length</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> sub <span class="keyword">of</span> subResult) &#123;</span><br><span class="line">               result.<span class="title function_">push</span>(word + (sub === <span class="string">&#x27;&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27; &#x27;</span>) + sub)</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将当前子字符串的结果存入缓存</span></span><br><span class="line">      memo[s] = result</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">backtrack</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">wordBreak</span>(<span class="string">&#x27;catsanddog&#x27;</span>, [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;cats&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;sand&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>]))</span><br><span class="line"><span class="comment">// 输出：[&quot;cats and dog&quot;, &quot;cat sand dog&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">wordBreak</span>(<span class="string">&#x27;pineapplepenapple&#x27;</span>, [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pen&#x27;</span>, <span class="string">&#x27;applepen&#x27;</span>, <span class="string">&#x27;pine&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>]))</span><br><span class="line"><span class="comment">// 输出：[&quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">wordBreak</span>(<span class="string">&#x27;catsandog&#x27;</span>, [<span class="string">&#x27;cats&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;sand&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]))</span><br><span class="line"><span class="comment">// 输出：[]</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>wordBreak</code> 函数</strong>：主函数，接收字符串 <code>s</code> 和词典 <code>wordDict</code>，返回所有可能的句子。</li><li><strong>初始化</strong>：将词典转化为集合 <code>wordSet</code>，用于快速查找；定义缓存 <code>memo</code>。</li><li><strong><code>backtrack</code> 函数</strong>：递归函数，处理当前子字符串 <code>s</code>，返回其所有可能的句子组合。</li><li><strong>缓存查询</strong>：如果当前子字符串 <code>s</code> 在缓存中，直接返回缓存中的结果。</li><li><strong>递归终止条件</strong>：如果子字符串 <code>s</code> 为空，返回包含一个空字符串的数组。</li><li><strong>遍历词典</strong>：对于每个单词，如果当前子字符串 <code>s</code> 以该单词开头，则递归处理剩余部分的字符串 <code>s.slice(word.length)</code>。</li><li><strong>组合结果</strong>：将当前单词和递归结果组合成新的句子，并添加到结果集中。</li><li><strong>更新缓存</strong>：将当前子字符串 <code>s</code> 的结果存入缓存 <code>memo</code>，避免重复计算。</li><li><strong>返回结果</strong>：主函数调用 <code>backtrack</code> 函数，返回最终结果。</li></ol><ul><li><strong>时间复杂度</strong>：最坏情况下为 O(n^2 * k)，其中 n 是字符串 <code>s</code> 的长度，k 是词典 <code>wordDict</code> 的大小。每个子字符串的计算会涉及到对词典的遍历，并且需要组合结果。</li><li><strong>空间复杂度</strong>：O(n^2)，用于缓存子字符串的结果和存储递归栈。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢大家看到最后，本文篇幅较长，难免会有错误，还望同学们多指正。看完本文后还没能理解透算法实现原理的同学，也不用灰心，掌握算法不是一朝半夕的事，勤加练习才能突破。</p><p>另外，作者组建了氛围特别好的前端交流群 &amp; 自由程序猿交流群，欢迎同学们一起来交流吐槽。由于群人数较多，需要添加作者才能邀请进群。</p><p><img lazyload alt="image" data-src="/images/fp/fp-slogan.webp" alt="自由程序猿"></p></div><div class="post-copyright-info-container border-box"><div class="copyright-info-content border-box"><div class="copyright-info-top border-box"><div class="copyright-post-title border-box text-ellipsis">零基础入门 JavaScript 算法</div><div class="copyright-post-link border-box text-ellipsis">post/efb94b4d08c6/</div></div><div class="copyright-info-bottom border-box"><div class="copyright-post-author bottom-item"><div class="type">Author</div><div class="content">XPoet</div></div><div class="post-time bottom-item"><div class="type">Published</div><div class="content">2024-05-23 16:00</div></div><div class="post-license bottom-item"><div class="type">License</div><div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed" target="_blank"><i class="fa-brands fa-creative-commons"></i> <i class="fa-brands fa-creative-commons-by"></i> <i class="fa-brands fa-creative-commons-nc"></i> <i class="fa-brands fa-creative-commons-sa"></i></a></div></div></div><i class="copyright-bg fa-solid fa-copyright"></i></div><div class="copy-copyright-info flex-center tooltip" data-tooltip-content="Copy copyright info" data-tooltip-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div><div class="post-bottom-tags-and-share border-box"><div><ul class="post-tags-box border-box"><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E7%AE%97%E6%B3%95/">算法</a></li></ul></div><div><div class="post-share-container border-box"><ul class="share-list-wrap border-box"><li class="qq share-item border-box flex-center tooltip" data-tooltip-content="Share to QQ"><i class="fa-brands fa-qq"></i></li><li class="wechat share-item border-box flex-center tooltip tooltip-img" data-tooltip-content="Share to WeChat" data-tooltip-img-tip="Scan by WeChat" data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"><i class="fa-brands fa-weixin"></i></li><li class="weibo share-item border-box flex-center tooltip" data-tooltip-content="Share to WeiBo"><i class="fa-brands fa-weibo"></i></li></ul></div></div></div><div class="reward-author-container border-box flex-center"><div class="reward-btn border-box flex-center tooltip tooltip-img" data-tooltip-img-url="/images/admire-code.png" data-tooltip-img-trigger="click" data-tooltip-img-style="top: -6px;"><i class="fa-solid fa-gift"></i>&nbsp;REWARD AUTHOR</div></div><div class="post-nav border-box"><div class="prev-post"><a class="prev" rel="prev" href="/post/1d1c89725ee6/" title="独立开发者的福音：Amazon DynamoDB 数据库"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">独立开发者的福音：Amazon DynamoDB 数据库</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="next-post"><a class="next" rel="next" href="/post/1c732a9f7dca/" title="微信公众号又双叒叕改名了"><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">微信公众号又双叒叕改名了</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comments-container border-box"><div id="comments-anchor" class="comment-area-title border-box"><i class="fas fa-comments"></i>&nbsp;Comments</div><div class="comment-plugin-fail border-box"><span class="fail-tip">Comment plugin failed to load</span> <button class="reload keep-button">Click to reload</button></div><div class="comment-plugin-loading flex-center border-box"><i class="loading-icon fa-solid fa-spinner fa-spin"></i> <span class="load-tip">Loading comment plugin</span></div><script data-pjax>window.KeepCommentPlugin={},window.KeepCommentPlugin.hideLoading=()=>{document.querySelector(".comments-container .comment-plugin-loading").style.display="none"},window.KeepCommentPlugin.loadFailHandle=()=>{window.KeepCommentPlugin.hideLoading();const e=document.querySelector(".comments-container .comment-plugin-fail");e.style.display="flex",e.querySelector(".reload").addEventListener("click",()=>{window.location.reload()})}</script><div class="waline-comment-container"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/3.2.1/waline.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/3.2.1/waline-meta.css"><div id="waline-comment"></div><script data-pjax>window.KeepCommentPlugin.walineOptions=JSON.parse("{}".replace(/&#34;/g,'"')),window.KeepCommentPlugin.walineOptions.el="#waline-comment",window.KeepCommentPlugin.walineOptions.comment=".post-comments-count",window.KeepCommentPlugin.walineOptions.serverURL="https://vercel-waline.xpoet.cn",window.KeepCommentPlugin.walineOptions.lang="en",window.KeepCommentPlugin.walineOptions.reaction=!0</script><script data-pjax async type="module">import{init}from"https://cdnjs.cloudflare.com/ajax/libs/waline/3.2.1/waline.js";window.KeepCommentPlugin.initWaline=()=>{init?(init(window.KeepCommentPlugin.walineOptions),window.KeepCommentPlugin.hideLoading()):setTimeout(()=>{window.KeepCommentPlugin.initWaline()},1e3)},setTimeout(()=>{window.KeepCommentPlugin.initWaline()},1200)</script></div></div></div></div><div class="pc-post-toc right-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">2.4.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">2.5.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">2.6.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">2.7.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.8.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.9.</span> <span class="nav-text">计数排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2"><span class="nav-number">3.</span> <span class="nav-text">搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2"><span class="nav-number">3.1.</span> <span class="nav-text">顺序搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">3.2.</span> <span class="nav-text">二分搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-number">4.</span> <span class="nav-text">算法设计思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="nav-number">4.1.</span> <span class="nav-text">分而治之</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.1.1.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.1.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.1.3.</span> <span class="nav-text">分而治之的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">多数元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">排序数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">最大子数组和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">数组中的第 K 个最大元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">4.2.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">4.2.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.2.3.</span> <span class="nav-text">动态规划的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">爬楼梯</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">最长递增子序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">4.2.3.3.</span> <span class="nav-text">打家劫舍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">4.2.3.4.</span> <span class="nav-text">零钱兑换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4-2"><span class="nav-number">4.3.1.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">4.3.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.3.3.</span> <span class="nav-text">贪心算法的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">分发饼干</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">柠檬水找零</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-number">4.3.3.3.</span> <span class="nav-text">跳跃游戏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="nav-number">4.3.3.4.</span> <span class="nav-text">无重叠区间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="nav-number">4.3.3.5.</span> <span class="nav-text">分发糖果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">回溯算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4-3"><span class="nav-number">4.4.1.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">4.4.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.4.3.</span> <span class="nav-text">回溯算法的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">全排列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E9%9B%86"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">子集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-II"><span class="nav-number">4.4.3.3.</span> <span class="nav-text">单词拆分 II</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E"><span class="nav-number">5.</span> <span class="nav-text">最后</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom border-box"><footer class="footer border-box"><div class="copyright-info info-item">&copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024 &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">XPoet</a></div><div class="theme-info info-item">Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a></div><div class="deploy-info info-item"><a target="_blank" rel="nofollow" href="https://github.com/xpoet/xpoet.github.io">This site is deployed on <span class="tooltip" data-tooltip-content="GitHub Pages"><img src="/images/brands/github.png"></span></a></div><div class="count-info info-item"><span class="count-item border-box uv"><span class="item-type border-box">Unique Visitor</span> <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span> </span><span class="count-item border-box pv"><span class="item-type border-box">Page View</span> <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span></span></div></footer></div></div><div class="post-tools right-toc"><div class="post-tools-container border-box"><ul class="post-tools-list border-box"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li><li class="tools-item flex-center full-screen"><i class="fa-solid fa-expand"></i></li></ul></div></div><div class="side-tools"><div class="side-tools-container border-box"><ul class="side-tools-list side-tools-show-handle border-box"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-toggle-theme-mode flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list border-box"><li class="tools-item toggle-show-toc-tablet flex-center"><i class="fas fa-list"></i></li><li class="tools-item go-to-comments-tablet flex-center"><i class="fas fa-comment"></i></li><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center show-arrow"><i class="arrow fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><div class="tablet-post-toc-mask"><div class="tablet-post-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">2.4.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">2.5.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">2.6.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">2.7.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.8.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.9.</span> <span class="nav-text">计数排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2"><span class="nav-number">3.</span> <span class="nav-text">搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2"><span class="nav-number">3.1.</span> <span class="nav-text">顺序搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">3.2.</span> <span class="nav-text">二分搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-number">4.</span> <span class="nav-text">算法设计思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="nav-number">4.1.</span> <span class="nav-text">分而治之</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.1.1.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.1.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.1.3.</span> <span class="nav-text">分而治之的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">多数元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">排序数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">最大子数组和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">数组中的第 K 个最大元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">4.2.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">4.2.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.2.3.</span> <span class="nav-text">动态规划的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">爬楼梯</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">最长递增子序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">4.2.3.3.</span> <span class="nav-text">打家劫舍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">4.2.3.4.</span> <span class="nav-text">零钱兑换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4-2"><span class="nav-number">4.3.1.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">4.3.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.3.3.</span> <span class="nav-text">贪心算法的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">分发饼干</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">柠檬水找零</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-number">4.3.3.3.</span> <span class="nav-text">跳跃游戏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="nav-number">4.3.3.4.</span> <span class="nav-text">无重叠区间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="nav-number">4.3.3.5.</span> <span class="nav-text">分发糖果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">回溯算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4-3"><span class="nav-number">4.4.1.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">4.4.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.4.3.</span> <span class="nav-text">回溯算法的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">全排列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E9%9B%86"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">子集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-II"><span class="nav-number">4.4.3.3.</span> <span class="nav-text">单词拆分 II</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E"><span class="nav-number">5.</span> <span class="nav-text">最后</span></a></li></ol></div></div></div></div></main><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/header-shrink.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/back2top.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/toggle-theme.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/code-block.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/libs/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/local-search.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/lazyload.min.js"></script><div class="pjax"><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/post-helper.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/toc.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/copyright-info.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/share.min.js"></script></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.initExecute()})})</script></body></html>