<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XPoet&#39;s Blog</title>
  
  <subtitle>XPoet&#39;s Blog</subtitle>
  <link href="https://xpoet.cn/atom.xml" rel="self"/>
  
  <link href="https://xpoet.cn/"/>
  <updated>2024-09-04T14:26:27.000Z</updated>
  <id>https://xpoet.cn/</id>
  
  <author>
    <name>XPoet</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>独立开发者的福音：Amazon DynamoDB 数据库</title>
    <link href="https://xpoet.cn/post/1d1c89725ee6/"/>
    <id>https://xpoet.cn/post/1d1c89725ee6/</id>
    <published>2024-09-04T14:12:24.000Z</published>
    <updated>2024-09-04T14:26:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于很多独立开发者朋友来说，往往总是需要一个稳定的云数据库来存储自己的个人数据。从零开始搭建一个云数据库，需要花费大量时间、精力，并且需要自己管理数据库的维护，在巨大的成本面前，显然这并不是明智之选。作者在偶然的机会下发现到亚马逊云科技 <a class="link"   href="https://aws.amazon.com/cn/dynamodb/?trk=17554200-e660-4d6e-acf0-f06b26fbc626&sc_channel=sm&campaign=blog1382" >Amazon DynamoDB 数据库<i class="fas fa-external-link-alt"></i></a>，可以永久免费提供 25GB 的存储量以及每月最多 2 亿次读&#x2F;写请求，一番体验下来，太良心了，简直就是独立开发者和个人网站站长的福音。</p><h2 id="什么是-Amazon-DynamoDB-数据库？"><a href="#什么是-Amazon-DynamoDB-数据库？" class="headerlink" title="什么是 Amazon DynamoDB 数据库？"></a>什么是 Amazon DynamoDB 数据库？</h2><p><img                         lazyload                       alt="image"                       data-src="/images/posts/DynamoDB/img-1.png"                        alt="img"                 ></p><p><a class="link"   href="https://aws.amazon.com/cn/dynamodb/?trk=17554200-e660-4d6e-acf0-f06b26fbc626&sc_channel=sm&campaign=blog1382" >Amazon DynamoDB 数据库<i class="fas fa-external-link-alt"></i></a>是亚马逊云科技提供的一款无服务器、NoSQL、完全托管的数据库，在任何规模下均具有个位数毫秒级的性能，你可以通过它来开发任何规模的现代应用程序。</p><p>作为无服务器数据库，Amazon Free Tier 永久免费提供 25GB 的存储量以及每月最多 2 亿次读&#x2F;写请求，超出部分，只需按使用量为其付费，Amazon DynamoDB 可以扩展到零，没有冷启动，没有版本升级，没有维护窗口，没有修补，也没有停机维护。Amazon DynamoDB 提供一系列广泛的安全控制措施和合规性标准。对于全球分布式应用程序，Amazon DynamoDB 全局表是一个多区域、多活动数据库，具有 99.999% 的可用性 SLA 和更高的弹性。托管备份、时间点恢复等功能有助于确保 Amazon DynamoDB 的可靠性。借助 Amazon DynamoDB 流，你可以构建无服务器的事件驱动型应用程序。</p><h2 id="Amazon-DynamoDB-的优势"><a href="#Amazon-DynamoDB-的优势" class="headerlink" title="Amazon DynamoDB 的优势"></a>Amazon DynamoDB 的优势</h2><ul><li>简单易用：Amazon DynamoDB 使用简单的 API 和数据模型，易于使用和学习。</li><li>规模性能：提供具有稳定、高性能和几乎无限吞吐量和存储空间的应用程序。</li><li>快速响应：支持读写操作的低延迟，读取操作的平均响应时间可以在几毫秒内完成。</li><li>高可扩展性：可以根据需要自动增加或减少容量，从而满足不同的负载需求。</li><li>高可用性：提供了多种数据备份和复原功能，使其在遇到任何故障或灾难时都能够快速恢复。</li><li>高灵活性：Amazon DynamoDB 支持多种数据类型和数据模型，并支持多种查询和索引方式。</li></ul><h2 id="Amazon-DynamoDB-的适用场景"><a href="#Amazon-DynamoDB-的适用场景" class="headerlink" title="Amazon DynamoDB 的适用场景"></a>Amazon DynamoDB 的适用场景</h2><p><a class="link"   href="https://aws.amazon.com/cn/dynamodb/?trk=17554200-e660-4d6e-acf0-f06b26fbc626&sc_channel=sm&campaign=blog1382" >Amazon DynamoDB 数据库<i class="fas fa-external-link-alt"></i></a>的适用场景非常广泛，例如金融服务应用程序、游戏应用程序、日志挖掘、分析社交计算、外部数据聚合、前端订单处理系统、企业内容管理等等。对我们这些独立开发者或者个人网站站长而言，用 Amazon DynamoDB 数据库提供的免费套餐的来存储我们评论系统的数据、博客文章的数据，或者其他一些简单的数据，再合适不过了，无需额外的成本开销。</p><p>Amazon DynamoDB 的免费套餐提供 25GB 的存储空间，以及 25 个预置的写入容量单位和 25 个预置的读取容量单位 (WCU、RCU)，足以处理每月 2 亿个请求，对个人用户来讲，完全是够用的。</p><p>写入和读取容量单位可以通过表的其他设置选项卡中进行查看，注意不要超过免费额度，不然会产生费用。</p><p><img                         lazyload                       alt="image"                       data-src="/images/posts/DynamoDB/img-2.png"                        alt="img"                 ></p><h2 id="Amazon-DynamoDB-快速上手使用示例"><a href="#Amazon-DynamoDB-快速上手使用示例" class="headerlink" title="Amazon DynamoDB 快速上手使用示例"></a>Amazon DynamoDB 快速上手使用示例</h2><h3 id="注册亚马逊云科技账户"><a href="#注册亚马逊云科技账户" class="headerlink" title="注册亚马逊云科技账户"></a>注册亚马逊云科技账户</h3><ol><li>访问<a class="link"   href="https://aws.amazon.com/cn/free/?trk=17554200-e660-4d6e-acf0-f06b26fbc626&sc_channel=sm&campaign=blog1382" >亚马逊云科技官网<i class="fas fa-external-link-alt"></i></a>。</li><li>创建一个亚马逊云科技账户。</li><li>按照指示填写个人信息，包括姓名、邮箱、密码等。</li><li>完成验证后，设置支付方式（在账单登记页可以使用国内的信用卡）。</li><li>完成注册流程。</li></ol><p><img                         lazyload                       alt="image"                       data-src="/images/posts/DynamoDB/img-3.png"                        alt="img"                 ></p><h3 id="开始使用-Amazon-DynamoDB"><a href="#开始使用-Amazon-DynamoDB" class="headerlink" title="开始使用 Amazon DynamoDB"></a>开始使用 Amazon DynamoDB</h3><h4 id="登录亚马逊云科技管理控制台"><a href="#登录亚马逊云科技管理控制台" class="headerlink" title="登录亚马逊云科技管理控制台"></a>登录亚马逊云科技管理控制台</h4><p>使用我们前面注册的亚马逊云科技账号和密码登录到<a class="link"   href="https://aws.amazon.com/cn/free/?trk=17554200-e660-4d6e-acf0-f06b26fbc626&sc_channel=sm&campaign=blog1382" >亚马逊云科技管理控制台<i class="fas fa-external-link-alt"></i></a>。</p><h4 id="选择-Amazon-DynamoDB"><a href="#选择-Amazon-DynamoDB" class="headerlink" title="选择 Amazon DynamoDB"></a>选择 Amazon DynamoDB</h4><p>在亚马逊云科技管理控制台页面的服务搜索栏中输入“DynamoDB”，然后选择使用 Amazon DynamoDB。</p><h4 id="创建-Amazon-DynamoDB-表"><a href="#创建-Amazon-DynamoDB-表" class="headerlink" title="创建 Amazon DynamoDB 表"></a>创建 Amazon DynamoDB 表</h4><p>此处为了方便演示，直接采用控制台的可视化方式进行创建，我们当然也可以使用 Amazon 提供的 SDK 等方式。进入 DynamoDB 的控制台页面，点击创建表，按照页面提示输入信息即可。</p><p><img                         lazyload                       alt="image"                       data-src="/images/posts/DynamoDB/img-4.png"                        alt="img"                 ></p><p>输入表的名称，因为 DynamoDB 是一个无模式数据库，在创建表时只需要表名和主键即可，主键代表数据的唯一性，记住这两个配置项目，后面的程序代码中需要使用到。其他的配置暂时按照默认推荐的参数即可。</p><h3 id="Amazon-DynamoDB-表的增删改查"><a href="#Amazon-DynamoDB-表的增删改查" class="headerlink" title="Amazon DynamoDB 表的增删改查"></a>Amazon DynamoDB 表的增删改查</h3><p>我们使用 Node.js 演示如何连接到 Amazon DynamoDB 数据库，以及对 Amazon DynamoDB 表进行增删改查等操作。</p><h4 id="安装-Amazon-SDK"><a href="#安装-Amazon-SDK" class="headerlink" title="安装 Amazon SDK"></a>安装 Amazon SDK</h4><p>我们在项目目录中初始化一个 Node.js 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dynamodb-example</span><br><span class="line"><span class="built_in">cd</span> dynamodb-example</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>安装 Amazon SDK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install aws-sdk</span><br></pre></td></tr></table></figure><h4 id="配置-Amazon-SDK-凭证"><a href="#配置-Amazon-SDK-凭证" class="headerlink" title="配置 Amazon SDK 凭证"></a>配置 Amazon SDK 凭证</h4><p>在与 Amazon DynamoDB 交互前，需要配置 Amazon SDK 凭证。我们可以通过以下方式配置：</p><p>在 <code>~/.aws/credentials</code> 文件中添加以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="attr">aws_access_key_id</span> = YOUR_ACCESS_KEY_ID</span><br><span class="line"><span class="attr">aws_secret_access_key</span> = YOUR_SECRET_ACCESS_KEY</span><br></pre></td></tr></table></figure><h4 id="创建-DynamoDB-客户端"><a href="#创建-DynamoDB-客户端" class="headerlink" title="创建 DynamoDB 客户端"></a>创建 DynamoDB 客户端</h4><p>在项目中创建一个文件 <code>index.js</code>，并初始化 DynamoDB 客户端：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">AWS</span> = <span class="built_in">require</span>(<span class="string">&#x27;aws-sdk&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置区域</span></span><br><span class="line"><span class="variable constant_">AWS</span>.<span class="property">config</span>.<span class="title function_">update</span>(&#123;</span><br><span class="line">  <span class="attr">region</span>: <span class="string">&#x27;us-west-2&#x27;</span> <span class="comment">// 替换为你的区域</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 DynamoDB 客户端</span></span><br><span class="line"><span class="keyword">const</span> dynamodb = <span class="keyword">new</span> <span class="variable constant_">AWS</span>.<span class="title class_">DynamoDB</span>();</span><br><span class="line"><span class="keyword">const</span> docClient = <span class="keyword">new</span> <span class="variable constant_">AWS</span>.<span class="property">DynamoDB</span>.<span class="title class_">DocumentClient</span>(); <span class="comment">// 使用文档客户端更方便操作数据</span></span><br></pre></td></tr></table></figure><h4 id="向表中插入数据"><a href="#向表中插入数据" class="headerlink" title="向表中插入数据"></a>向表中插入数据</h4><p>在 Amazon DynamoDB 数据库的控制台页面也提供了给 Amazon DynamoDB 表增加数据的可视化操作，但是在实际应用中，一般都是由应用程序自动产生需要增加的数据，并推送到数据库进行数据的存储。</p><p>使用 DocumentClient 插入数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">    <span class="title class_">TableName</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">    <span class="title class_">Item</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;1000&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">docClient.<span class="title function_">put</span>(params, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="从表中查询数据"><a href="#从表中查询数据" class="headerlink" title="从表中查询数据"></a>从表中查询数据</h4><p>使用 DocumentClient 通过主键查询数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">    <span class="title class_">TableName</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">    <span class="title class_">Key</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;AA&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">docClient.<span class="title function_">get</span>(params, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="删除表中的数据"><a href="#删除表中的数据" class="headerlink" title="删除表中的数据"></a>删除表中的数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">    <span class="title class_">TableName</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">    <span class="title class_">Key</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;1000&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">docClient.<span class="title function_">delete</span>(params, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上对 Amazon DynamoDB 数据库做了一个大概的介绍，演示了 Amazon DynamoDB 的基本操作以及结合 Node.js 的入门使用，Amazon DynamoDB 永久免费提供 25GB 的存储量以及每月最多 2 亿次读&#x2F;写请求，足以满足个人开发者需求，小伙伴可以体验一下，相信是一个非常不错的 NoSQL 数据库的替代。</p><p>除 Amazon DynamoDB 数据库外，亚马逊云科技还提供众多永久免费的云产品，例如：无服务器计算服务 Amazon Lambda、消息传送的完全托管的 Pub&#x2F;Sub 服务 Amazon SNS、内容分发网络 (CDN) 服务 Amazon CloudFront 等等几十款免费的云产品服务，感兴趣小伙伴可以访问：<a class="link"   href="https://aws.amazon.com/cn/free/?trk=17554200-e660-4d6e-acf0-f06b26fbc626&sc_channel=sm&campaign=blog1382" >亚马逊云科技<i class="fas fa-external-link-alt"></i></a>。</p><p><img                         lazyload                       alt="image"                       data-src="/images/posts/DynamoDB/img-5.png"                        alt="img"                 ></p><p>另外，亚马逊云科技还有个福利活动，在 2024 年 8 月 20 日 0 时至 2024 年 9 月 30 日 24 时期间的新注册用户，可以获得亚马逊云科技赠送的礼品 (无线耳机或无线键盘)，详情请查看<a class="link"   href="https://aws.amazon.com/cn/free/?trk=17554200-e660-4d6e-acf0-f06b26fbc626&sc_channel=sm&campaign=blog1382" >亚马逊云科技官网活动页面<i class="fas fa-external-link-alt"></i></a>。</p><p><img                         lazyload                       alt="image"                       data-src="/images/posts/DynamoDB/img-6.png"                        alt="img"                 ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于很多独立开发者朋友来说，往往总是需要一个稳定的云数据库来存储自己的个人数据。从零开始搭建一个云数据库，需要花费大量时间、精力，并且需要自己管理数据库的维护，在巨大的成本面前，显然这并不是明智之选。作者在偶然的机会下发现到亚马逊云科技 &lt;a class=&quot;link&quot;   </summary>
      
    
    
    
    <category term="数据库" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="DynamoDB" scheme="https://xpoet.cn/tags/DynamoDB/"/>
    
    <category term="数据库" scheme="https://xpoet.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>零基础入门 JavaScript 算法</title>
    <link href="https://xpoet.cn/post/efb94b4d08c6/"/>
    <id>https://xpoet.cn/post/efb94b4d08c6/</id>
    <published>2024-05-23T08:00:32.000Z</published>
    <updated>2024-05-23T15:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提及算法，可能会有很多前端同学觉得这是一个距离自己日常工作较远的领域，认为算法并没有那么重要。事实上，这种看法是片面的，算法不仅仅是计算机科学中的一个重要概念，在前端开发中也有着广泛的应用和巨大的价值。</p><p>一个精心设计的算法可以大幅度提高应用的性能和效率，例如：如何在大量数据中快速找到指定信息、如何高效地处理用户输入、如何在动画效果中保持流畅的用户体验、如何让页面加载更快、响应更灵敏等等场景，这些都依赖于对算法的理解和应用。掌握算法能够让我们在面对复杂问题时，具备更强的分析能力和解决策略。</p><p>本文是一篇对前端同学相对友好的入门算法文章，提供一条易于理解的学习路径，从经典的排序、搜索等基础算法开始，逐步深入，再到一些高级算法设计思想，结合 LeetCode 真题实战案例分析，帮助你理解算法背后的实现逻辑，以及如何将其灵活应用于实际的前端开发场景中。</p><p>学习算法，不仅能提高编程能力，对求职面试也有很大帮助，微软、字节跳动、腾讯等公司就特别喜欢问算法。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>简单来说，排序算法用于将一组乱序的元素按照升序或降序的顺序重新排列。其性能通常通过时间复杂度、空间复杂度、稳定性等指标来衡量。</p><p>JavaScript 语言中的自带的排序：数组的 <code>sort</code> 方法。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序（Bubble Sort）是一种简单的比较排序算法。它重复地遍历待排序数组，每次比较相邻的两个元素，如果顺序相反则进行交换。这样，每一轮遍历都会将最大（或最小）的元素“冒泡”到顶端，直到整个数组都排序完成，最终达到完全有序。</p><p>步骤：</p><ol><li><strong>遍历数组</strong>：从头到尾遍历数组，比较相邻的两个元素。</li><li><strong>比较相邻元素</strong>：每次比较相邻的两个元素，如果它们的顺序不正确（比如，前一个元素大于后一个元素），则交换它们。</li><li><strong>重复遍历</strong>：重复上述步骤，直到没有任何一对元素需要交换，即数组已经完全排序。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查输入是否为数组且长度大于 1，若不满足条件，则直接返回原数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最后一个未排序元素的索引</span></span><br><span class="line">    <span class="keyword">let</span> lastIndex = array.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当还有未排序的元素时，执行排序过程</span></span><br><span class="line">    <span class="keyword">while</span> (lastIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化交换标志为 true，若本轮未发生交换，则排序完成</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 记录最后一次交换元素的位置，初始设置为未排序部分的末尾</span></span><br><span class="line">        <span class="keyword">const</span> k = lastIndex</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历未排序部分的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="comment">// 若当前元素大于其后面的元素，则交换它们的位置</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span> <span class="comment">// 发生了交换，将标志设置为 false</span></span><br><span class="line">                lastIndex = j <span class="comment">// 记录最后一次交换的位置</span></span><br><span class="line">                ;[array[j], array[j + <span class="number">1</span>]] = [array[j + <span class="number">1</span>], array[j]] <span class="comment">// 交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若本轮未发生交换，则数组已经有序，直接退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回排序后的数组</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bubbleSort</span>([<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>冒泡排序有几种可以优化的空间：</p><ul><li><strong>优化遍历范围</strong>：在每一轮排序中，可以观察到最后一次交换发生的位置之后的元素已经是有序的，因此可以将下一轮排序的范围限定在上一轮最后一次交换的位置之前。这样可以减少不必要的比较和交换操作。</li><li><strong>添加标志位</strong>：如果在一轮排序过程中没有发生任何元素的交换，说明数组已经是有序的，可以提前结束排序过程。</li><li><strong>针对部分有序数组的优化</strong>：如果数组在初始状态下已经接近有序，可以记录下每轮排序中最后一次交换的位置，然后下一轮排序时只需要遍历到该位置即可，这样可以大大减少排序的比较次数。</li><li><strong>鸡尾酒排序（双向冒泡排序）</strong>：在一次排序过程中，既从左到右比较交换，又从右到左比较交换，可以在某些特定情况下提升效率。</li></ul><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n)<br>当输入数据已经是有序时，冒泡排序可以通过设置一个标志变量来检测是否发生了交换操作，如果在某一趟排序中没有交换操作发生，说明数组已经有序，因此可以提前结束排序过程。此时，最优时间复杂度为 O(n)。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n^2)<br>在最坏情况下，输入数据是逆序的，此时需要进行 n-1 趟排序，每一趟排序中需要进行的比较次数逐渐减少，总比较次数为 n(n-1)&#x2F;2，因此最坏时间复杂度为 O(n^2)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n^2)<br>在一般情况下，冒泡排序的比较和交换操作的次数与输入数据的初始排列状态有关，但总体而言其时间复杂度仍为 O(n^2)。</p></li></ul><p>空间复杂度：</p><p>冒泡排序是一种<strong>原地排序算法</strong>，它在排序过程中只需要常数级的额外空间，即只使用了少量的辅助变量，因此其空间复杂度为 O(1)。</p><p>稳定性：</p><p>冒泡排序是一种<strong>稳定排序算法</strong>。在排序过程中，如果两个相等的元素相互比较，它们不会交换位置，因此相等元素的相对位置不会改变。</p><p>冒泡排序由于其简单易懂的特性，常用于教学和小规模数据集的排序，但由于其较低的效率，通常不适合大规模数据集的排序任务。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序（Selection Sort）是一种简单的比较排序算法。它的基本思想是在未排序数组中找到最小（或最大）的元素，然后将其放置到数组的起始位置，接着在剩余的未排序部分中继续寻找最小（或最大）的元素，依次类推，直到所有元素都排序完成。</p><p>步骤：</p><ol><li><p><strong>初始状态：</strong> 将整个序列看作两部分，一部分是未排序的，一部分是已排序的（初始时已排序部分为空）。</p></li><li><p><strong>遍历未排序部分：</strong> 遍历未排序部分，找到最小（或最大）的元素。</p></li><li><p><strong>交换元素：</strong> 将找到的最小（或最大）元素与未排序部分的第一个元素交换位置，使得找到的最小元素成为已排序部分的最后一个元素。</p></li><li><p><strong>扩大已排序部分：</strong> 将已排序部分的长度增加 1，未排序部分的长度减少 1。</p></li><li><p><strong>重复：</strong> 重复以上步骤，直到所有元素都已经排序完毕。</p></li></ol><p>这个过程类似于每次从一堆未排序的卡片中选出最小（或最大）的卡片，然后放到已排序的卡片堆中。选择排序的特点是每次遍历都只进行一次交换操作，因此相对于其他排序算法，它的交换次数较少。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层循环，遍历整个数组，每次找到当前未排序部分的最小元素并放到已排序部分的末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i <span class="comment">// 设置当前循环最小元素索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层循环，从当前元素的下一个位置开始遍历，找到未排序部分的最小元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素比最小元素索引小，则更新最小元素索引</span></span><br><span class="line">            <span class="keyword">if</span> (array[minIndex] &gt; array[j]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换最小元素到当前位置</span></span><br><span class="line">        <span class="title function_">swap</span>(array, i, minIndex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = array[left]</span><br><span class="line">    array[left] = array[right]</span><br><span class="line">    array[right] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">selectionSort</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n^2)<br>无论输入数据的初始排列状态如何，选择排序总是需要进行 n(n-1)&#x2F;2 次比较，因此最优时间复杂度为 O(n^2)。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n^2)<br>同样地，在最坏情况下，选择排序仍需要进行 n(n-1)&#x2F;2 次比较，所以最坏时间复杂度为 O(n^2)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n^2)<br>由于选择排序每一趟排序所需的比较次数固定，因此其平均时间复杂度也为 O(n^2)。</p></li></ul><p>空间复杂度：</p><p>选择排序是一种<strong>原地排序算法</strong>，只需要常数级的辅助空间（通常是用于交换元素的临时变量），因此其空间复杂度为 O(1)。</p><p>稳定性：</p><p>选择排序通常<strong>不是稳定排序</strong>。在选择排序过程中，每次从未排序部分选择最小（或最大）元素并将其与未排序部分的第一个元素交换时，如果相等元素存在，原有的相对顺序可能会被打破。例如：</p><ul><li>初始数组：[3, 2, 2, 1]</li><li>第一次选择：选择最小元素 1，与第一个元素 3 交换，结果：[1, 2, 2, 3]</li><li>第二次选择：选择最小元素 2，与第二个元素 2 交换，结果：[1, 2, 2, 3]</li></ul><p>虽然这个例子没有改变相同元素的相对顺序，但在某些情况下，如处理：[2, 3, 1, 2]，第二个“2”会被提前，与第一个“2”交换，导致顺序改变。</p><p>选择排序由于其简单性和恒定的空间复杂度，适用于对内存空间要求较高但对时间效率要求不高的场景。然而，由于其 O(n^2) 的时间复杂度，选择排序在处理大规模数据集时效率较低，通常不作为首选的排序算法。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序（Insertion Sort）是一种简单的比较排序算法。它的基本思想是将待排序数组分成<strong>已排序</strong>和<strong>未排序</strong>两部分，初始时已排序部分只有一个元素（即数组的第一个元素），然后从未排序部分依次取出元素，将其插入到已排序部分的正确位置，直到所有元素都被插入完成。</p><blockquote><p>插入排序类似扑克牌思想，想象在打扑克牌，拿起来第一张，放哪里无所谓，再拿起来一张，比第一张小，放左边，继续拿，可能是中间数，就插在中间，依次把牌拿完。</p></blockquote><p>步骤：</p><ol><li><strong>初始已排序部分</strong>：初始时，将待排序数组的第一个元素视为已排序部分，其余元素视为未排序部分。</li><li><strong>遍历未排序部分</strong>：从第二个元素开始，依次遍历未排序部分的元素。</li><li><strong>插入到已排序部分</strong>：对于每个未排序部分的元素，将其与已排序部分的元素逐个比较，找到正确的插入位置。</li><li><strong>重复插入</strong>：将元素插入到已排序部分的正确位置后，已排序部分的长度增加 1，未排序部分的长度减少 1，继续重复上述步骤，直到所有元素都被插入完成。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环从 1 开始，0 位置为默认的已排序的序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = array[i] <span class="comment">// 保存当前需要排序的元素</span></span><br><span class="line">        <span class="keyword">let</span> j = i</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置</span></span><br><span class="line">        <span class="keyword">while</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将找到的位置插入元素</span></span><br><span class="line">        array[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">insertSort</span>([<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n)<br>当输入数据已经有序时，插入排序每次只需要比较一次即可确定元素的位置，无需进行交换操作。此时，最优时间复杂度为 O(n)。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n^2)<br>在最坏情况下，输入数据是逆序的。此时，插入排序需要进行大量的比较和移动操作，每次插入元素时都需要将其与已经排序的部分进行比较并移动其他元素。因此最坏时间复杂度为 O(n^2)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n^2)<br>在一般情况下，插入排序的比较和移动操作次数与输入数据的初始排列状态有关，但总体而言，其平均时间复杂度为 O(n^2)。</p></li></ul><p>空间复杂度：</p><p>插入排序是一种<strong>原地排序算法</strong>，它在排序过程中只需要常数级的额外空间（用于存储待插入的元素的临时变量），因此其空间复杂度为 O(1)。</p><p>稳定性：</p><p>插入排序是一种<strong>稳定排序算法</strong>。在插入过程中，如果待插入的元素与已排序部分的某个元素相等，插入排序会将待插入的元素放在相等元素的后面，从而保持相等元素的相对顺序不变。</p><p>插入排序由于其简单性和对小规模数据集的高效性，常用于对小型数组进行排序或在其他更复杂的排序算法（如快速排序、归并排序）的过程中处理小数据块。然而，由于其 O(n^2) 的时间复杂度，插入排序在处理大规模数据集时效率较低。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序（Shell Sort）是一种改进的插入排序算法，也被称为“缩小增量排序”。它的基本思想是通过定义一个间隔序列（称为增量序列），将待排序数组分成若干个子序列，对每个子序列进行插入排序。随着排序的进行，增量序列逐渐缩小，直到增量为 1，最后对整个数组进行插入排序。</p><p>步骤：</p><ol><li><strong>选择增量序列</strong>：定义一个增量序列，确定每个增量值（间隔），通常以递减的方式选择。</li><li><strong>分组排序</strong>：将待排序数组根据当前增量值分成若干个子序列，对每个子序列进行插入排序。</li><li><strong>逐步缩小增量</strong>：重复上述步骤，逐步缩小增量值，直到增量为 1。</li><li><strong>最终排序</strong>：当增量为 1 时，对整个数组进行一次插入排序，完成排序过程。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hillSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果输入不是数组或者数组长度小于等于 1，直接返回原数组，不需要排序</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一层循环：确定增量的大小，每次增量的大小减半</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>); gap &gt;= <span class="number">1</span>; gap = <span class="built_in">parseInt</span>(gap &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">// 对每个分组使用插入排序，相当于将插入排序的 1 换成了 gap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = array[i] <span class="comment">// 保存当前元素</span></span><br><span class="line">      <span class="keyword">let</span> j = i</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第二层循环：对当前分组进行插入排序</span></span><br><span class="line">      <span class="comment">// 如果 j - gap &gt;= 0 并且前一个元素大于当前元素，则进行交换</span></span><br><span class="line">      <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; array[j - gap] &gt; temp) &#123;</span><br><span class="line">        array[j] = array[j - gap] <span class="comment">// 将前一个元素后移</span></span><br><span class="line">        j -= gap <span class="comment">// 继续比较下一个分组内的元素</span></span><br><span class="line">      &#125;</span><br><span class="line">      array[j] = temp <span class="comment">// 插入元素到正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array <span class="comment">// 返回排序后的数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">hillSort</span>([<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><p>希尔排序的时间复杂度较为复杂，与所选的增量序列（gap sequence）有很大关系。常见的增量序列有希尔增量序列、Hibbard 增量序列、Sedgewick 增量序列等。以下是几种常见增量序列的时间复杂度分析：</p><ul><li><p><strong>希尔增量序列</strong>（gap &#x3D; n&#x2F;2, n&#x2F;4, …, 1）：最坏时间复杂度：O(n^2)</p></li><li><p><strong>Hibbard 增量序列</strong>（gap &#x3D; 2^k - 1）：最坏时间复杂度：O(n^(3&#x2F;2))</p></li><li><p><strong>Sedgewick 增量序列</strong>（一种较为复杂的序列）：最坏时间复杂度：O(n^(4&#x2F;3))</p></li><li><p><strong>更优的增量序列</strong>：有些优化过的增量序列可以达到 O(n log^2 n) 的最坏时间复杂度。</p></li></ul><p>由于增量序列的选择对希尔排序的时间复杂度有很大的影响，所以具体的时间复杂度因实现而异，但通常在 O(n^2) 和 O(n log^2 n) 之间。</p><p>空间复杂度：</p><p>希尔排序是一种<strong>原地排序算法</strong>，其空间复杂度为 O(1)，只需要常数级的额外空间。</p><p>稳定性：</p><p>希尔排序<strong>不是稳定排序</strong>。在排序过程中，元素可能会跨越多个位置进行交换，因此相同元素的相对顺序可能会被打乱。</p><p>希尔排序由于其高效性和相对简单的实现，在实际应用中有一定的优势，特别是在数据规模较大时。它通过对插入排序的改进，大大减少了数据移动的次数，从而提高了排序的效率。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序（Merge Sort）是一种基于分治法的高效排序算法。其基本思想是将数组分成更小的子数组，分别对这些子数组进行排序，然后再将它们合并起来，以得到一个有序的数组。</p><p>步骤：</p><ol><li><strong>分割（Divide）</strong>：将数组从中间分成两个子数组（递归地分割直到子数组的长度为 1）。</li><li><strong>排序（Conquer）</strong>：对每个子数组进行排序。因为子数组的长度为 1，所以它们是有序的。</li><li><strong>合并（Combine）</strong>：将两个有序的子数组合并成一个有序的数组。重复这个过程，直到所有的子数组被合并成一个完整的有序数组。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于 0，直接返回，不需要排序</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>) <span class="comment">// 找到中间索引值</span></span><br><span class="line">  <span class="keyword">const</span> left = array.<span class="title function_">slice</span>(<span class="number">0</span>, mid) <span class="comment">// 截取左半部分</span></span><br><span class="line">  <span class="keyword">const</span> right = array.<span class="title function_">slice</span>(mid, length) <span class="comment">// 截取右半部分</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right)) <span class="comment">// 递归分解后，进行排序合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">leftArray, rightArray</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> leftLength = leftArray.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> rightLength = rightArray.<span class="property">length</span></span><br><span class="line">  <span class="keyword">let</span> il = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> ir = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; leftLength &amp;&amp; ir &lt; rightLength) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftArray[il] &lt; rightArray[ir]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(leftArray[il++])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(rightArray[ir++])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; leftLength) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(leftArray[il++])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。</span></span><br><span class="line">  <span class="keyword">while</span> (ir &lt; rightLength) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(rightArray[ir++])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergeSort</span>([<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>基本过程：</p><ol><li><strong>分割</strong>：将待排序数组分成两半。</li><li><strong>递归排序</strong>：对每一半分别进行递归排序。</li><li><strong>合并</strong>：合并两个有序子数组以形成一个有序的整体。</li></ol><p>时间复杂度：</p><ol><li><strong>最优时间复杂度</strong>：O(n log n)</li><li><strong>最坏时间复杂度</strong>：O(n log n)</li><li><strong>平均时间复杂度</strong>：O(n log n)</li></ol><p>归并排序在最优、最坏和平均情况下的时间复杂度都是 O(n log n)，因为它始终将数组分成两半，然后对每一半进行排序，再合并结果。</p><p>空间复杂度：</p><p>归并排序的空间复杂度为 O(n)，这是因为归并排序在合并过程中需要一个额外的数组来暂存数据。对于递归实现，还需要考虑递归调用的栈空间，但总的额外空间仍然是 O(n)。</p><p>稳定性：</p><p>归并排序是一种<strong>稳定排序算法</strong>。在合并两个有序子数组的过程中，如果两个元素相等，先将前一个数组的元素放入结果数组中，从而保持相等元素的相对顺序不变。</p><p>归并排序由于其稳定性和 O(n log n) 的时间复杂度，常用于处理大规模数据集，尤其是在需要稳定排序的情况下。虽然归并排序的空间复杂度较高，但其分治策略使其在许多应用中表现出色。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序（Quick Sort）是一种高效的排序算法，基于分治法。它通过选择一个”基准”（pivot）元素，并将数组分成两部分，其中一部分的所有元素都小于基准，另一部分的所有元素都大于基准。然后递归地对这两部分进行排序。</p><p>步骤：</p><ol><li><strong>选择基准</strong>：从数组中选择一个元素作为基准（pivot）。</li><li><strong>分区</strong>：重新排列数组，使得所有小于基准的元素在基准的左边，所有大于基准的元素在基准的右边（相等的元素可以放在任一侧）。此时基准元素处于其正确的位置。</li><li><strong>递归排序</strong>：递归地对基准左边的子数组和右边的子数组进行排序。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于 0，直接返回，不需要排序</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择基准</span></span><br><span class="line">  <span class="keyword">const</span> pivot = array[array.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  <span class="comment">// 使用两个数组 left 和 right 来存储小于和大于基准的元素</span></span><br><span class="line">  <span class="keyword">const</span> left = []</span><br><span class="line">  <span class="keyword">const</span> right = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分区过程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(array[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归地排序左右子数组并合并</span></span><br><span class="line">  <span class="keyword">return</span> [...<span class="title function_">quickSort</span>(left), pivot, ...<span class="title function_">quickSort</span>(right)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">quickSort</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n log n)<br>当每次划分的子数组都比较均匀时，递归树的高度为 log n，每层的操作复杂度为 O(n)，所以最优时间复杂度为 O(n log n)。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n^2)<br>在最坏情况下，每次划分的子数组高度不均匀，例如每次选择的基准（pivot）是最大或最小元素，这会导致递归树退化为链表形式，时间复杂度为 O(n^2)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n log n)<br>在实际应用中，快速排序的平均性能通常很好，期望时间复杂度为 O(n log n)，因为随机选择基准或使用“三数取中”等方法可以有效避免最坏情况。</p></li></ul><p>空间复杂度：</p><p>快速排序的空间复杂度主要取决于递归调用栈的深度：</p><ul><li><p><strong>平均空间复杂度</strong>：O(log n)<br>在理想情况下，递归调用栈的深度为 log n，因此空间复杂度为 O(log n)。</p></li><li><p><strong>最坏空间复杂度</strong>：O(n)<br>在最坏情况下，递归调用栈的深度为 n，因此空间复杂度为 O(n)。</p></li></ul><p>稳定性：</p><p>快速排序<strong>不是稳定排序</strong>。在排序过程中，元素的相对顺序可能会被改变，因为基准元素的交换可能会使得相等的元素顺序颠倒。</p><p>快速排序因其高效性和较好的平均性能，广泛应用于各种排序任务。通过随机选择基准或“三数取中”等方法，可以有效地改善其性能，避免最坏情况的发生。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序（Heap Sort）是一种基于二叉堆数据结构的比较排序算法。堆排序可以分为两个阶段：构建初始堆和在堆上进行排序操作。</p><p>步骤：</p><ol><li><strong>构建最大堆</strong>：将无序数组构建成一个最大堆（max heap），最大堆是一个完全二叉树，其中每个节点的值都大于或等于其子节点的值。</li><li><strong>排序</strong>：交换堆顶元素（最大值）和堆的最后一个元素，并将堆的大小减少 1。然后对堆的根节点进行调整，使其重新成为最大堆。<br>重复上述步骤，直到堆中剩余元素只剩一个，即完成排序。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> n = array.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建最大堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">heapify</span>(array, n, i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逐一从堆中取出元素，并对剩余元素重新堆化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 将堆顶（最大值）和堆的最后一个元素交换</span></span><br><span class="line">    ;[array[<span class="number">0</span>], array[i]] = [array[i], array[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对堆的剩余部分重新堆化</span></span><br><span class="line">    <span class="title function_">heapify</span>(array, i, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆化函数，维护堆的性质</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapify</span>(<span class="params">array, n, i</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> largest = i <span class="comment">// 假设当前节点是最大值</span></span><br><span class="line">  <span class="keyword">const</span> left = <span class="number">2</span> * i + <span class="number">1</span> <span class="comment">// 左子节点</span></span><br><span class="line">  <span class="keyword">const</span> right = <span class="number">2</span> * i + <span class="number">2</span> <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果左子节点大于当前节点，则更新最大值</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt; n &amp;&amp; array[left] &gt; array[largest]) &#123;</span><br><span class="line">    largest = left</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果右子节点大于当前节点，则更新最大值</span></span><br><span class="line">  <span class="keyword">if</span> (right &lt; n &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">    largest = right</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果最大值不是当前节点，则交换并继续堆化</span></span><br><span class="line">  <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">    ;[array[i], array[largest]] = [array[largest], array[i]]</span><br><span class="line">    <span class="title function_">heapify</span>(array, n, largest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">heapSort</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n log n)<br>在最优情况下，堆排序的时间复杂度为 O(n log n)，因为构建最大堆和进行堆排序的时间复杂度都是 O(n log n)。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n log n)<br>在最坏情况下，堆排序的时间复杂度也是 O(n log n)。无论输入数据的顺序如何，都需要将数据构建成最大堆，然后进行排序。</p></li><li><p><strong>平均时间复杂度</strong>：O(n log n)</p></li></ul><p>空间复杂度：</p><p>堆排序是一种<strong>原地排序算法</strong>，它只需要常数级别的额外空间来存储堆的数据结构，因此其空间复杂度为 O(1)。</p><p>稳定性：</p><p>堆排序<strong>不是稳定排序算法</strong>。在堆排序中，可能会破坏相同元素的相对顺序，因此它不是稳定的排序算法。</p><p>堆排序由于其高效性和原地排序的特性，常用于需要稳定且较高性能的排序任务。虽然堆排序的实现相对复杂，但它的时间复杂度稳定在 O(n log n)，在实践中具有较好的性能表现。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序（Radix Sort）是一种非比较性的排序算法，它根据关键字的每个位的值来排序。基数排序适用于元素都是整数的数组，其中每个元素都有相同的位数或范围。基本思想是将待排序的元素按照位数进行分组，然后按照每一位的顺序依次排序。</p><p>步骤：</p><ol><li><p><strong>按照最低有效位进行排序</strong>：从最低位（个位）开始，将元素按照该位的值进行分组（例如 0 到 9），并按照顺序重新排列。</p></li><li><p><strong>依次对更高位进行排序</strong>：对每一位重复上述排序过程，直到按照最高位排序完成。</p></li><li><p><strong>合并分组</strong>：每次按照位数排序后，将所有分组合并为一个数组，形成新的待排序数组。</p></li><li><p><strong>重复步骤 1~3</strong>，直到所有位都被处理完毕。</p></li></ol><p>示例：</p><p>假设我们有一个无序数组 <code>[170, 45, 75, 90, 802, 24, 2, 66]</code>，使用基数排序对其进行排序：</p><ol><li><p><strong>按照个位进行排序</strong>：<br>将数字按照个位的值进行分组：<code>[170, 90, 802, 2], [24], [45, 75], [66]</code>，并按照顺序重新排列：<code>[170, 90, 802, 2, 24, 45, 75, 66]</code>。</p></li><li><p><strong>按照十位进行排序</strong>：<br>将数字按照十位的值进行分组：<code>[802, 2], [24], [45, 66], [75], [170, 90]</code>，并按照顺序重新排列：<code>[802, 2, 24, 45, 66, 75, 170, 90]</code>。</p></li><li><p><strong>按照百位进行排序</strong>（如果有的话）。</p></li><li><p>排序完成，得到有序数组 <code>[2, 24, 45, 66, 75, 90, 170, 802]</code>。</p></li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数字的指定位数上的数字</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDigit</span>(<span class="params">num, place</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(num) / <span class="number">10</span> ** place) % <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数字的位数（最大位数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">digitCount</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">log10</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(num))) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中最大数字的位数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mostDigits</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> maxDigits = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    maxDigits = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxDigits, <span class="title function_">digitCount</span>(nums[i]))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxDigits</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">radixSort</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> maxDigitCount = <span class="title function_">mostDigits</span>(nums)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; maxDigitCount; k++) &#123;</span><br><span class="line">    <span class="comment">// 创建 10 个桶（0 到 9）</span></span><br><span class="line">    <span class="keyword">const</span> digitBuckets = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">() =&gt;</span> [])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数字放入相应的桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> digit = <span class="title function_">getDigit</span>(nums[i], k)</span><br><span class="line">      digitBuckets[digit].<span class="title function_">push</span>(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并所有桶中的数字成为新的待排序数组</span></span><br><span class="line">    nums = [].<span class="title function_">concat</span>(...digitBuckets)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">radixSort</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n * k)<br>最优情况下，每个关键字的位数相同，基数排序的时间复杂度为 O(n * k)，其中 n 是元素个数，k 是关键字的位数。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n * k)<br>最坏情况下，基数排序的时间复杂度仍然为 O(n * k)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n * k)<br>基数排序的平均时间复杂度也为 O(n * k)，其中 k 通常为常数。</p></li></ul><p>基数排序的时间复杂度主要取决于关键字的位数和元素个数，与元素的大小范围无关。</p><p>空间复杂度：</p><p>基数排序的空间复杂度取决于辅助存储空间的使用，通常需要一个额外的数组来存储中间结果。因此，其空间复杂度为 O(n + k)，其中 n 是元素个数，k 是关键字的范围（通常是 10）。</p><p>稳定性：</p><p>基数排序是一种<strong>稳定排序算法</strong>。在基数排序过程中，相同位数的元素根据其原始顺序进行排序，不会改变相等元素的相对位置，因此是稳定的。</p><p>基数排序适用于处理整数或字符串等具有固定位数的元素集合。它的时间复杂度相对较低，并且是稳定排序算法，因此在一些特定的排序场景中具有一定的优势。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序（Counting Sort）是一种非比较性的排序算法，适用于待排序元素都属于一个有限范围的整数。计数排序的基本思想是通过统计待排序数组中每个元素出现的次数，然后根据统计信息将元素放置到正确的位置上。</p><p>步骤：</p><ol><li><strong>统计元素出现次数</strong>：遍历待排序数组，统计每个元素出现的次数，存储在一个辅助数组中。</li><li><strong>累加统计次数</strong>：对统计数组进行累加，使得每个位置存储的值表示小于等于该值的元素的个数。</li><li><strong>根据统计信息排序</strong>：遍历待排序数组，根据统计数组中的信息，将元素放置到正确的位置上。</li></ol><p>示例：</p><p>假设我们有一个无序数组 <code>[4, 2, 2, 8, 3, 3, 1]</code>，使用计数排序对其进行排序：</p><ol><li><p><strong>统计元素出现次数</strong>：统计数组中每个元素的出现次数：<code>[1:1, 2:2, 3:2, 4:1, 8:1]</code>。</p></li><li><p><strong>累加统计次数</strong>：将统计数组中的值进行累加：<code>[1:1, 2:3, 3:5, 4:6, 8:7]</code>，表示小于等于每个元素的个数。</p></li><li><p><strong>根据统计信息排序</strong>：根据累加统计次数，将待排序数组中的元素放置到正确的位置上，得到有序数组 <code>[1, 2, 2, 3, 3, 4, 8]</code>。</p></li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countingSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="comment">// 找到待排序数组中的最大值和最小值</span></span><br><span class="line">  <span class="keyword">let</span> min = array[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> max = array[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &lt; min) min = array[i]</span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) max = array[i]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建统计数组，长度为 max - min + 1</span></span><br><span class="line">  <span class="keyword">const</span> countArray = <span class="keyword">new</span> <span class="title class_">Array</span>(max - min + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计每个元素出现的次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    countArray[array[i] - min]++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据统计信息对元素进行排序</span></span><br><span class="line">  <span class="keyword">let</span> sortedIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; countArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (countArray[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      array[sortedIndex] = i + min</span><br><span class="line">      sortedIndex++</span><br><span class="line">      countArray[i]--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countingSort</span>([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li><p><strong>最优时间复杂度</strong>：O(n + k)<br>最优情况下，计数排序的时间复杂度为 O(n + k)，其中 n 是元素个数，k 是元素的范围。</p></li><li><p><strong>最坏时间复杂度</strong>：O(n + k)<br>最坏情况下，计数排序的时间复杂度仍然为 O(n + k)。</p></li><li><p><strong>平均时间复杂度</strong>：O(n + k)<br>计数排序的平均时间复杂度也为 O(n + k)。</p></li></ul><p>计数排序的时间复杂度主要取决于元素的范围，而与元素的个数无关。</p><p>空间复杂度：</p><p>计数排序的空间复杂度取决于额外的计数数组和输出数组。因此，其空间复杂度为 O(n + k)，其中 n 是元素个数，k 是元素的范围。</p><p>稳定性：</p><p>计数排序是一种<strong>稳定排序算法</strong>。在计数排序中，相同元素的相对顺序不会改变，因此是稳定的。</p><p>计数排序适用于对一定范围内的整数进行排序，并且适合于元素范围不是很大的情况下。由于其时间复杂度和空间复杂度均为线性，因此在一些特定的排序场景中具有较好的性能表现。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>搜索算法简单来说就是用于找出数组中某个元素的下标。</p><p>JavaScript 语言中的自带的搜索：数组的 <code>indexOf</code> 方法。</p><h3 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h3><p>顺序搜索（Sequential Search）算法是一种简单的搜索算法，它按顺序检查列表中的每个元素，直到找到目标元素或遍历完整个列表。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sequentialSearch</span>(<span class="params">array, target</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历数组中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素等于目标元素，则返回当前元素的索引</span></span><br><span class="line">        <span class="keyword">if</span> (array[i] === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果未找到目标元素，则返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sequentialSearch</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">0</span>)) <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sequentialSearch</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>顺序搜索的时间复杂度为 O(n)，其中 n 是列表的长度。</p><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>二分搜索（Binary Search）是一种高效的搜索算法，适用于有序数组。该算法通过重复将搜索范围缩小为一半来找到目标值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr, target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span> <span class="comment">// 搜索范围的最低索引</span></span><br><span class="line">  <span class="keyword">let</span> high = arr.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// 搜索范围的最高索引</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((low + high) / <span class="number">2</span>) <span class="comment">// 中间索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid <span class="comment">// 找到目标元素，返回索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span> <span class="comment">// 目标元素在右半部分，调整搜索范围的最低索引</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span> <span class="comment">// 目标元素在左半部分，调整搜索范围的最高索引</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span> <span class="comment">// 目标元素未找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">0</span>)) <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>二分搜索的时间复杂度为 O(log n)，其中 n 是数组的长度。</p><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分而治之（分治法）是一种常见的算法设计思想，其核心是将一个大问题分解成小的子问题，分别解决这些子问题，然后将子问题的解合并起来得到原问题的解。这种思想在很多算法中都有广泛的应用，特别是在解决递归问题时很常见。</p><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol><li><strong>分解（Divide）</strong>：将原问题划分成若干个规模较小的子问题。</li><li><strong>解决（Conquer）</strong>：递归地解决这些子问题，如果子问题规模足够小，则直接求解。</li><li><strong>合并（Combine）</strong>：将子问题的解合并成原问题的解。</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>排序算法：如<strong>归并排序</strong>和<strong>快速排序</strong>。</li><li>搜索算法：如<strong>二分搜索</strong>。</li><li>数据压缩：如哈夫曼编码。</li><li>分布式计算：如 MapReduce 等。</li></ul><h4 id="分而治之的应用"><a href="#分而治之的应用" class="headerlink" title="分而治之的应用"></a>分而治之的应用</h4><h5 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/majority-element/description/" >LeetCode #169 简单<i class="fas fa-external-link-alt"></i></a></p><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code>，返回其中的多数元素。多数元素是指在数组中出现次数大于 <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [3, 2, 3]<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [2, 2, 1, 1, 1, 2, 2]<br>输出：2</p></blockquote><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><p>解题步骤：</p><ol><li><strong>分解</strong>：将数组分成左右两部分。</li><li><strong>解决子问题</strong>：递归地在左右两部分中分别找出多数元素。</li><li><strong>合并</strong>：<ul><li>如果左右部分的多数元素相同，则该元素即为整个数组的多数元素。</li><li>如果左右部分的多数元素不同，则需要统计这两个元素在整个数组中的出现次数，出现次数较多的元素即为多数元素。</li></ul></li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">majorityElement</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="comment">// 辅助函数：统计元素在给定区间内的出现次数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">countInRange</span>(<span class="params">nums, num, left, right</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nums[i] === num) &#123;</span><br><span class="line">            count++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 分治算法主函数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">majorityElementRec</span>(<span class="params">nums, left, right</span>) &#123;</span><br><span class="line">      <span class="comment">// 基本情况：只有一个元素时</span></span><br><span class="line">      <span class="keyword">if</span> (left === right) &#123;</span><br><span class="line">         <span class="keyword">return</span> nums[left]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将数组分成左右两部分</span></span><br><span class="line">      <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">const</span> leftMajority = <span class="title function_">majorityElementRec</span>(nums, left, mid)</span><br><span class="line">      <span class="keyword">const</span> rightMajority = <span class="title function_">majorityElementRec</span>(nums, mid + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果左右部分的多数元素相同，则返回该元素</span></span><br><span class="line">      <span class="keyword">if</span> (leftMajority === rightMajority) &#123;</span><br><span class="line">         <span class="keyword">return</span> leftMajority</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 否则统计左右多数元素在整个区间内的出现次数</span></span><br><span class="line">      <span class="keyword">const</span> leftCount = <span class="title function_">countInRange</span>(nums, leftMajority, left, right)</span><br><span class="line">      <span class="keyword">const</span> rightCount = <span class="title function_">countInRange</span>(nums, rightMajority, left, right)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回出现次数较多的元素</span></span><br><span class="line">      <span class="keyword">return</span> leftCount &gt; rightCount ? leftMajority : rightMajority</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用递归函数，从整个数组开始</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">majorityElementRec</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">majorityElement</span>([<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 输出：3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">majorityElement</span>([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])) <span class="comment">// 输出：2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">majorityElement</span>([<span class="number">1</span>])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">majorityElement</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])) <span class="comment">// 输出：1</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>时间复杂度</strong>：O(n log n)，每次递归将数组分为两部分，类似于归并排序，每层的合并操作需要线性时间，递归深度为 log n，因此总时间复杂度为 O(n log n)。</p></li><li><p><strong>空间复杂度</strong>：O(log n)，递归调用栈的深度为 log n，因此空间复杂度为 O(log n)（不包括输入和输出所占用的空间）。</p></li></ul><h5 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/sort-an-array/description" >LeetCode #912 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [5, 2, 3, 1]<br>输出：[1, 2, 3, 5]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [5, 1, 1, 2, 0, 0]<br>输出：[0, 0, 1, 1, 2, 5]</p></blockquote><p>要将一个整数数组进行排序，我们可以使用分而治之的思想，这里我们选择<strong>归并排序</strong>作为实现方法，归并排序是一种稳定的排序算法。</p><p>解题步骤：</p><ol><li><strong>递归终止条件</strong>：当数组长度小于等于 1 时，返回数组本身，因为它已经是有序的。</li><li><strong>分解数组</strong>：找到数组的中点，将数组分成左右两部分。</li><li><strong>递归排序</strong>：递归地对左右两部分进行排序。</li><li><strong>合并</strong>：合并两个有序的子数组成一个有序的数组。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortArray</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="comment">// 主函数，调用归并排序函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">mergeSort</span>(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="comment">// 基本情况：如果数组长度小于等于 1，直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (nums.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算中点</span></span><br><span class="line">   <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 分别对左右两部分进行排序</span></span><br><span class="line">   <span class="keyword">const</span> left = <span class="title function_">mergeSort</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>, mid))</span><br><span class="line">   <span class="keyword">const</span> right = <span class="title function_">mergeSort</span>(nums.<span class="title function_">slice</span>(mid))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并排序好的左右两部分</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">merge</span>(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> sortedArray = []</span><br><span class="line">   <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并两个有序数组</span></span><br><span class="line">   <span class="keyword">while</span> (i &lt; left.<span class="property">length</span> &amp;&amp; j &lt; right.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left[i] &lt; right[j]) &#123;</span><br><span class="line">         sortedArray.<span class="title function_">push</span>(left[i])</span><br><span class="line">         i++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         sortedArray.<span class="title function_">push</span>(right[j])</span><br><span class="line">         j++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将剩余的元素添加到结果数组</span></span><br><span class="line">   <span class="keyword">while</span> (i &lt; left.<span class="property">length</span>) &#123;</span><br><span class="line">      sortedArray.<span class="title function_">push</span>(left[i])</span><br><span class="line">      i++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (j &lt; right.<span class="property">length</span>) &#123;</span><br><span class="line">      sortedArray.<span class="title function_">push</span>(right[j])</span><br><span class="line">      j++</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sortedArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortArray</span>([<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// 输出：[1, 2, 3, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortArray</span>([<span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>])) <span class="comment">// 输出：[0, 0, 1, 1, 2, 5]</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(N log N)，因为数组每次都被分成两部分，并且每次合并操作的时间复杂度为 O(N)。</li><li><strong>空间复杂度</strong>：O(N)，因为归并排序需要额外的空间来存储合并后的数组。</li></ul><h5 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/maximum-subarray/description/" >LeetCode #53 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [-2, 1, -3, 4, -1, 2, 1, -5, 4]<br>输出：6<br>解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [1]<br>输出：1</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [5, 4, -1, 7, 8]<br>输出：23</p></blockquote><p>解决最大子数组和问题，分而治之的思想是一种有效的方法。分而治之的基本思想是将问题分解成子问题，分别解决这些子问题，然后合并这些子问题的解来得到原问题的解。在这个问题中，我们将数组分成两个部分，然后递归地求解左右两部分的最大子数组和，并合并两部分的结果。</p><p>解题步骤：</p><ol><li><strong>递归终止条件</strong>：当数组长度为 1 时，返回数组的唯一元素。</li><li><strong>分解数组</strong>：找到数组的中点，将数组分成左右两部分。</li><li><strong>递归求解</strong>：递归地计算左半部分和右半部分的最大子数组和。</li><li><strong>合并</strong>：计算跨越中间的最大子数组和，包括：<ul><li>从中点向左扫描的最大子数组和。</li><li>从中点向右扫描的最大子数组和。</li><li>跨越中点的最大子数组和等于左半部分的最大和加上右半部分的最大和。</li></ul></li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxSubArray</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 分治法求解最大子数组和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">divideAndConquer</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divideAndConquer</span>(<span class="params">nums, left, right</span>) &#123;</span><br><span class="line">    <span class="comment">// 基本情况：如果只有一个元素，返回该元素</span></span><br><span class="line">    <span class="keyword">if</span> (left === right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算中间点</span></span><br><span class="line">    <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归求解左半部分和右半部分的最大子数组和</span></span><br><span class="line">    <span class="keyword">const</span> leftMax = <span class="title function_">divideAndConquer</span>(nums, left, mid)</span><br><span class="line">    <span class="keyword">const</span> rightMax = <span class="title function_">divideAndConquer</span>(nums, mid + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算跨越中间点的最大子数组和</span></span><br><span class="line">    <span class="keyword">const</span> crossMax = <span class="title function_">maxCrossingSubArray</span>(nums, left, mid, right)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回三个部分中最大的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftMax, rightMax, crossMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxCrossingSubArray</span>(<span class="params">nums, left, mid, right</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算左半部分的最大子数组和</span></span><br><span class="line">    <span class="keyword">let</span> leftSum = -<span class="title class_">Infinity</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = mid; i &gt;= left; i--) &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; leftSum) &#123;</span><br><span class="line">            leftSum = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算右半部分的最大子数组和</span></span><br><span class="line">    <span class="keyword">let</span> rightSum = -<span class="title class_">Infinity</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; rightSum) &#123;</span><br><span class="line">            rightSum = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回跨越中间点的最大子数组和</span></span><br><span class="line">    <span class="keyword">return</span> leftSum + rightSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSubArray</span>([-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>])) <span class="comment">// 输出：6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSubArray</span>([<span class="number">1</span>])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSubArray</span>([<span class="number">5</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>])) <span class="comment">// 输出：23</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n log n)：每次分治将问题分成两个子问题，类似于归并排序，每次合并时需要线性的时间来计算跨越中间的最大子数组和。</li><li><strong>空间复杂度</strong>：O(log n)：递归调用的深度为 log n，因此空间复杂度为 O(log n)（不包括输入和输出所占用的空间）。</li></ul><h5 id="数组中的第-K-个最大元素"><a href="#数组中的第-K-个最大元素" class="headerlink" title="数组中的第 K 个最大元素"></a>数组中的第 K 个最大元素</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description" >LeetCode #215 中等<i class="fas fa-external-link-alt"></i></a></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>示例 1:</p><blockquote><p>输入: [3, 2, 1, 5, 6, 4], k &#x3D; 2<br>输出：5</p></blockquote><p>示例 2:</p><blockquote><p>输入: [3, 2, 3, 1, 2, 4, 5, 5, 6], k &#x3D; 4<br>输出：4</p></blockquote><p>为了找到数组中的第 <code>k</code> 个最大元素，并且实现时间复杂度为 O(n) 的算法，我们可以使用<strong>快速选择算法（Quickselect）</strong>。快速选择算法是快速排序的变种，通过分而治之的方法来选择特定的第 <code>k</code> 个元素。</p><p>解题步骤：</p><ol><li><strong>选择一个主元（pivot）</strong>：通常选择数组的最后一个元素作为主元。</li><li><strong>分区</strong>：使用 Lomuto 分区方案，将数组重新排列，使得主元的位置是其最终位置，同时确保左边的元素都小于等于主元，右边的元素都大于主元。</li><li><strong>递归搜索</strong>：<ul><li>如果主元的位置正好是我们需要找的位置，直接返回主元。</li><li>如果主元的位置大于目标位置，在左半部分继续搜索。</li><li>如果主元的位置小于目标位置，在右半部分继续搜索。</li></ul></li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findKthLargest</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="comment">// 目标是找到第 k 大的元素，即排序后第 (n-k) 小的元素</span></span><br><span class="line">    <span class="keyword">const</span> targetIndex = nums.<span class="property">length</span> - k;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>, targetIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSelect</span>(<span class="params">nums, left, right, targetIndex</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="keyword">const</span> pivotIndex = <span class="title function_">partition</span>(nums, left, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pivotIndex === targetIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; targetIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">quickSelect</span>(nums, pivotIndex + <span class="number">1</span>, right, targetIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">quickSelect</span>(nums, left, pivotIndex - <span class="number">1</span>, targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">nums, left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> pivot = nums[right];</span><br><span class="line">    <span class="keyword">let</span> i = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">            [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [nums[i], nums[right]] = [nums[right], nums[i]];</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findKthLargest</span>([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>], <span class="number">2</span>)); <span class="comment">// 输出：5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findKthLargest</span>([<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">4</span>)); <span class="comment">// 输出：4</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：平均情况为 O(n)，因为每次分区都会将数组分成两部分。然而，在最坏情况下（例如数组已经有序时），时间复杂度可能达到 O(n^2)。</li><li><strong>空间复杂度</strong>：O(1)，因为快速选择是就地排序的算法，不需要额外的空间来存储数组。递归调用的栈空间为 O(log n)。</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划是一种解决复杂问题的方法，通过将问题分解成更小的子问题，<strong>并利用子问题的重叠性，避免重复计算</strong>，从而提高效率。动态规划的核心思想是利用已计算的结果来构建解决方案，从而减少不必要的计算。</p><h4 id="基本步骤-1"><a href="#基本步骤-1" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol><li><strong>定义子问题</strong>：将原问题分解为若干子问题，确定这些子问题的状态和状态之间的转移关系。</li><li><strong>确定状态转移方程</strong>：根据子问题的定义，找出当前状态与之前状态的关系，即状态转移方程。</li><li><strong>初始化</strong>：确定初始状态的值。</li><li><strong>填表计算</strong>：利用状态转移方程，从初始状态出发，逐步计算每个子问题的值，通常使用一个表格（数组）来存储子问题的解。</li><li><strong>返回结果</strong>：根据问题的要求，从表格中提取最终的结果。</li></ol><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>动态规划主要用于解决以下几类问题：</p><ul><li><strong>最优化问题</strong>：如最短路径、最大子序列和等问题。</li><li><strong>计数问题</strong>：如统计符合某些条件的方案数量。</li><li><strong>序列问题</strong>：如最长递增子序列、最长公共子序列等问题。</li><li><strong>划分问题</strong>：如背包问题、划分等问题。</li></ul><h4 id="动态规划的应用"><a href="#动态规划的应用" class="headerlink" title="动态规划的应用"></a>动态规划的应用</h4><h5 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/climbing-stairs/" >LeetCode #70 简单<i class="fas fa-external-link-alt"></i></a></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：</p><blockquote><p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol></blockquote><p>示例 2：</p><blockquote><p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></blockquote><p>解题步骤：</p><ol><li><strong>定义状态</strong>：定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示达到第 <code>i</code> 阶的方法总数。</li><li><strong>初始条件</strong>：知道 <code>dp[0] = 1</code>（到达第 0 阶的方法是站在原地）和 <code>dp[1] = 1</code>（到达第 1 阶的方法只有一种）。</li><li><strong>状态转移方程</strong>：为了到达第 <code>i</code> 阶，可以从第 <code>i-1</code> 阶迈一步或者从第 <code>i-2</code> 阶迈两步，所以 <code>dp[i] = dp[i-1] + dp[i-2]</code>。</li><li><strong>最终结果</strong>：<code>dp[n]</code> 表示达到第 <code>n</code> 阶的方法总数。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">climbStairs</span>(<span class="params">n</span>) &#123;</span><br><span class="line">   <span class="comment">// 如果楼梯阶数为 0 或 1，直接返回 n</span></span><br><span class="line">   <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建一个 dp 数组来存储每个台阶的方法数</span></span><br><span class="line">   <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始条件</span></span><br><span class="line">   dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算每个台阶的方法数</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回到达第 n 阶的方法总数</span></span><br><span class="line">   <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">climbStairs</span>(<span class="number">2</span>)) <span class="comment">// 输出：2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">climbStairs</span>(<span class="number">3</span>)) <span class="comment">// 输出：3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">climbStairs</span>(<span class="number">4</span>)) <span class="comment">// 输出：5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">climbStairs</span>(<span class="number">5</span>)) <span class="comment">// 输出：8</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)，因为只需遍历一次数组。</li><li><strong>空间复杂度</strong>：O(n)，需要一个长度为 <code>n+1</code> 的数组来存储每一阶的方法数。</li></ul><h5 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/longest-increasing-subsequence/description/" >LeetCode #300 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3, 6, 2, 7]</code> 是数组 <code>[0, 3, 1, 6, 2, 2, 7]</code> 的子序列。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [10, 9, 2, 5, 3, 7, 101, 18]<br>输出：4<br>解释：最长递增子序列是 [2, 3, 7, 101]，因此长度为 4。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [0, 1, 0, 3, 2, 3]<br>输出：4</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [7, 7, 7, 7, 7, 7, 7]<br>输出：1</p></blockquote><p>解题步骤：</p><ol><li><strong>定义状态</strong>：定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长递增子序列的长度。</li><li><strong>初始化</strong>：每个位置的初始值为 1，因为每个位置都至少可以是一个长度为 1 的子序列。</li><li><strong>状态转移方程</strong>：对于每个 <code>nums[i]</code>，遍历其之前的元素 <code>nums[j]</code> (0 ≤ j &lt; i)，如果 <code>nums[i] &gt; nums[j]</code>，则更新 <code>dp[i] = max(dp[i], dp[j] + 1)</code>，表示在 <code>nums[j]</code> 的子序列上追加 <code>nums[i]</code>。</li><li><strong>最终结果</strong>：数组 <code>dp</code> 中的最大值即为最长递增子序列的长度。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLIS</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// dp 数组，每个位置初始化为 1</span></span><br><span class="line">   <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算每个位置的最长递增子序列长度</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">            dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回 dp 数组中的最大值</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>([<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>])) <span class="comment">// 输出：4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 输出：4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>([<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>])) <span class="comment">// 输出：1</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n^2)，因为我们需要嵌套循环遍历每个元素对。</li><li><strong>空间复杂度</strong>：O(n)，需要一个长度为 <code>n</code> 的数组来存储每个位置的最长子序列长度。</li></ul><h5 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/house-robber/description/" >LeetCode #198 中等<i class="fas fa-external-link-alt"></i></a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><blockquote><p>输入：[1, 2, 3, 1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4。</p></blockquote><p>示例 2：</p><blockquote><p>输入：[2, 7, 9, 3, 1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12。</p></blockquote><p>解题步骤：</p><ol><li><strong>定义状态</strong>：定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示到达第 <code>i</code> 个房子时可以偷窃到的最高金额。</li><li><strong>初始条件</strong>：如果只有一个房子，那么可以偷窃的最高金额就是该房子的金额，即 <code>dp[0] = nums[0]</code>。如果有两个房子，则可以偷窃的最高金额是这两个房子中金额较大的那个，即 <code>dp[1] = Math.max(nums[0], nums[1])</code>。</li><li><strong>状态转移方程</strong>：对于每个房子 <code>i</code>，有两种选择：偷窃该房子（然后加上 <code>i-2</code> 房子的最高金额）或者不偷窃该房子（直接取 <code>i-1</code> 房子的最高金额）。状态转移方程为 <code>dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])</code>。</li><li><strong>最终结果</strong>：数组 <code>dp</code> 中的最后一个值即为可以偷窃到的最高金额。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rob</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> n = nums.<span class="property">length</span></span><br><span class="line">   <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">   <span class="comment">// dp 数组，每个位置初始化为 0</span></span><br><span class="line">   <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始条件</span></span><br><span class="line">   dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">   dp[<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 填充 dp 数组</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">      dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回 dp 数组的最后一个值</span></span><br><span class="line">   <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">rob</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// 输出：4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">rob</span>([<span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// 输出：12</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)，因为需要遍历一次数组。</li><li><strong>空间复杂度</strong>：O(n)，因为需要一个长度为 <code>n</code> 的数组来存储每个位置的最高金额。</li></ul><p>优化空间复杂度：</p><p>注意到我们在状态转移时，只需要前两个状态的值，所以可以将空间复杂度优化为 O(1)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rob</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> n = nums.<span class="property">length</span></span><br><span class="line">   <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> prev1 = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> prev2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = <span class="title class_">Math</span>.<span class="title function_">max</span>(prev1, prev2 + nums[i])</span><br><span class="line">      prev2 = prev1</span><br><span class="line">      prev1 = current</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> prev1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">rob</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// 输出：4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">rob</span>([<span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>])) <span class="comment">// 输出：12</span></span><br></pre></td></tr></table></figure><p>优化后的算法分析：</p><ul><li><strong>时间复杂度</strong>：O(n)，因为需要遍历一次数组。</li><li><strong>空间复杂度</strong>：O(1)，因为只需要常量空间来存储前两个状态的值。</li></ul><p>通过上述方法，我们可以有效地计算出不触动警报装置的情况下，可以偷窃到的最高金额。优化后的代码在空间复杂度上更高效。</p><h5 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/coin-change/description/" >LeetCode #322 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>coins</code>，表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><blockquote><p>输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3<br>解释：11 &#x3D; 5 + 5 + 1</p></blockquote><p>示例 2：</p><blockquote><p>输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1</p></blockquote><p>示例 3：</p><blockquote><p>输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0</p></blockquote><p>解题步骤：</p><ol><li><strong>定义状态</strong>：定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示凑成金额 <code>i</code> 所需的最少硬币个数。</li><li><strong>初始化</strong>：<code>dp[0] = 0</code>，因为凑成金额 <code>0</code> 所需的硬币数是 <code>0</code>。其他 <code>dp[i]</code> 初始化为一个较大的值（如 <code>Infinity</code>），表示还没有计算出结果。</li><li><strong>状态转移方程</strong>：对于每个金额 <code>i</code>，尝试使用每种硬币 <code>coin</code>，更新 <code>dp[i] = Math.min(dp[i], dp[i - coin] + 1)</code>，表示从金额 <code>i - coin</code> 加上一个 <code>coin</code> 的硬币数量。</li><li><strong>最终结果</strong>：如果 <code>dp[amount]</code> 仍然是初始值 <code>Infinity</code>，则表示无法凑成该金额，返回 <code>-1</code>，否则返回 <code>dp[amount]</code>。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">coinChange</span>(<span class="params">coins, amount</span>) &#123;</span><br><span class="line">   <span class="comment">// 创建一个 dp 数组，初始化为 Infinity</span></span><br><span class="line">   <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(amount + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="title class_">Infinity</span>)</span><br><span class="line">   dp[<span class="number">0</span>] = <span class="number">0</span> <span class="comment">// 初始化金额为 0 时的最少硬币数为 0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 填充 dp 数组</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i - coin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i], dp[i - coin] + <span class="number">1</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果 dp[amount] 还是 Infinity，表示无法凑成该金额，返回 -1</span></span><br><span class="line">   <span class="keyword">return</span> dp[amount] === <span class="title class_">Infinity</span> ? -<span class="number">1</span> : dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">coinChange</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], <span class="number">11</span>)) <span class="comment">// 输出：3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">coinChange</span>([<span class="number">2</span>], <span class="number">3</span>)) <span class="comment">// 输出：-1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">coinChange</span>([<span class="number">1</span>], <span class="number">0</span>)) <span class="comment">// 输出：0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">coinChange</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">7</span>)) <span class="comment">// 输出：2 (3 + 4)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">coinChange</span>([<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>], <span class="number">27</span>)) <span class="comment">// 输出：4 (10 + 10 + 5 + 2)</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n * m)，其中 <code>n</code> 是金额 <code>amount</code>，<code>m</code> 是硬币种类数。</li><li><strong>空间复杂度</strong>：O(n)，需要一个长度为 <code>amount + 1</code> 的数组来存储每个金额的最少硬币数。</li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是全局最优的算法。贪心算法的核心是贪心选择性质，即<strong>每一步的局部最优选择最终能够导致全局最优解</strong>。</p><h4 id="基本步骤-2"><a href="#基本步骤-2" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol><li><strong>建立数学模型</strong>：将问题抽象为数学模型，明确所需的解和约束条件。</li><li><strong>选择贪心策略</strong>：根据问题的特性，选择一个贪心策略，即在每一步选择中，采取局部最优的选择。</li><li><strong>证明贪心选择的正确性</strong>：证明所选的贪心策略能够得到问题的最优解，通常通过数学归纳法或反证法证明。</li><li><strong>实施贪心算法</strong>：从初始状态开始，按照贪心策略逐步推进，直到达到问题的约束条件或无法继续推进为止。</li><li><strong>构造解</strong>：根据选择的步骤，构造出问题的解。</li></ol><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>贪心算法通常用于以下几类问题：</p><ul><li><strong>最优化问题</strong>：如最小生成树、最短路径等问题。</li><li><strong>活动选择问题</strong>：如区间调度、任务安排等问题。</li><li><strong>资源分配问题</strong>：如背包问题的某些变种、最大子序列和等问题。</li><li><strong>图论问题</strong>：如 Dijkstra 算法求最短路径，Kruskal 算法和 Prim 算法求最小生成树。</li></ul><h4 id="贪心算法的应用"><a href="#贪心算法的应用" class="headerlink" title="贪心算法的应用"></a>贪心算法的应用</h4><h5 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/assign-cookies/description/" >LeetCode #455 简单<i class="fas fa-external-link-alt"></i></a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code>。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code>，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1:</p><blockquote><p>输入: g &#x3D; [1, 2, 3], s &#x3D; [1, 1]<br>输出：1<br>解释：<br>你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1, 2, 3。<br>虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。<br>所以你应该输出 1。</p></blockquote><p>示例 2:</p><blockquote><p>输入: g &#x3D; [1, 2], s &#x3D; [1, 2, 3]<br>输出：2<br>解释：<br>你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1, 2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出 2。</p></blockquote><p>先对孩子的满足度和饼干的大小排序，然后依次为每个孩子分配满足其满足度的最小饼干。</p><p>解题步骤：</p><ol><li><strong>排序</strong>：将孩子的胃口数组 <code>g</code> 和饼干尺寸数组 <code>s</code> 分别进行排序。</li><li><strong>匹配</strong>：使用两个指针，一个指向孩子的胃口数组，另一个指向饼干尺寸数组。依次尝试用当前最小的饼干去满足当前最小的胃口。</li><li><strong>更新指针</strong>：如果当前饼干可以满足当前孩子的胃口，两个指针都移动到下一个。如果不能，则只移动饼干的指针，尝试用下一个较大的饼干去满足当前孩子的胃口。</li><li><strong>结束条件</strong>：当两个指针都到达数组末尾时，匹配结束，返回满足孩子的数量。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findContentChildren</span>(<span class="params">g, s</span>) &#123;</span><br><span class="line">   <span class="comment">// 对孩子的胃口数组和饼干尺寸数组进行排序</span></span><br><span class="line">   g.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">   s.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> i = <span class="number">0</span> <span class="comment">// 孩子的指针</span></span><br><span class="line">   <span class="keyword">let</span> j = <span class="number">0</span> <span class="comment">// 饼干的指针</span></span><br><span class="line">   <span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 满足的孩子数量</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当孩子和饼干都没有处理完时进行匹配</span></span><br><span class="line">   <span class="keyword">while</span> (i &lt; g.<span class="property">length</span> &amp;&amp; j &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[j] &gt;= g[i]) &#123;</span><br><span class="line">         <span class="comment">// 当前饼干可以满足当前孩子</span></span><br><span class="line">         count++</span><br><span class="line">         i++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 无论是否满足，都尝试下一个饼干</span></span><br><span class="line">      j++</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findContentChildren</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findContentChildren</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 输出：2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findContentChildren</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findContentChildren</span>([<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])) <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n log n + m log m)，其中 <code>n</code> 是孩子数组的长度，<code>m</code> 是饼干数组的长度。这是因为排序需要 O(n log n) 和 O(m log m)。</li><li><strong>空间复杂度</strong>：O(1)，只需要常量级别的额外空间。</li></ul><h5 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/lemonade-change/description/" >LeetCode #860 简单<i class="fas fa-external-link-alt"></i></a></p><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code>，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code>，否则返回 <code>false</code>。</p><p>示例 1：</p><blockquote><p>输入：bills &#x3D; [5, 5, 5, 10, 20]<br>输出：true<br>解释：<br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。</p></blockquote><p>示例 2：</p><blockquote><p>输入：bills &#x3D; [5, 5, 10, 10, 20]<br>输出：false<br>解释：<br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。</p></blockquote><p>遍历顾客给的钱，优先使用手中的大额钞票找零，从而保留小额钞票以应对后续的找零需求。</p><p>解题步骤：</p><ol><li><strong>初始化钱箱</strong>：使用两个变量 <code>five</code> 和 <code>ten</code> 来分别表示手中拥有的 5 美元和 10 美元的数量，初始值为 0。</li><li><strong>遍历账单</strong>：遍历顾客付的每一张账单。</li><li><strong>处理账单</strong>：<ul><li>如果顾客付的是 5 美元，直接收下。</li><li>如果顾客付的是 10 美元，需要找零，检查是否有足够的 5 美元找零，如果有则找零，否则无法找零，返回 false。</li><li>如果顾客付的是 20 美元，需要找零，优先使用 10 美元找零，然后再用 5 美元找零，如果都无法找零，则返回 false。</li></ul></li><li><strong>返回结果</strong>：遍历结束后，如果能够给每个顾客正确找零，则返回 true，否则返回 false。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lemonadeChange</span>(<span class="params">bills</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> five = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> ten = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> bill <span class="keyword">of</span> bills) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bill === <span class="number">5</span>) &#123;</span><br><span class="line">         <span class="comment">// 顾客付 5 美元，直接收下</span></span><br><span class="line">         five++</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bill === <span class="number">10</span>) &#123;</span><br><span class="line">         <span class="comment">// 顾客付 10 美元，尝试找零，优先使用 10 美元找零</span></span><br><span class="line">         <span class="keyword">if</span> (five === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 无法找零，返回 false</span></span><br><span class="line">         &#125;</span><br><span class="line">         five--</span><br><span class="line">         ten++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 顾客付 20 美元，尝试找零，优先使用 10 美元找零，再使用 5 美元找零</span></span><br><span class="line">         <span class="keyword">if</span> (ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ten--</span><br><span class="line">            five--</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            five -= <span class="number">3</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 无法找零，返回 false</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lemonadeChange</span>([<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>])) <span class="comment">// 输出：true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lemonadeChange</span>([<span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>])) <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是账单的数量，我们需要遍历一次账单数组。</li><li><strong>空间复杂度</strong>：O(1)，只需要常数级别的额外空间来存储 5 美元和 10 美元的数量。</li></ul><h5 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/jump-game/description/" >LeetCode #55 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个非负整数数组 <code>nums</code>，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [2, 3, 1, 1, 4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [3, 2, 1, 0, 4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0，所以永远不可能到达最后一个下标。</p></blockquote><p>从前往后遍历数组，维护当前能够到达的最远位置，如果在某一步能够到达或超过数组的最后一个位置，则返回 <code>true</code>。</p><p>解题步骤：</p><ol><li><strong>初始化</strong>：定义一个变量 <code>maxReach</code>，表示当前能够到达的最远位置，初始值为 <code>0</code>。</li><li><strong>遍历数组</strong>：从头到尾遍历数组的每个位置，检查当前位置是否能够到达。如果当前位置大于 <code>maxReach</code>，说明不能到达当前位置，返回 <code>false</code>。</li><li><strong>更新最远可达位置</strong>：如果当前位置在可达范围内，更新 <code>maxReach</code> 为 <code>max(maxReach, i + nums[i])</code>。</li><li><strong>检查是否可达</strong>：如果在遍历过程中，<code>maxReach</code> 大于或等于数组的最后一个下标，返回 <code>true</code>。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">canJump</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> maxReach = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果当前下标超过了能到达的最远位置</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; maxReach) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新能到达的最远位置</span></span><br><span class="line">      maxReach = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxReach, i + nums[i])</span><br><span class="line">      <span class="comment">// 如果能到达或超过最后一个下标</span></span><br><span class="line">      <span class="keyword">if</span> (maxReach &gt;= nums.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canJump</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>])) <span class="comment">// 输出：true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canJump</span>([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>])) <span class="comment">// 输出：false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canJump</span>([<span class="number">0</span>])) <span class="comment">// 输出：true (只有一个元素，已经在最后一个下标)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canJump</span>([<span class="number">2</span>, <span class="number">0</span>])) <span class="comment">// 输出：true (可以直接到达最后一个下标)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canJump</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])) <span class="comment">// 输出：true (每步都能跳到最后)</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>canJump</code> 函数</strong>：主函数，判断是否能够到达最后一个下标。</li><li>**初始化 <code>maxReach</code>**：定义变量 <code>maxReach</code> 表示当前能够到达的最远位置，初始值为 <code>0</code>。</li><li><strong>遍历数组</strong>：<ul><li>对于每个位置 <code>i</code>，检查是否超过了 <code>maxReach</code>。如果是，返回 <code>false</code>，表示不能到达该位置。</li><li>否则，更新 <code>maxReach</code> 为 <code>max(maxReach, i + nums[i])</code>，表示当前能够到达的最远位置。</li></ul></li><li><strong>检查终止条件</strong>：如果 <code>maxReach</code> 已经大于或等于数组的最后一个下标，返回 <code>true</code>。</li><li><strong>返回结果</strong>：遍历结束后，如果没有返回 <code>true</code>，则返回 <code>false</code>。</li></ol><ul><li><strong>时间复杂度</strong>：O(n)，因为我们需要遍历一次数组。</li><li><strong>空间复杂度</strong>：O(1)，只需要常量级别的额外空间。</li></ul><h5 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/non-overlapping-intervals/description/" >LeetCode #435 中等<i class="fas fa-external-link-alt"></i></a></p><p>给定一个区间的集合 <code>intervals</code>，其中 <code>intervals[i] = [starti, endi]</code> 。返回需要移除区间的最小数量，使剩余区间互不重叠。</p><p>示例 1:</p><blockquote><p>输入: intervals &#x3D; [[1, 2], [2, 3], [3, 4], [1, 3]]<br>输出：1<br>解释: 移除 [1, 3] 后，剩下的区间没有重叠。</p></blockquote><p>示例 2:</p><blockquote><p>输入: intervals &#x3D; [[1, 2], [1,2], [1,2]]<br>输出：2<br>解释: 你需要移除两个 [1, 2] 来使剩下的区间没有重叠。</p></blockquote><p>示例 3:</p><blockquote><p>输入: intervals &#x3D; [[1, 2], [2, 3]]<br>输出：0<br>解释：你不需要移除任何区间，因为它们已经是无重叠的了。</p></blockquote><p>先按照区间的结束时间排序，然后依次选择结束时间最早且不与前一个选择的区间重叠的区间。对于这个问题，我们要尽可能多地保留区间，从而使得需要移除的区间数量最小。</p><p>解题步骤：</p><ol><li><strong>排序</strong>：首先将区间按照结束时间 <code>end</code> 进行排序。这样可以保证每次选择的区间结束时间尽可能早，以便留出更多的空间给后面的区间。</li><li><strong>贪心选择</strong>：使用一个变量 <code>end</code> 来记录上一个选择的区间的结束时间。初始化 <code>end</code> 为负无穷大。</li><li><strong>遍历区间</strong>：依次遍历排序后的区间，如果当前区间的起始时间 <code>start</code> 大于等于 <code>end</code>，说明这个区间可以保留，同时更新 <code>end</code> 为当前区间的结束时间 <code>end</code>。否则，这个区间需要移除。</li><li><strong>统计结果</strong>：遍历结束后，计算需要移除的区间数量。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">intervals</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (intervals.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 按区间的结束时间进行排序</span></span><br><span class="line">   intervals.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] - b[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> end = -<span class="title class_">Infinity</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> [start, finish] <span class="keyword">of</span> intervals) &#123;</span><br><span class="line">      <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">         <span class="comment">// 当前区间可以保留，更新结束时间</span></span><br><span class="line">         end = finish</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 当前区间与上一个区间重叠，需要移除</span></span><br><span class="line">         count++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eraseOverlapIntervals</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>]])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eraseOverlapIntervals</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]])) <span class="comment">// 输出：2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eraseOverlapIntervals</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]])) <span class="comment">// 输出：0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eraseOverlapIntervals</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">5</span>]])) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eraseOverlapIntervals</span>([[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">6</span>]])) <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>eraseOverlapIntervals</code> 函数</strong>：主函数，计算需要移除的区间数量。</li><li><strong>排序</strong>：将区间按照结束时间进行排序，使得每次选择的区间结束时间尽可能早。</li><li><strong>初始化变量</strong>：<code>count</code> 用于记录需要移除的区间数量，<code>end</code> 初始化为负无穷大。</li><li><strong>遍历区间</strong>：<ul><li>如果当前区间的起始时间 <code>start</code> 大于等于 <code>end</code>，说明这个区间可以保留，并更新 <code>end</code> 为当前区间的结束时间 <code>finish</code>。</li><li>否则，这个区间与上一个区间重叠，需要移除，增加 <code>count</code> 计数器。</li></ul></li><li><strong>返回结果</strong>：遍历结束后，返回需要移除的区间数量 <code>count</code>。</li></ol><ul><li><strong>时间复杂度</strong>：O(n log n)，因为我们需要对区间进行排序。</li><li><strong>空间复杂度</strong>：O(1)，不需要额外的空间，除了用于存储输入的区间列表。</li></ul><h5 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/candy/description/" >LeetCode #135 困难<i class="fas fa-external-link-alt"></i></a></p><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。</p><p>示例 1：</p><blockquote><p>输入：ratings &#x3D; [1, 0, 2]<br>输出：5<br>解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</p></blockquote><p>示例 2：</p><blockquote><p>输入：ratings &#x3D; [1, 2, 2]<br>输出：4<br>解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。<br>第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</p></blockquote><p>先从左到右扫描数组，确保右边的评分更高的孩子获得更多糖果；再从右到左扫描数组，确保左边的评分更高的孩子获得更多糖果。</p><p>解题步骤：</p><ol><li><strong>初始化</strong>：创建一个数组 <code>candies</code>，初始化每个孩子的糖果数为 1，表示每个孩子至少有一个糖果。</li><li><strong>从左到右遍历</strong>：检查每个孩子与前一个孩子的评分，如果当前孩子的评分比前一个孩子高，则更新当前孩子的糖果数为 <code>candies[i-1] + 1</code>。</li><li><strong>从右到左遍历</strong>：检查每个孩子与后一个孩子的评分，如果当前孩子的评分比后一个孩子高且糖果数不大于后一个孩子，则更新当前孩子的糖果数为 <code>candies[i+1] + 1</code>。</li><li><strong>计算总糖果数</strong>：遍历 <code>candies</code> 数组，求和得到最少需要的糖果数。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">candy</span>(<span class="params">ratings</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> n = ratings.<span class="property">length</span></span><br><span class="line">   <span class="keyword">const</span> candies = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从左到右遍历，保证右边孩子评分高的糖果更多</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">         candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从右到左遍历，保证左边孩子评分高的糖果更多</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">         candies[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(candies[i], candies[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算总糖果数</span></span><br><span class="line">   <span class="keyword">return</span> candies.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, candy</span>) =&gt;</span> sum + candy, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">candy</span>([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])) <span class="comment">// 输出：5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">candy</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])) <span class="comment">// 输出：4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">candy</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])) <span class="comment">// 输出：7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">candy</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])) <span class="comment">// 输出：15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">candy</span>([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])) <span class="comment">// 输出：15</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>candy</code> 函数</strong>：主函数，计算最少需要的糖果数。</li><li><strong>初始化 <code>candies</code> 数组</strong>：每个孩子至少分配 1 个糖果。</li><li><strong>从左到右遍历</strong>：<ul><li>如果当前孩子的评分高于前一个孩子，则当前孩子的糖果数等于前一个孩子的糖果数加 1。</li></ul></li><li><strong>从右到左遍历</strong>：<ul><li>如果当前孩子的评分高于后一个孩子且糖果数不大于后一个孩子，则更新当前孩子的糖果数为 <code>candies[i + 1] + 1</code>。</li></ul></li><li><strong>计算总糖果数</strong>：通过遍历 <code>candies</code> 数组求和得到最少需要的糖果数。</li></ol><ul><li><strong>时间复杂度</strong>：O(n)，因为我们需要遍历两次数组，每次遍历的时间复杂度都是 O(n)。</li><li><strong>空间复杂度</strong>：O(n)，因为我们需要额外的数组 <code>candies</code> 来存储每个孩子的糖果数。</li></ul><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>回溯算法是一种通过逐步构建解决方案的方法，当遇到某一步无法继续前进时，回溯算法会回退到上一步，尝试其他的选择，直到找到问题的解决方案或确定无解。回溯算法通常通过深度优先搜索的方式实现。</p><h4 id="基本步骤-3"><a href="#基本步骤-3" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol><li><strong>选择决策树</strong>：将问题抽象成一个决策树，每个节点代表一个决策点。</li><li><strong>深度优先搜索</strong>：从根节点开始，采用深度优先搜索的方式探索决策树的所有分支。</li><li><strong>做出选择</strong>：在每个节点处，根据问题的限制条件，做出一个选择。</li><li><strong>检查约束条件</strong>：检查当前选择是否满足问题的约束条件，如果满足则继续探索，否则回溯到上一步。</li><li><strong>标记路径</strong>：在探索过程中，记录已经探索过的路径，避免重复探索。</li><li><strong>撤销选择</strong>：在回溯时，撤销当前节点的选择，回到上一层继续探索其他分支。</li><li><strong>判断终止条件</strong>：当到达叶子节点或者无法继续探索时，判断是否找到了问题的解决方案。</li></ol><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>回溯算法通常用于以下几类问题：</p><ul><li><strong>组合问题</strong>：如组合总和、组合总和 II 等问题。</li><li><strong>排列问题</strong>：如全排列、字符串的全排列等问题。</li><li><strong>搜索问题</strong>：如解数独、N 皇后问题等。</li><li><strong>子集问题</strong>：如子集、子集 II 等问题。</li></ul><h4 id="回溯算法的应用"><a href="#回溯算法的应用" class="headerlink" title="回溯算法的应用"></a>回溯算法的应用</h4><h5 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/permutations/description/" >LeetCode #46 中等<i class="fas fa-external-link-alt"></i></a></p><p>给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列。你可以按任意顺序返回答案。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [1, 2, 3]<br>输出：[[1, 2, 3], [1, 3, 2], [2, 1 ,3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [0, 1]<br>输出：[[0, 1], [1, 0]]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [1]<br>输出：[[1]]</p></blockquote><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数互不相同</li></ul><p>解题步骤：</p><ol><li><strong>初始化结果集</strong>：创建一个结果数组 <code>result</code> 来存储所有的排列。</li><li><strong>回溯函数</strong>：定义一个回溯函数 <code>backtrack</code>，参数为当前路径 <code>path</code> 和剩余可选择的数字 <code>choices</code>。</li><li><strong>终止条件</strong>：当路径长度等于输入数组长度时，表明我们找到了一种排列，将其加入结果集。</li><li><strong>选择和探索</strong>：遍历剩余可选择的数字，将每个数字加入当前路径，并递归调用回溯函数，传递更新后的路径和剩余可选择的数字。</li><li><strong>回溯</strong>：在递归调用结束后，撤销上一步选择，进行下一轮选择和探索。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">permute</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> result = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">         result.<span class="title function_">push</span>([...path])</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; choices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">         path.<span class="title function_">push</span>(choices[i])</span><br><span class="line">         <span class="title function_">backtrack</span>(path, choices.<span class="title function_">slice</span>(<span class="number">0</span>, i).<span class="title function_">concat</span>(choices.<span class="title function_">slice</span>(i + <span class="number">1</span>)))</span><br><span class="line">         path.<span class="title function_">pop</span>()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="title function_">backtrack</span>([], nums)</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">0</span>, <span class="number">1</span>])) <span class="comment">// 输出：[[0,1],[1,0]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">1</span>])) <span class="comment">// 输出：[[1]]</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>permute</code> 函数</strong>：主函数，接收输入数组 <code>nums</code>，返回所有的排列。</li><li><strong>初始化结果集</strong>：创建一个空数组 <code>result</code> 来存储所有的排列结果。</li><li><strong><code>backtrack</code> 函数</strong>：递归函数，构建排列。参数 <code>path</code> 表示当前路径，<code>choices</code> 表示当前剩余的可选择数字。</li><li><strong>终止条件</strong>：当路径长度等于输入数组长度时，将当前路径加入结果集。</li><li><strong>选择和探索</strong>：遍历剩余可选择的数字，将每个数字加入当前路径，递归调用 <code>backtrack</code> 函数，并传递更新后的路径和剩余可选择的数字。</li><li><strong>回溯</strong>：在递归调用结束后，撤销上一步选择，通过 <code>path.pop()</code> 将最后一个元素移除，进行下一轮选择和探索。</li></ol><ul><li><strong>时间复杂度</strong>：O(n * n!)，其中 n 是输入数组的长度。总共有 n! 种排列，每种排列需要 O(n) 的时间来构建。</li><li><strong>空间复杂度</strong>：O(n)，用于存储递归调用栈和临时路径。</li></ul><h5 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/subsets/description/" >LeetCode 78 中等<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 <code>nums</code>，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。</p><p>解集不能包含重复的子集。你可以按任意顺序返回解集。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [1, 2, 3]<br>输出：[[], [1], [2], [1,2], [3], [1, 3], [2, 3], [1, 2, 3]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [0]<br>输出：[[], [0]]</p></blockquote><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素互不相同</li></ul><p>解题步骤：</p><ol><li><strong>初始化结果集</strong>：创建一个结果数组 <code>result</code> 来存储所有的子集。</li><li><strong>回溯函数</strong>：定义一个回溯函数 <code>backtrack</code>，参数为当前路径 <code>path</code> 和起始索引 <code>start</code>。</li><li><strong>添加当前路径到结果集</strong>：将当前路径 <code>path</code> 的拷贝加入结果集 <code>result</code>。</li><li><strong>选择和探索</strong>：从起始索引开始遍历 <code>nums</code> 数组，将每个数字加入当前路径，并递归调用回溯函数，传递更新后的路径和新的起始索引。</li><li><strong>回溯</strong>：在递归调用结束后，撤销上一步选择，进行下一轮选择和探索。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">subsets</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> result = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">path, start</span>) &#123;</span><br><span class="line">      <span class="comment">// 将当前路径加入结果集</span></span><br><span class="line">      result.<span class="title function_">push</span>([...path])</span><br><span class="line">      <span class="comment">// 从当前索引开始遍历 nums 数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">         <span class="comment">// 将当前数字加入路径</span></span><br><span class="line">         path.<span class="title function_">push</span>(nums[i])</span><br><span class="line">         <span class="comment">// 递归调用回溯函数，传递更新后的路径和新的起始索引</span></span><br><span class="line">         <span class="title function_">backtrack</span>(path, i + <span class="number">1</span>)</span><br><span class="line">         <span class="comment">// 回溯，撤销上一步选择</span></span><br><span class="line">         path.<span class="title function_">pop</span>()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化回溯</span></span><br><span class="line">   <span class="title function_">backtrack</span>([], <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subsets</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 输出：[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subsets</span>([<span class="number">0</span>])) <span class="comment">// 输出：[[], [0]]</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>subsets</code> 函数</strong>：主函数，接收输入数组 <code>nums</code>，返回所有的子集。</li><li><strong>初始化结果集</strong>：创建一个空数组 <code>result</code> 来存储所有的子集结果。</li><li><strong><code>backtrack</code> 函数</strong>：递归函数，构建子集。参数 <code>path</code> 表示当前路径，<code>start</code> 表示起始索引。</li><li><strong>添加当前路径到结果集</strong>：将当前路径 <code>path</code> 的拷贝加入结果集 <code>result</code>。</li><li><strong>选择和探索</strong>：从起始索引开始遍历 <code>nums</code> 数组，将每个数字加入当前路径 <code>path</code>，递归调用 <code>backtrack</code> 函数，并传递更新后的路径和新的起始索引 <code>i + 1</code>。</li><li><strong>回溯</strong>：在递归调用结束后，撤销上一步选择，通过 <code>path.pop()</code> 将最后一个元素移除，进行下一轮选择和探索。</li></ol><ul><li><strong>时间复杂度</strong>：O(n * 2^n)，其中 n 是输入数组的长度。总共有 2^n 个子集，每个子集的平均长度为 n&#x2F;2。</li><li><strong>空间复杂度</strong>：O(n)，用于存储递归调用栈和临时路径。</li></ul><h5 id="单词拆分-II"><a href="#单词拆分-II" class="headerlink" title="单词拆分 II"></a>单词拆分 II</h5><p>题目来源：<a class="link"   href="https://leetcode.cn/problems/word-break-ii/description/" >LeetCode #140 困难<i class="fas fa-external-link-alt"></i></a></p><p>给定一个字符串 <code>s</code> 和一个字符串字典 <code>wordDict</code>，在字符串 <code>s</code> 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序返回所有这些可能的句子。</p><p>注意：词典中的同一个单词可能在分段中被重复使用多次。</p><p>示例 1：</p><blockquote><p>输入：s &#x3D; “catsanddog”, wordDict &#x3D; [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出：[“cats and dog”, “cat sand dog”]</p></blockquote><p>示例 2：</p><blockquote><p>输入：s &#x3D; “pineapplepenapple”, wordDict &#x3D; [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出：[“pine apple pen apple”, “pineapple pen apple”, “pine applepen apple”]<br>解释：注意你可以重复使用字典中的单词。</p></blockquote><p>示例 3：</p><blockquote><p>输入：s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出：[]</p></blockquote><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li><li><code>wordDict</code> 中所有字符串都不同</li></ul><p>要解决这个问题，我们可以使用回溯算法结合动态规划进行优化。具体来说，我们需要递归地尝试在字符串 <code>s</code> 中插入空格来构成单词，同时使用缓存来存储已经计算过的结果，避免重复计算。</p><p>解题步骤：</p><ol><li><strong>定义缓存</strong>：使用一个对象 <code>memo</code> 来存储已经计算过的子问题的结果。</li><li><strong>定义回溯函数</strong>：递归函数 <code>backtrack</code>，参数为当前子字符串 <code>s</code>。</li><li><strong>递归终止条件</strong>：如果当前子字符串 <code>s</code> 在缓存中，直接返回缓存中的结果；如果 <code>s</code> 为空字符串，返回包含一个空字符串的数组。</li><li><strong>遍历匹配</strong>：遍历词典中的单词，如果当前子字符串 <code>s</code> 以该单词开头，则递归处理剩余部分的字符串，并将结果组合起来。</li><li><strong>更新缓存</strong>：将当前子字符串的结果存入缓存中，并返回该结果。</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wordBreak</span>(<span class="params">s, wordDict</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> wordSet = <span class="keyword">new</span> <span class="title class_">Set</span>(wordDict)</span><br><span class="line">   <span class="keyword">const</span> memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">s</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果当前子字符串已经在缓存中，直接返回缓存的结果</span></span><br><span class="line">      <span class="keyword">if</span> (memo[s] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> memo[s]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果子字符串为空，返回包含一个空字符串的数组</span></span><br><span class="line">      <span class="keyword">if</span> (s === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> result = []</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历词典中的每个单词</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> wordSet) &#123;</span><br><span class="line">         <span class="keyword">if</span> (s.<span class="title function_">startsWith</span>(word)) &#123;</span><br><span class="line">            <span class="keyword">const</span> subResult = <span class="title function_">backtrack</span>(s.<span class="title function_">slice</span>(word.<span class="property">length</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> sub <span class="keyword">of</span> subResult) &#123;</span><br><span class="line">               result.<span class="title function_">push</span>(word + (sub === <span class="string">&#x27;&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27; &#x27;</span>) + sub)</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将当前子字符串的结果存入缓存</span></span><br><span class="line">      memo[s] = result</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">backtrack</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">wordBreak</span>(<span class="string">&#x27;catsanddog&#x27;</span>, [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;cats&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;sand&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>]))</span><br><span class="line"><span class="comment">// 输出：[&quot;cats and dog&quot;, &quot;cat sand dog&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">wordBreak</span>(<span class="string">&#x27;pineapplepenapple&#x27;</span>, [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pen&#x27;</span>, <span class="string">&#x27;applepen&#x27;</span>, <span class="string">&#x27;pine&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>]))</span><br><span class="line"><span class="comment">// 输出：[&quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">wordBreak</span>(<span class="string">&#x27;catsandog&#x27;</span>, [<span class="string">&#x27;cats&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;sand&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]))</span><br><span class="line"><span class="comment">// 输出：[]</span></span><br></pre></td></tr></table></figure><ol><li><strong><code>wordBreak</code> 函数</strong>：主函数，接收字符串 <code>s</code> 和词典 <code>wordDict</code>，返回所有可能的句子。</li><li><strong>初始化</strong>：将词典转化为集合 <code>wordSet</code>，用于快速查找；定义缓存 <code>memo</code>。</li><li><strong><code>backtrack</code> 函数</strong>：递归函数，处理当前子字符串 <code>s</code>，返回其所有可能的句子组合。</li><li><strong>缓存查询</strong>：如果当前子字符串 <code>s</code> 在缓存中，直接返回缓存中的结果。</li><li><strong>递归终止条件</strong>：如果子字符串 <code>s</code> 为空，返回包含一个空字符串的数组。</li><li><strong>遍历词典</strong>：对于每个单词，如果当前子字符串 <code>s</code> 以该单词开头，则递归处理剩余部分的字符串 <code>s.slice(word.length)</code>。</li><li><strong>组合结果</strong>：将当前单词和递归结果组合成新的句子，并添加到结果集中。</li><li><strong>更新缓存</strong>：将当前子字符串 <code>s</code> 的结果存入缓存 <code>memo</code>，避免重复计算。</li><li><strong>返回结果</strong>：主函数调用 <code>backtrack</code> 函数，返回最终结果。</li></ol><ul><li><strong>时间复杂度</strong>：最坏情况下为 O(n^2 * k)，其中 n 是字符串 <code>s</code> 的长度，k 是词典 <code>wordDict</code> 的大小。每个子字符串的计算会涉及到对词典的遍历，并且需要组合结果。</li><li><strong>空间复杂度</strong>：O(n^2)，用于缓存子字符串的结果和存储递归栈。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢大家看到最后，本文篇幅较长，难免会有错误，还望同学们多指正。看完本文后还没能理解透算法实现原理的同学，也不用灰心，掌握算法不是一朝半夕的事，勤加练习才能突破。</p><p>另外，作者组建了氛围特别好的前端交流群 &amp; 自由程序猿交流群，欢迎同学们一起来交流吐槽。由于群人数较多，需要添加作者才能邀请进群。</p><p><img                         lazyload                       alt="image"                       data-src="/images/fp/fp-slogan.webp"                        alt="自由程序猿"                 ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;提及算法，可能会有很多前端同学觉得这是一个距离自己日常工作较远的领域，认为算法并没有那么重要。事实上，这种看法是片面的，算法不仅仅是计算机科</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://xpoet.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号又双叒叕改名了</title>
    <link href="https://xpoet.cn/post/1c732a9f7dca/"/>
    <id>https://xpoet.cn/post/1c732a9f7dca/</id>
    <published>2024-02-28T12:00:00.000Z</published>
    <updated>2024-02-28T14:33:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>实在惭愧，这篇本应在两个月前就该写好的文章，由于我太懒，重度拖延，时至今日才姗姗来迟。</p><span id="more"></span><p>微信公众号又双叒叕改名了，特意查看详情记录，自 2020 年 3 月 6 日注册以来，文章没写几篇，改名次数倒是不少，上一个名称《前端鼓励师》应该是使用最长时间的一个，大概持续了 3 年，貌似每一次的改名都与当时自己的职业规划、副业设想以及迫不及待想成为行业大牛的冲动息息相关，这一次的改名自然也不例外。</p><p>一转眼，大学毕业后工作即将满 7 年，打了这么多年工，当了这么多年的社畜，眼看着自己的雄心壮志被一点一点吞噬掉，身上的棱角被一点一点磨平，深深感受到作为社会人的生活是多么不容易，真心觉得学生时代是最幸福的时光。</p><p>我和大多数人一样，都是讨厌工作的，但为了生存又不得不工作。程序员这种职业，工作通常占据了生活中很大一部分时间，比起其他行业，更难于拥有属于自己真正的自由时间。</p><p>如果能找到一份自己喜欢、挣得多、离家近，并且能从中收获非常多成就感和快乐的工作，当然是最好的，可惜大部分人都没有这样的幸运。</p><p>在成为程序员之前，我热衷于写代码，跟大多数程序员一样，曾经梦想用代码改变世界，单纯地写代码就能够带给我带来很大的满足感，就在刚工作的那几年，我也极其享受写代码的感觉。</p><p>然而，最近很长一段时间以来，我的情绪越来越不稳定，总是莫名其妙地发脾气，总感觉越来越疲惫，越来越焦虑，工作中纯粹写代码的时间越来越少，或许是因为当前的工作收入不太稳定，或许是这几年在跳槽和被裁员中患得患失，又或许是受到社会经济持续低迷的影响，我想更多可能是因为结婚后有了两个娃，在娃现在还比较小的时候自己却不能天天陪伴着，有了家庭的责任和牵绊，变得跟学生时代一样常常期盼着周末和假期，内心渴望更多自由时间。</p><p>如果可以不仅仅依赖工作赚钱，或者说如果不止于主动工作这一份的收入来源，可能就会拥有更多的自由时间，可以去做自己喜欢的事情。</p><p>工作之前的梦想比天还高，工作之后却不得不在现实面前低头，愈发愈觉得理想和现实之间的巨大鸿沟不是仅仅靠努力和坚持就能跨越的，绝大多数人终其一生也不能达到自己想要的高度，或许追求拥有健康、自由且平凡的生活才是最实在和可靠的。</p><p>此次将公众号改名为《自由程序猿》，正是自己饱受职场摧残后做出的转变，也是自己对当前及未来的职业生涯做出的规划。我无比热爱代码，程序员是我终身的标签；我无比渴望自由，为了拥有真正的自由，自此开始，无论是工作中还是工作外，探索程序员的自由之路将是我长期坚持的事情，甚至是未来五年、十年、二十年、三十年。</p><p>这个公众号自注册以来约 1000 人关注，深感惭愧，之前未能够给各位小伙伴持续分享有用的内容，今后也许还会一样，作者几乎不可能高产更文，依然是不定期分享我在探索程序员实现自由之路的各种尝试和实践，包括但不限于分享前端技术、后端技术、数据结构与算法、AIGC、面试经验、职场感悟、副业创业等等。各位小伙伴如若认可，请继续关注；若不喜欢，随时取关，随心就好。</p><p>如果你和我一样有着类似的经历和想法，也渴望成为一个自由的人，也想去探索实现时间自由、空间自由，甚至财富自由，那么希望咱们能交个朋友（添加作者微信时请注明来意，作者从不推销，也极少发朋友圈），多个朋友多条路，但有想法随时交流。</p><p>此刻思绪万千，脑海中点滴记忆如碎片一般混杂纷纭。</p><p><img                         lazyload                       alt="image"                       data-src="/images/fp/fp-slogan.webp"                        alt="fp"                 ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实在惭愧，这篇本应在两个月前就该写好的文章，由于我太懒，重度拖延，时至今日才姗姗来迟。&lt;/p&gt;</summary>
    
    
    
    <category term="公众号" scheme="https://xpoet.cn/categories/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
    
    <category term="公众号" scheme="https://xpoet.cn/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
    <category term="自由程序猿" scheme="https://xpoet.cn/tags/%E8%87%AA%E7%94%B1%E7%A8%8B%E5%BA%8F%E7%8C%BF/"/>
    
  </entry>
  
  <entry>
    <title>赞赏作者 Admire Author 💕</title>
    <link href="https://xpoet.cn/post/0054d541d734/"/>
    <id>https://xpoet.cn/post/0054d541d734/</id>
    <published>2023-11-24T07:52:41.000Z</published>
    <updated>2024-02-29T09:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>开源项目，维护不易，感谢您的认可和支持。</p><p>您可以使用微信扫描下图，对作者进行一定金额的赞赏支持。</p><p>同时，您也可以添加作者微信，获得相应的技术支持。</p><table><thead><tr><th align="center">赞赏码</th><th align="center">作者微信二维码</th></tr></thead><tbody><tr><td align="center"><img   width="300"                         lazyload                       alt="image"                       data-src="/images/admire-code-wechat.webp"                                         ></td><td align="center"><img   width="300"                         lazyload                       alt="image"                       data-src="/images/wechat-qrcode.png"                                         ></td></tr></tbody></table><blockquote><p>添加微信时请注明来意，如需进群，请直接写明想进哪个群。<br>目前有：<code>前端技术交流群</code>、<code>Keep 主题交流群</code>、<code>自由程序猿交流群</code>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开源项目，维护不易，感谢您的认可和支持。&lt;/p&gt;
&lt;p&gt;您可以使用微信扫描下图，对作者进行一定金额的赞赏支持。&lt;/p&gt;
&lt;p&gt;同时，您也可以添加作者微信，获得相应的技术支持。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;赞赏码&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript 的并发模型和事件循环</title>
    <link href="https://xpoet.cn/post/cbe58a2205e2/"/>
    <id>https://xpoet.cn/post/cbe58a2205e2/</id>
    <published>2022-05-15T08:07:24.000Z</published>
    <updated>2024-05-15T08:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其他语言中的模型截然不同，比如 C 和 Java。</p><h2 id="运行时概念"><a href="#运行时概念" class="headerlink" title="运行时概念"></a>运行时概念</h2><p>现代 JavaScript 引擎实现并着重优化了以下描述的这些语义。</p><h3 id="可视化描述"><a href="#可视化描述" class="headerlink" title="可视化描述"></a>可视化描述</h3><p><img                         lazyload                       alt="image"                       data-src="/images/posts/front-end/img-1.png"                        alt="img"                 ></p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>函数调用形成了一个由若干帧组成的栈。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b + <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">foo</span>(x * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bar</span>(<span class="number">7</span>)); <span class="comment">// 返回 42</span></span><br></pre></td></tr></table></figure><p>当调用 <code>bar</code> 时，第一个帧被创建并压入栈中，帧中包含了 <code>bar</code> 的参数和局部变量。当 <code>bar</code> 调用 <code>foo</code> 时，第二个帧被创建并被压入栈中，放在第一个帧之上，帧中包含 <code>foo</code> 的参数和局部变量。当 <code>foo</code> 执行完毕然后返回时，第二个帧就被弹出栈（剩下 <code>bar</code> 函数的调用帧）。当 <code>bar</code> 也执行完毕然后返回时，第一个帧也被弹出，栈就被清空了。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。</p><p>在事件循环期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。</p><p>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>之所以称之为事件循环，是因为它经常按照类似如下的方式来被实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.<span class="title function_">waitForMessage</span>()) &#123;</span><br><span class="line">  queue.<span class="title function_">processNextMessage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>queue.waitForMessage()</code> 会同步地等待消息到达 (如果当前没有任何消息等待被处理)。</p><h3 id="“执行至完成”"><a href="#“执行至完成”" class="headerlink" title="“执行至完成”"></a>“执行至完成”</h3><p>每一个消息完整地执行后，其他消息才会被执行。这为程序的分析提供了一些优秀的特性，包括：当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。这与 C 语言不同，例如，如果函数在线程中运行，它可能在任何位置被终止，然后在另一个线程中运行其他代码。</p><p>这个模型的一个缺点在于当一个消息需要太长时间才能处理完毕时，Web 应用程序就无法处理与用户的交互，例如点击或滚动。为了缓解这个问题，浏览器一般会弹出一个“这个脚本运行时间过长”的对话框。一个良好的习惯是缩短单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。</p><h3 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a>添加消息</h3><p>在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。</p><p>函数 <code>setTimeout</code> 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其他消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其他消息，<code>setTimeout</code> 消息必须等待其他消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。</p><p>下面的例子演示了这个概念（<code>setTimeout</code> 并不会在计时器到期之后直接执行）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getSeconds</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 输出 &quot;2&quot;，表示回调函数并没有在 500 毫秒之后立即执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Ran after &quot;</span> + (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getSeconds</span>() - s) + <span class="string">&quot; seconds&quot;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getSeconds</span>() - s &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Good, looped for 2 seconds&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零延迟"><a href="#零延迟" class="headerlink" title="零延迟"></a>零延迟</h3><p>零延迟并不意味着回调会立即执行。以 0 为第二参数调用 <code>setTimeout</code> 并不表示在 0 毫秒后就立即调用回调函数。</p><p>其等待的时间取决于队列里待处理的消息数量。在下面的例子中，<code>&quot;这是一条消息&quot;</code> 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。</p><p>基本上，<code>setTimeout</code> 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">cb</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是来自第一个回调的消息&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是一条消息&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">cb1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是来自第二个回调的消息&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是结束&quot;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;这是开始&quot;</span></span><br><span class="line"><span class="comment">// &quot;这是一条消息&quot;</span></span><br><span class="line"><span class="comment">// &quot;这是结束&quot;</span></span><br><span class="line"><span class="comment">// &quot;这是来自第一个回调的消息&quot;</span></span><br><span class="line"><span class="comment">// &quot;这是来自第二个回调的消息&quot;</span></span><br></pre></td></tr></table></figure><h3 id="多个运行时互相通信"><a href="#多个运行时互相通信" class="headerlink" title="多个运行时互相通信"></a>多个运行时互相通信</h3><p>一个 web worker 或者一个跨域的 <code>iframe</code> 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 <code>postMessage</code> 方法进行通信。如果另一个运行时侦听 <code>message</code> 事件，则此方法会向该运行时添加消息。</p><h2 id="永不阻塞"><a href="#永不阻塞" class="headerlink" title="永不阻塞"></a>永不阻塞</h2><p>JavaScript 的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。处理 I&#x2F;O 通常通过事件和回调来执行，所以当一个应用正等待一个 IndexedDB 查询返回或者一个 XHR 请求返回时，它仍然可以处理其他事情，比如用户输入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其他语言中的模型截然不同，比如 C 和 Java。&lt;/p&gt;
&lt;h2 id=&quot;运行时概念&quot;&gt;&lt;a href=&quot;#运行时概念&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="前端" scheme="https://xpoet.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>常考的 JavaScript 手写题</title>
    <link href="https://xpoet.cn/post/9b7700b386a6/"/>
    <id>https://xpoet.cn/post/9b7700b386a6/</id>
    <published>2022-01-06T12:59:55.000Z</published>
    <updated>2024-03-25T08:31:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在的前端招聘圈，对前端程序员的能力要求真的是越来越高了（<del>内卷真的太厉害了</del>），出去找工作面试，哪怕是家小公司，大概率都会考一些 JS 手写题，你不会但别人会，自然就被卷死了。</p><p>其实，对一个前端工程师来说，JS 本就重中之重，我们要掌握的可不仅仅是这些手写题。  </p><p>当然，你不会这些手写题也不能代表你的 JS 编程能力不好，我觉得那是因为你不熟悉而已。</p><span id="more"></span><p>现在就跟着作者来一步一步学习，彻底搞懂这些常考的 JS 手写题，无论是在业务开发还是求职面试中都很实用。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JS-%E6%89%8B%E5%86%99%E9%A2%98/image.79wc6n86vxw0.webp"                        alt="image"                 ></p><p>截止目前，市面上超过 98% 的浏览器支持 ES6，ES6 (ECMAScript 2015) 都已经是 2015 年的标准了，所以这些手写题里面能使用 ES6 实现的均采用 ES6 实现。以下的每一道手写题，都经过作者反复检验，也配备了测试代码，小伙伴放心大胆学起来。</p><p>如发现错误或者有更好的实现方式，欢迎大家指正。</p><blockquote><p>代码仓库：<a class="link"   href="https://github.com/XPoet/handwriting-js" >https://github.com/XPoet/handwriting-js<i class="fas fa-external-link-alt"></i></a></p></blockquote><h3 id="手写类型判断"><a href="#手写类型判断" class="headerlink" title="手写类型判断"></a>手写类型判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myTypeOf</span> = (<span class="params">data</span>) =&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(data).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>).<span class="title function_">toLowerCase</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTypeOf</span>(<span class="number">1</span>)) <span class="comment">//--&gt; number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTypeOf</span>(<span class="string">&#x27;1&#x27;</span>)) <span class="comment">//--&gt; string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTypeOf</span>(<span class="literal">true</span>)) <span class="comment">//--&gt; boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTypeOf</span>([])) <span class="comment">//--&gt; array</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTypeOf</span>(&#123;&#125;)) <span class="comment">//--&gt; object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTypeOf</span>(<span class="regexp">/^/</span>)) <span class="comment">//--&gt; regexp</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTypeOf</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())) <span class="comment">//--&gt; date</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTypeOf</span>(<span class="title class_">Math</span>)) <span class="comment">//--&gt; math</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTypeOf</span>(<span class="function">() =&gt;</span> &#123;&#125;)) <span class="comment">//--&gt; function</span></span><br></pre></td></tr></table></figure><h3 id="手写数组去重"><a href="#手写数组去重" class="headerlink" title="手写数组去重"></a>手写数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myUnique</span> = array =&gt; [...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myUnique</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">//--&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="手写-Ajax-的-GET-方法"><a href="#手写-Ajax-的-GET-方法" class="headerlink" title="手写 Ajax 的 GET 方法"></a>手写 Ajax 的 GET 方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myAjaxGet</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 Promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&#x27;json&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 Promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="title function_">myAjaxGet</span>(<span class="string">&#x27;https://api.github.com/users/XPoet&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res) <span class="comment">//--&gt; &#123;...&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="手写函数节流"><a href="#手写函数节流" class="headerlink" title="手写函数节流"></a>手写函数节流</h3><p>定义：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p><p>使用场景：窗口 resize、scroll、输入框 input、频繁点击等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 需要执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 间隔时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, delay = <span class="number">1000</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上一次执行 fn 的时间</span></span><br><span class="line">  <span class="keyword">let</span> prevTime = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒 ms</span></span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="comment">// 将当前时间和上一次执行函数的时间进行对比</span></span><br><span class="line">    <span class="comment">// 大于间隔时间就把 prevTime 设置为当前时间并执行函数 fn</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - prevTime &gt; delay) &#123;</span><br><span class="line">      prevTime = nowTime</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> testFn = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数节流测试 - fn 执行了&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器每 100 毫秒执行一次 testFn 函数，但是只有间隔时间差大于 1000 毫秒时才会执行 fn</span></span><br><span class="line"><span class="built_in">setInterval</span>(testFn, <span class="number">100</span>) <span class="comment">//--&gt; 函数节流测试 - fn 执行了</span></span><br></pre></td></tr></table></figure><h3 id="手写函数防抖"><a href="#手写函数防抖" class="headerlink" title="手写函数防抖"></a>手写函数防抖</h3><p>定义：在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。<br>使用场景：搜索框输入搜索、点击提交等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(ctx, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> testFn = <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数防抖测试 - fn 执行了&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器每 1000 毫秒执行一次 testFn 函数，等待时间未大于 2000 毫秒，所以 fn 永远不会执行</span></span><br><span class="line"><span class="built_in">setInterval</span>(testFn, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器每 3000 毫秒执行一次 testFn 函数，等待时间大于 2000 毫秒，所以 fn 会隔 3000 执行一次</span></span><br><span class="line"><span class="built_in">setInterval</span>(testFn, <span class="number">3000</span>) <span class="comment">//--&gt; 函数防抖测试 - fn 执行了</span></span><br></pre></td></tr></table></figure><h3 id="手写深浅拷贝"><a href="#手写深浅拷贝" class="headerlink" title="手写深浅拷贝"></a>手写深浅拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象类型的数据</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// object 如果是数组类型就新建一个空数组，否则新建空对象</span></span><br><span class="line">  <span class="keyword">const</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，进行属性拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title function_">shallowCopy</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2) <span class="comment">//--&gt; &#123; x: 1, y: 2, z: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="title function_">shallowCopy</span>(arr1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2) <span class="comment">//--&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象类型的数据</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// object 如果是数组类型就新建一个空数组，否则新建空对象</span></span><br><span class="line">  <span class="keyword">const</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// object[key] 如果是对象类型，则使用递归继续遍历拷贝属性</span></span><br><span class="line">      newObject[key] = <span class="keyword">typeof</span> object[key] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepCopy</span>(object[key]) : object[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: &#123; <span class="attr">z</span>: <span class="number">3</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title function_">deepCopy</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2) <span class="comment">//--&gt; &#123; x: 1, y: &#123; z: 3 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="title function_">deepCopy</span>(arr1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2) <span class="comment">//--&gt; [1, [2, 3]]</span></span><br></pre></td></tr></table></figure><h3 id="手写-call、apply-和-bind-函数"><a href="#手写-call、apply-和-bind-函数" class="headerlink" title="手写 call、apply 和 bind 函数"></a>手写 call、apply 和 bind 函数</h3><p>在 JavaScript 中，<code>call</code>、<code>apply</code> 和 <code>bind</code> 是 <code>Function</code> 对象自带的三个方法，这三个方法的主要作用是改变函数中的 <code>this</code> 指向。</p><p>共同点：</p><ul><li><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都是用来改变函数的 <code>this</code> 对象指向。</li><li><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者第一个参数都是 <code>this</code> 要指向的对象，也就是想指定的上下文。（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context），这就是 <code>this</code> 关键字的值。）</li><li><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都可以利用后续参数传参。</li></ul><p>区别：</p><ul><li><code>bind</code> 是返回对应函数，便于稍后调用。</li><li><code>apply</code> 、<code>call</code> 则是立即调用。</li></ul><p><code>call()</code> 和 <code>apply()</code> 的作用是一样的，都是用于改变 <code>this</code> 的指向，区别在于 <code>call</code> 接受多个参数，而 <code>apply</code> 接受的是一个数组。</p><p>第一个参数的取值有以下 4 种情况：</p><ol><li>不传，或者传 <code>null</code>、<code>undefined</code>，函数中的 <code>this</code> 指向 <code>window</code> 对象。</li><li>传递另一个函数的函数名，函数中的 <code>this</code> 指向这个函数的引用。</li><li>传递字符串、数值或布尔类型等基础类型，函数中的 <code>this</code> 指向其对应的包装对象，如 <code>String</code>、<code>Number</code>、<code>Boolean</code>。</li><li>传递一个对象，函数中的 <code>this</code> 指向这个对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">call</span>() <span class="comment">//--&gt; window</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">//--&gt; window</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">//window</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="number">1</span>) <span class="comment">//--&gt; Number &#123;1&#125;</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">//--&gt; String &#123;&#x27;&#x27;&#125;</span></span><br><span class="line">a.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">//--&gt; Boolean &#123;true&#125;</span></span><br><span class="line">a.<span class="title function_">call</span>(b) <span class="comment">//--&gt; function b()&#123;&#125;</span></span><br><span class="line">a.<span class="title function_">call</span>(c) <span class="comment">//--&gt; &#123;x: 1&#125;</span></span><br></pre></td></tr></table></figure><h4 id="手写-call"><a href="#手写-call" class="headerlink" title="手写 call"></a>手写 call</h4><p>call 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 <code>call</code> 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 <code>window</code>。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">ctx, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Type Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 ctx 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  ctx = ctx || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  ctx.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  <span class="keyword">const</span> result = ctx.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> ctx.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">test</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a, b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">test</span>.<span class="title function_">myCall</span>(obj, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//--&gt; &#123;test: ƒ, fn: ƒ&#125; 4 5</span></span><br></pre></td></tr></table></figure><h4 id="手写-apply"><a href="#手写-apply" class="headerlink" title="手写 apply"></a>手写 apply</h4><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 <code>call</code> 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 <code>window</code>。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Type Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 ctx 是否存在，如果未传入则为 window</span></span><br><span class="line">  ctx = ctx || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  ctx.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = ctx.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = ctx.<span class="title function_">fn</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> ctx.<span class="property">fn</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">test</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a, b, c)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">test</span>.<span class="title function_">myApply</span>(obj, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]) <span class="comment">//--&gt; &#123;test: ƒ, fn: ƒ&#125; 4 5 6</span></span><br></pre></td></tr></table></figure><h4 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h4><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 <code>call</code> 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回。</li><li>函数内部使用 <code>apply</code> 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 <code>this</code> 给 <code>apply</code> 调用，其余情况都传入指定的上下文对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">ctx, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Type Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : ctx, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">test</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">test</span>.<span class="title function_">myBind</span>(obj, <span class="number">4</span>, <span class="number">5</span>)() <span class="comment">//--&gt; &#123;test: ƒ&#125; 9</span></span><br></pre></td></tr></table></figure><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。例如：<code>add(1, 2, 3, 4, 5)</code> 转换成 <code>add(1)(2)(3)(4)(5)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.<span class="property">length</span> &lt;= args.<span class="property">length</span> ? <span class="title function_">fn</span>(...args) : curry.<span class="title function_">bind</span>(<span class="literal">null</span>, fn, ...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b, c, d, e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的柯里化函数</span></span><br><span class="line"><span class="keyword">const</span> _fn = <span class="title function_">curry</span>(fn)</span><br><span class="line"></span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//--&gt; 1 2 3 4 5</span></span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//--&gt; 1 2 3 4 5</span></span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>) <span class="comment">//--&gt; 1 2 3 4 5</span></span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) <span class="comment">//--&gt; 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>看起来柯里化好像是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。而这里对于函数参数的自由处理，正是柯里化的核心所在。柯里化本质上是降低通用性，提高适用性。</p><h3 id="手写-EventBus"><a href="#手写-EventBus" class="headerlink" title="手写 EventBus"></a>手写 EventBus</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手写 EventBus</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 存储事件及其对应的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅事件</span></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果事件不存在，则创建一个新的事件数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[eventName] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将回调函数添加到事件数组中</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[eventName].<span class="title function_">push</span>(callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消订阅事件</span></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果事件不存在，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[eventName]) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从事件数组中移除指定的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[eventName] = <span class="variable language_">this</span>.<span class="property">events</span>[eventName].<span class="title function_">filter</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb !== callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布事件</span></span><br><span class="line">  <span class="title function_">next</span>(<span class="params">eventName, data</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果事件不存在，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[eventName]) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历事件数组，依次执行回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[eventName].<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">callback</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的 EventBus 实例</span></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">EventBus</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件处理函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handler1</span> = data =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Handler 1:&#x27;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handler2</span> = data =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Handler 2:&#x27;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">eventBus.<span class="title function_">subscribe</span>(<span class="string">&#x27;event1&#x27;</span>, handler1)</span><br><span class="line">eventBus.<span class="title function_">subscribe</span>(<span class="string">&#x27;event1&#x27;</span>, handler2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">eventBus.<span class="title function_">next</span>(<span class="string">&#x27;event1&#x27;</span>, <span class="string">&#x27;Hello, EventBus!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅事件</span></span><br><span class="line">eventBus.<span class="title function_">unsubscribe</span>(<span class="string">&#x27;event1&#x27;</span>, handler2)</span><br></pre></td></tr></table></figure><h3 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案回调函数和事件更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 <code>Promise</code>  对象。</p><p>所谓 <code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>下面我们用 ES6 语法来手写一个 Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promise/A+ 规范规定的三种状态</span></span><br><span class="line">  <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span> <span class="comment">// 等待状态</span></span><br><span class="line">  <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span><span class="comment">// 成功状态</span></span><br><span class="line">  <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span> <span class="comment">// 失败状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数接收一个执行回调</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable language_">this</span>.<span class="property">PENDING</span> <span class="comment">// Promise 初始状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="literal">undefined</span> <span class="comment">// then 回调的值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_resolveQueue</span> = [] <span class="comment">// resolve 时触发的成功队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rejectQueue</span> = [] <span class="comment">// reject 时触发的失败队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用箭头函数固定 this（resolve 函数在 executor 中触发，不然找不到 this）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = value =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// Promise/A+ 规范规定的 Promise 状态只能从 pending 触发，变成 fulfilled</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_status</span> === <span class="variable language_">this</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable language_">this</span>.<span class="property">FULFILLED</span> <span class="comment">// 更改状态</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_value</span> = value <span class="comment">// 储存当前值，用于 then 回调</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行 resolve 回调</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="title function_">callback</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把 resolve 执行回调的操作封装成一个函数，放进 setTimeout 里，以实现 Promise 异步调用的特性（规范上是微任务，这里是宏任务）</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(run)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同 resolve</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = value =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_status</span> === <span class="variable language_">this</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable language_">this</span>.<span class="property">REJECTED</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_value</span> = value</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="title function_">callback</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">setTimeout</span>(run)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new Promise() 时立即执行 executor，并传入 resolve 和 reject</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then 方法，接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果 then 的参数不是 function，则忽略它，让值继续往下传递，链式调用继续往下执行</span></span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled !== <span class="string">&#x27;function&#x27;</span> ? onFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span> ? onRejected = <span class="function"><span class="params">error</span> =&gt;</span> error : <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// then 返回一个新的 Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">resolveFn</span> = value =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = <span class="title function_">onFulfilled</span>(value)</span><br><span class="line">          <span class="comment">// 分类讨论返回值，如果是 Promise，那么等待 Promise 状态变更，否则直接 resolve</span></span><br><span class="line">          x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">rejectFn</span> = error =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = <span class="title function_">onRejected</span>(error)</span><br><span class="line">          x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">_status</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="variable language_">this</span>.<span class="property">PENDING</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="title function_">push</span>(resolveFn)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="title function_">push</span>(rejectFn)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable language_">this</span>.<span class="property">FULFILLED</span>:</span><br><span class="line">          <span class="title function_">resolveFn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable language_">this</span>.<span class="property">REJECTED</span>:</span><br><span class="line">          <span class="title function_">rejectFn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">finally</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value), <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态 resolve 方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span> ? value : <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(value))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态 reject 方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(error))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态 all 方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(result)</span><br><span class="line">      &#125;</span><br><span class="line">      promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          count++</span><br><span class="line">          result[i] = value</span><br><span class="line">          <span class="keyword">if</span> (count === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态 race 方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promiseArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(value)</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">`resolve ***`</span>)</span><br><span class="line">      &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">`reject ***`</span>)</span><br><span class="line">      &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve value: &#x27;</span>, res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject value: &#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="手写-JSONP"><a href="#手写-JSONP" class="headerlink" title="手写 JSONP"></a>手写 JSONP</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">url, params, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否含有参数</span></span><br><span class="line">  <span class="keyword">let</span> queryString = url.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) === <span class="string">&#x27;-1&#x27;</span> ? <span class="string">&#x27;?&#x27;</span> : <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params.<span class="title function_">hasOwnProperty</span>(k)) &#123;</span><br><span class="line">      queryString += k + <span class="string">&#x27;=&#x27;</span> + params[k] + <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理回调函数名</span></span><br><span class="line">  <span class="keyword">let</span> random = <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    callbackName = <span class="string">&#x27;myJsonp&#x27;</span> + random;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加回调函数</span></span><br><span class="line">  queryString += <span class="string">&#x27;callback=&#x27;</span> + callbackName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建请求</span></span><br><span class="line">  <span class="keyword">let</span> scriptNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  scriptNode.<span class="property">src</span> = url + queryString;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>[callbackName] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    <span class="title function_">callback</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除这个引入的脚本</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">removeChild</span>(scriptNode);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发起请求</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(scriptNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写观察者模式"><a href="#手写观察者模式" class="headerlink" title="手写观察者模式"></a>手写观察者模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> topics = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 注册监听函数</span></span><br><span class="line">    <span class="attr">subscribe</span>: <span class="keyword">function</span> (<span class="params">topic, handler</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.<span class="title function_">hasOwnProperty</span>(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      topics[topic].<span class="title function_">push</span>(handler);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件，触发观察者回调事件</span></span><br><span class="line">    <span class="attr">publish</span>: <span class="keyword">function</span> (<span class="params">topic, info</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.<span class="title function_">hasOwnProperty</span>(topic)) &#123;</span><br><span class="line">        topics[topic].<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">handler</span>) &#123;</span><br><span class="line">          <span class="title function_">handler</span>(info);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的一个观察者的回调事件</span></span><br><span class="line">    <span class="attr">remove</span>: <span class="keyword">function</span> (<span class="params">topic, handler</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.<span class="title function_">hasOwnProperty</span>(topic)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> handlerIndex = -<span class="number">1</span>;</span><br><span class="line">      topics[topic].<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item === handler) &#123;</span><br><span class="line">          handlerIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (handlerIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        topics[topic].<span class="title function_">splice</span>(handlerIndex, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的所有观察者的回调事件</span></span><br><span class="line">    <span class="attr">removeAll</span>: <span class="keyword">function</span> (<span class="params">topic</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.<span class="title function_">hasOwnProperty</span>(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在的前端招聘圈，对前端程序员的能力要求真的是越来越高了（&lt;del&gt;内卷真的太厉害了&lt;/del&gt;），出去找工作面试，哪怕是家小公司，大概率都会考一些 JS 手写题，你不会但别人会，自然就被卷死了。&lt;/p&gt;
&lt;p&gt;其实，对一个前端工程师来说，JS 本就重中之重，我们要掌握的可不仅仅是这些手写题。  &lt;/p&gt;
&lt;p&gt;当然，你不会这些手写题也不能代表你的 JS 编程能力不好，我觉得那是因为你不熟悉而已。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://xpoet.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 的内存管理</title>
    <link href="https://xpoet.cn/post/a1ea44b079f7/"/>
    <id>https://xpoet.cn/post/a1ea44b079f7/</id>
    <published>2021-05-14T13:56:42.000Z</published>
    <updated>2024-03-14T14:31:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>像 C 语言这样的底层语言一般都有底层的内存管理接口，比如 malloc() 和 free()。相反，JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让 JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。</p><h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：</p><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放\归还</li></ol><p>所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像 JavaScript 这些高级语言中，大部分都是隐含的。</p><h2 id="JavaScript-的内存分配"><a href="#JavaScript-的内存分配" class="headerlink" title="JavaScript 的内存分配"></a>JavaScript 的内存分配</h2><h3 id="值的初始化"><a href="#值的初始化" class="headerlink" title="值的初始化"></a>值的初始化</h3><p>为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;azerty&quot;</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">&quot;abra&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    someElement.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="通过函数调用分配内存"><a href="#通过函数调用分配内存" class="headerlink" title="通过函数调用分配内存"></a>通过函数调用分配内存</h3><p>有些函数调用结果是分配对象内存：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 分配一个 Date 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); <span class="comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure><p>有些方法分配新变量或者新对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;azerty&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 是一个新的字符串</span></span><br><span class="line"><span class="comment">// 因为字符串是不变量，</span></span><br><span class="line"><span class="comment">// JavaScript 可能决定不分配内存，</span></span><br><span class="line"><span class="comment">// 只是存储了 [0-3] 的范围。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;ouais ouais&quot;</span>, <span class="string">&quot;nan nan&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">&quot;generation&quot;</span>, <span class="string">&quot;nan nan&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a.<span class="title function_">concat</span>(a2);</span><br><span class="line"><span class="comment">// 新数组有四个元素，是 a 连接 a2 的结果</span></span><br></pre></td></tr></table></figure><h3 id="使用值"><a href="#使用值" class="headerlink" title="使用值"></a>使用值</h3><p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p><h3 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h3><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“哪些被分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。</p><p>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p><p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。</p><h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h3><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2 变量是第二个对“这个对象”的引用</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span>; <span class="comment">// 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oa = o2.<span class="property">a</span>; <span class="comment">// 引用“这个对象”的 a 属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是 o2，一个是 oa</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">&quot;yo&quot;</span>; <span class="comment">// 虽然最初的对象现在已经是零引用了，可以被垃圾回收了</span></span><br><span class="line"><span class="comment">// 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// a 属性的那个对象现在也是零引用了</span></span><br><span class="line"><span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure><h4 id="限制：循环引用"><a href="#限制：循环引用" class="headerlink" title="限制：循环引用"></a>限制：循环引用</h4><p>该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.<span class="property">a</span> = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.<span class="property">a</span> = o; <span class="comment">// o2 引用 o</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;azerty&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><h4 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h4><p>IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDivElement&quot;</span>);</span><br><span class="line">  div.<span class="property">circularReference</span> = div;</span><br><span class="line">  div.<span class="property">lotsOfData</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>).<span class="title function_">join</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从 DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p><p>这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p><p>从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记 - 清除算法的改进，并没有改进标记 - 清除算法本身和它对“对象是否不再需要”的简化定义。</p><h4 id="循环引用不再是问题了"><a href="#循环引用不再是问题了" class="headerlink" title="循环引用不再是问题了"></a>循环引用不再是问题了</h4><p>在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。</p><h4 id="限制：那些无法从根对象查询到的对象都将被清除"><a href="#限制：那些无法从根对象查询到的对象都将被清除" class="headerlink" title="限制：那些无法从根对象查询到的对象都将被清除"></a>限制：那些无法从根对象查询到的对象都将被清除</h4><p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;像 C 语言这样的底层语言一般都有底层的内存管理接口，比如 malloc() 和 free()。相反，JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让 JavaS</summary>
      
    
    
    
    <category term="前端" scheme="https://xpoet.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>从 0 开始手把手带你搭建一套企业级 Vue3.x 工程化项目</title>
    <link href="https://xpoet.cn/post/04962924f0b8/"/>
    <id>https://xpoet.cn/post/04962924f0b8/</id>
    <published>2021-04-06T07:33:47.000Z</published>
    <updated>2024-02-28T14:33:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue3 跟 Vite 正式版发布有很长一段时间了，生态圈也渐渐丰富起来，作者已在多个项目中使用，总结一下：就是快！也不用担心稳定性问题，开发体验真不是一般好！还没尝试的同学可以从本文开始学习，从 0 开始手把手带你搭建一套规范的 Vite + Vue3 + TypeScript 前端工程化项目环境。</p><span id="more"></span><p>本文篇幅较长，从以下几个方面展开：</p><ul><li>架构搭建</li><li>代码规范</li><li>提交规范</li><li>单元测试</li><li>自动部署</li></ul><blockquote><p>本项目完整的代码托管在 <a class="link"   href="https://github.com/XPoet/vite-vue3-starter" >GitHub 仓库<i class="fas fa-external-link-alt"></i></a>，欢迎点亮小星星 🌟🌟</p></blockquote><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>编程语言：<a class="link"   href="https://www.typescriptlang.org/zh/" >TypeScript 4.x<i class="fas fa-external-link-alt"></i></a> + <a class="link"   href="https://www.javascript.com/" >JavaScript<i class="fas fa-external-link-alt"></i></a></li><li>构建工具：<a class="link"   href="https://cn.vitejs.dev/" >Vite 2.x<i class="fas fa-external-link-alt"></i></a></li><li>前端框架：<a class="link"   href="https://v3.cn.vuejs.org/" >Vue 3.x<i class="fas fa-external-link-alt"></i></a></li><li>路由工具：<a class="link"   href="https://next.router.vuejs.org/zh/index.html" >Vue Router 4.x<i class="fas fa-external-link-alt"></i></a></li><li>状态管理：<a class="link"   href="https://next.vuex.vuejs.org/" >Vuex 4.x<i class="fas fa-external-link-alt"></i></a></li><li>UI 框架：<a class="link"   href="https://element-plus.org/#/zh-CN" >Element Plus<i class="fas fa-external-link-alt"></i></a></li><li>CSS 预编译：<a class="link"   href="https://stylus-lang.com/" >Stylus<i class="fas fa-external-link-alt"></i></a> &#x2F; <a class="link"   href="https://sass.bootcss.com/documentation" >Sass<i class="fas fa-external-link-alt"></i></a> &#x2F; <a class="link"   href="http://lesscss.cn/" >Less<i class="fas fa-external-link-alt"></i></a></li><li>HTTP 工具：<a class="link"   href="https://axios-http.com/" >Axios<i class="fas fa-external-link-alt"></i></a></li><li>Git Hook 工具：<a class="link"   href="https://typicode.github.io/husky/#/" >husky<i class="fas fa-external-link-alt"></i></a> + <a class="link"   href="https://github.com/okonet/lint-staged" >lint-staged<i class="fas fa-external-link-alt"></i></a></li><li>代码规范：<a class="link"   href="http://editorconfig.org/" >EditorConfig<i class="fas fa-external-link-alt"></i></a> + <a class="link"   href="https://prettier.io/" >Prettier<i class="fas fa-external-link-alt"></i></a> + <a class="link"   href="https://eslint.org/" >ESLint<i class="fas fa-external-link-alt"></i></a> + <a class="link"   href="https://github.com/airbnb/javascript#translation" >Airbnb JavaScript Style Guide<i class="fas fa-external-link-alt"></i></a></li><li>提交规范：<a class="link"   href="http://commitizen.github.io/cz-cli/" >Commitizen<i class="fas fa-external-link-alt"></i></a> + <a class="link"   href="https://commitlint.js.org/#/" >Commitlint<i class="fas fa-external-link-alt"></i></a></li><li>单元测试：<a class="link"   href="https://next.vue-test-utils.vuejs.org/" >vue-test-utils<i class="fas fa-external-link-alt"></i></a> + <a class="link"   href="https://jestjs.io/" >jest<i class="fas fa-external-link-alt"></i></a> + <a class="link"   href="https://github.com/vuejs/vue-jest" >vue-jest<i class="fas fa-external-link-alt"></i></a> + <a class="link"   href="https://kulshekhar.github.io/ts-jest/" >ts-jest<i class="fas fa-external-link-alt"></i></a></li><li>自动部署：<a class="link"   href="https://docs.github.com/cn/actions/learn-github-actions" >GitHub Actions<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="架构搭建"><a href="#架构搭建" class="headerlink" title="架构搭建"></a>架构搭建</h2><p>请确保你的电脑上成功安装 Node.js，本项目使用 Vite 构建工具，<strong>需要 Node.js 版本 &gt;&#x3D; 12.0.0</strong>。</p><p>查看 Node.js 版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>建议将 Node.js 升级到最新的稳定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 nvm 安装最新稳定版 Node.js</span></span><br><span class="line">nvm install stable</span><br></pre></td></tr></table></figure><h3 id="使用-Vite-快速初始化项目雏形"><a href="#使用-Vite-快速初始化项目雏形" class="headerlink" title="使用 Vite 快速初始化项目雏形"></a>使用 Vite 快速初始化项目雏形</h3><ul><li><p>使用 NPM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init @vitejs/app</span><br></pre></td></tr></table></figure></li><li><p>使用 Yarn：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn create @vitejs/app</span><br></pre></td></tr></table></figure></li></ul><p>然后按照终端提示完成以下操作：</p><ol><li><p>输入项目名称</p><p>例如：本项目名称 <strong>vite-vue3-starter</strong></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.2uunmmbbm4w0.png"                        alt="image"                 ></p></li><li><p>选择模板</p><p>本项目需要使用 Vue3 + TypeScript，所以我们选择 <code>vue-ts</code>，会自动安装 Vue3 和 TypeScript。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.85qfbz8zh1c.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.jsp544ku2mo.png"                        alt="image"                 ></p><p>你还可以通过附加的命令行选项直接指定项目名和模板，本项目要构建 Vite + Vue3 + TypeScript 项目，则运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm 6.x</span></span><br><span class="line">npm init @vitejs/app vite-vue3-starter --template vue-ts</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 7+（需要额外的双横线）</span></span><br><span class="line">npm init @vitejs/app vite-vue3-starter -- --template vue-ts</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn</span></span><br><span class="line">yarn create @vitejs/app vite-vue3-starter --template vue-ts</span><br></pre></td></tr></table></figure></li><li><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>启动项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.1z3aiuqxy1a8.png"                        alt="image"                 ></p><p>如上图，表示 Vite + Vue3 + TypeScript 简单的项目骨架搭建完毕，下面我们来为这个项目集成 Vue Router、Vuex、Element Plus、Axios、Stylus&#x2F;Sass&#x2F;Less。</p></li></ol><h3 id="修改-Vite-配置文件"><a href="#修改-Vite-配置文件" class="headerlink" title="修改 Vite 配置文件"></a>修改 Vite 配置文件</h3><p>Vite 配置文件 <code>vite.config.ts</code> 位于根目录下，项目启动时会自动读取。</p><p>本项目先做一些简单配置，例如：设置 <code>@</code> 指向 <code>src</code> 目录、服务启动端口、打包路径、代理等。</p><p>关于 Vite 更多配置项及用法，请查看 Vite 官网 <a class="link"   href="https://vitejs.dev/config/" >https://vitejs.dev/config/<i class="fas fa-external-link-alt"></i></a> 。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="comment">// 如果编辑器提示 path 模块找不到，则可以安装一下 @types/node -&gt; npm i @types/node -D</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>) <span class="comment">// 设置 `@` 指向 `src` 目录</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;./&#x27;</span>, <span class="comment">// 设置打包路径</span></span><br><span class="line">  <span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">4000</span>, <span class="comment">// 设置服务启动端口号</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 设置服务启动时是否自动打开浏览器</span></span><br><span class="line">    <span class="attr">cors</span>: <span class="literal">true</span> <span class="comment">// 允许跨域</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置代理，根据我们项目实际情况配置</span></span><br><span class="line">    <span class="comment">// proxy: &#123;</span></span><br><span class="line">    <span class="comment">//   &#x27;/api&#x27;: &#123;</span></span><br><span class="line">    <span class="comment">//     target: &#x27;http://xxx.xxx.xxx.xxx:8000&#x27;,</span></span><br><span class="line">    <span class="comment">//     changeOrigin: true,</span></span><br><span class="line">    <span class="comment">//     secure: false,</span></span><br><span class="line">    <span class="comment">//     rewrite: (path) =&gt; path.replace(&#x27;/api/&#x27;, &#x27;/&#x27;)</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="规范目录结构"><a href="#规范目录结构" class="headerlink" title="规范目录结构"></a>规范目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├── publish/</span><br><span class="line">└── src/</span><br><span class="line">    ├── assets/                    // 静态资源目录</span><br><span class="line">    ├── common/                    // 通用类库目录</span><br><span class="line">    ├── components/                // 公共组件目录</span><br><span class="line">    ├── router/                    // 路由配置目录</span><br><span class="line">    ├── store/                     // 状态管理目录</span><br><span class="line">    ├── style/                     // 通用 CSS 目录</span><br><span class="line">    ├── utils/                     // 工具函数目录</span><br><span class="line">    ├── views/                     // 页面组件目录</span><br><span class="line">    ├── App.vue</span><br><span class="line">    ├── main.ts</span><br><span class="line">    ├── shims-vue.d.ts</span><br><span class="line">├── tests/                         // 单元测试目录</span><br><span class="line">├── index.html</span><br><span class="line">├── tsconfig.json                  // TypeScript 配置文件</span><br><span class="line">├── vite.config.ts                 // Vite 配置文件</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><h3 id="集成路由工具-Vue-Router"><a href="#集成路由工具-Vue-Router" class="headerlink" title="集成路由工具 Vue Router"></a>集成路由工具 Vue Router</h3><ol><li><p>安装支持 Vue3 的路由工具 vue-router@4</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router@4</span><br></pre></td></tr></table></figure></li><li><p>创建 <code>src/router/index.ts</code> 文件</p><p>在 <code>src</code> 下创建 <code>router</code> 目录，然后在 <code>router</code> 目录里新建 <code>index.ts</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">└── src/</span><br><span class="line">    ├── router/</span><br><span class="line">        ├── index.ts  // 路由配置文件</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createRouter,</span><br><span class="line">  createWebHashHistory,</span><br><span class="line">  <span class="title class_">RouteRecordRaw</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/vuex.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/vuex&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Vuex&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Vuex</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/axios&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Axios&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/axios.vue&#x27;</span>) <span class="comment">// 懒加载组件</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>根据本项目路由配置的实际情况，你需要在 <code>src</code> 下创建 <code>views</code> 目录，用来存储页面组件。</p><p>我们在 <code>views</code> 目录下创建 <code>home.vue</code> 、<code>vuex.vue</code> 、<code>axios.vue</code>。</p></li><li><p>在 <code>main.ts</code> 文件中挂载路由配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(router).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="集成状态管理工具-Vuex"><a href="#集成状态管理工具-Vuex" class="headerlink" title="集成状态管理工具 Vuex"></a>集成状态管理工具 Vuex</h3><ol><li><p>安装支持 Vue3 的状态管理工具 vuex@next</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vuex@next</span><br></pre></td></tr></table></figure></li><li><p>创建 <code>src/store/index.ts</code> 文件</p><p>在 <code>src</code> 下创建 <code>store</code> 目录，然后在 <code>store</code> 目录里新建 <code>index.ts</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">└── src/</span><br><span class="line">    ├── store/</span><br><span class="line">        ├── index.ts  // store 配置文件</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new store instance.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultState</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"><span class="attr">state</span>: <span class="keyword">typeof</span> defaultState</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">context</span>) &#123;</span><br><span class="line">      context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">double</span>(<span class="params"><span class="attr">state</span>: <span class="keyword">typeof</span> defaultState</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span> * state.<span class="property">count</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在 <code>main.ts</code> 文件中挂载 Vuex 配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(store).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="集成-UI-框架-Element-Plus"><a href="#集成-UI-框架-Element-Plus" class="headerlink" title="集成 UI 框架 Element Plus"></a>集成 UI 框架 Element Plus</h3><ol><li><p>安装支持 Vue3 的 UI 框架 Element Plus</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-plus</span><br></pre></td></tr></table></figure></li><li><p>在 <code>main.ts</code> 文件中挂载 Element Plus</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/lib/theme-chalk/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="集成-HTTP-工具-Axios"><a href="#集成-HTTP-工具-Axios" class="headerlink" title="集成 HTTP 工具 Axios"></a>集成 HTTP 工具 Axios</h3><ol><li><p>安装 Axios（Axios 跟 Vue 版本没有直接关系，安装最新即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i axios</span><br></pre></td></tr></table></figure></li><li><p>配置 Axios</p><blockquote><p>为了使项目的目录结构合理且规范，我们在 <code>src</code> 下创建 <code>utils</code> 目录来存储我们常用的工具函数。</p></blockquote><p>Axios 作为 HTTP 工具，我们在 <code>utils</code> 目录下创建 <code>axios.ts</code> 作为 Axios 配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">└── src/</span><br><span class="line">    ├── utils/</span><br><span class="line">        ├── axios.ts  // Axios 配置文件</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Axios</span> <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ElMessage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseURL = <span class="string">&#x27;https://api.github.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axios = <span class="title class_">Axios</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">  baseURL,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">20000</span> <span class="comment">// 请求超时 20s</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置拦截器（发起请求之前的拦截）</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据你的项目实际情况来对 config 做处理</span></span><br><span class="line"><span class="comment">     * 这里对 config 不做任何处理，直接返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置拦截器（获取到响应时的拦截）</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据你的项目实际情况来对 response 和 error 做处理</span></span><br><span class="line"><span class="comment">     * 这里对 response 和 error 不做任何处理，直接返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">response</span> &amp;&amp; error.<span class="property">response</span>.<span class="property">data</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> code = error.<span class="property">response</span>.<span class="property">status</span></span><br><span class="line">      <span class="keyword">const</span> msg = error.<span class="property">response</span>.<span class="property">data</span>.<span class="property">message</span></span><br><span class="line">      <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">`Code: <span class="subst">$&#123;code&#125;</span>, Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`[Axios Error]`</span>, error.<span class="property">response</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">`<span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios</span><br></pre></td></tr></table></figure></li><li><p>使用 Axios<br>在需要使用 Axios 文件里，引入 Axios 配置文件，参考如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;../utils/axios&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      axios</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">get</span>(<span class="string">&#x27;/users/XPoet&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res)</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err: &#x27;</span>, err)</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="集成-CSS-预编译器-Stylus-x2F-Sass-x2F-Less"><a href="#集成-CSS-预编译器-Stylus-x2F-Sass-x2F-Less" class="headerlink" title="集成 CSS 预编译器 Stylus&#x2F;Sass&#x2F;Less"></a>集成 CSS 预编译器 Stylus&#x2F;Sass&#x2F;Less</h3><p>本项目使用 CSS 预编译器 Stylus，直接安装为开发依赖即可。Vite 内部已帮我们集成了相关的 loader，不需要额外配置。同理，你也可以使用 Sass 或 Less 等。</p><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i stylus -D</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">npm i sass -D</span><br><span class="line">npm i less -D</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>至此，一个基于 TypeScript + Vite + Vue3 + Vue Router + Vuex + Element Plus + Axios + Stylus&#x2F;Sass&#x2F;Less 的前端项目开发环境搭建完毕，项目 Demo 托管在 <a class="link"   href="https://github.com/XPoet/vite-vue3-starter" >GitHub 仓库<i class="fas fa-external-link-alt"></i></a>，需要的同学可以去下载下来，参考学习。</p><p>下面我们来打磨这个项目，增加代码规范约束、提交规范约束、单元测试、自动部署等，让其更完善、更健壮。</p><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>随着前端应用逐渐变得大型化和复杂化，在同一个项目中有多个人员参与时，每个人的前端能力程度不等，他们往往会用不同的编码风格和习惯在项目中写代码，长此下去，势必会让项目的健壮性越来越差。解决这些问题，理论上讲，口头约定和代码审查都可以，但是这种方式无法实时反馈，而且沟通成本过高，不够灵活，更关键的是无法把控。不以规矩，不能成方圆，我们不得不在项目使用一些工具来约束代码规范。</p><p>本文讲解如何使用 <strong>EditorConfig + Prettier + ESLint</strong> 组合来实现代码规范化。</p><p>这样做带来好处：</p><ul><li>解决团队之间代码不规范导致的可读性差和可维护性差的问题。</li><li>解决团队成员不同编辑器导致的编码规范不统一问题。</li><li>提前发现代码风格问题，给出对应规范提示，及时修复。</li><li>减少代码审查过程中反反复复的修改过程，节约时间。</li><li>自动格式化，统一编码风格，从此和脏乱差的代码说再见。</li></ul><h3 id="集成-EditorConfig-配置"><a href="#集成-EditorConfig-配置" class="headerlink" title="集成 EditorConfig 配置"></a>集成 EditorConfig 配置</h3><p>EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。</p><p>官网：<a class="link"   href="http://editorconfig.org/" >http://editorconfig.org<i class="fas fa-external-link-alt"></i></a></p><p>在项目根目录下增加 <code>.editorconfig</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Editor configuration, see http://editorconfig.org</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示是最顶层的 EditorConfig 配置文件</span></span><br><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*] <span class="comment"># 表示所有文件适用</span></span><br><span class="line">charset = utf-8 <span class="comment"># 设置文件字符集为 utf-8</span></span><br><span class="line">indent_style = space <span class="comment"># 缩进风格（tab | space）</span></span><br><span class="line">indent_size = 2 <span class="comment"># 缩进大小</span></span><br><span class="line">end_of_line = lf <span class="comment"># 控制换行类型(lf | cr | crlf)</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span> <span class="comment"># 去除行首的任意空白字符</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span> <span class="comment"># 始终在文件末尾插入一个新行</span></span><br><span class="line"></span><br><span class="line">[*.md] <span class="comment"># 表示仅 md 文件适用以下规则</span></span><br><span class="line">max_line_length = off</span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>VSCode 使用 EditorConfig 需要去插件市场下载插件 <strong>EditorConfig for VS Code</strong> 。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.2wj7mdci7ya0.png"                        alt="image"                 ></p></li><li><p>JetBrains 系列（WebStorm、IntelliJ IDEA 等）则不用额外安装插件，可直接使用 EditorConfig 配置。</p></li></ul><h3 id="集成-Prettier-配置"><a href="#集成-Prettier-配置" class="headerlink" title="集成 Prettier 配置"></a>集成 Prettier 配置</h3><p>Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。</p><p>官网：<a class="link"   href="https://prettier.io/" >https://prettier.io/<i class="fas fa-external-link-alt"></i></a></p><ol><li><p>安装 Prettier</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i prettier -D</span><br></pre></td></tr></table></figure></li><li><p>创建 Prettier 配置文件</p><p>Prettier 支持多种格式的<a class="link"   href="https://prettier.io/docs/en/configuration.html" >配置文件<i class="fas fa-external-link-alt"></i></a>，比如 <code>.json</code>、<code>.yml</code>、<code>.yaml</code>、<code>.js</code>等。</p><p>在本项目根目录下创建 <code>.prettierrc</code> 文件。</p></li><li><p>配置 <code>.prettierrc</code></p><p>在本项目中，我们进行如下简单配置，关于更多配置项信息，请前往官网查看 <a class="link"   href="https://prettier.io/docs/en/options.html" >Prettier-Options<i class="fas fa-external-link-alt"></i></a> 。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;useTabs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tabWidth&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;printWidth&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;singleQuote&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;trailingComma&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bracketSpacing&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;semi&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Prettier 安装且配置好之后，就能使用命令来格式化代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化所有文件（. 表示所有文件）</span></span><br><span class="line">npx prettier --write .</span><br></pre></td></tr></table></figure></li></ol><p>注意：</p><ul><li><p>VSCode 编辑器使用 Prettier 配置需要下载插件 <strong>Prettier - Code formatter</strong> 。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.1khvzd6zfw68.png"                        alt="image"                 ></p></li><li><p>JetBrains 系列编辑器（WebStorm、IntelliJ IDEA 等）则不用额外安装插件，可直接使用 Prettier 配置。</p></li></ul><p>Prettier 配置好以后，在使用 VSCode 或 WebStorm 等编辑器的格式化功能时，编辑器就会按照 Prettier 配置文件的规则来进行格式化，避免了因为大家编辑器配置不一样而导致格式化后的代码风格不统一的问题。</p><h3 id="集成-ESLint-配置"><a href="#集成-ESLint-配置" class="headerlink" title="集成 ESLint 配置"></a>集成 ESLint 配置</h3><p><a class="link"   href="https://github.com/eslint/eslint" >ESLint<i class="fas fa-external-link-alt"></i></a> 是一款用于查找并报告代码中问题的工具，并且支持部分问题自动修复。其核心是通过对代码解析得到的 AST（Abstract Syntax Tree 抽象语法树）进行模式匹配，来分析代码达到检查代码质量和风格问题的能力。</p><p>正如前面我们提到的因团队成员之间编程能力和编码习惯不同所造成的代码质量问题，我们使用 ESLint 来解决，一边写代码一边查找问题，如果发现错误，就给出规则提示，并且自动修复，长期下去，可以促使团队成员往同一种编码风格靠拢。</p><ol><li><p>安装 ESLint</p><p>可以全局或者本地安装，作者推荐本地安装（只在当前项目中安装）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint -D</span><br></pre></td></tr></table></figure></li><li><p>配置 ESLint</p><p>ESLint 安装成功后，执行 <code>npx eslint --init</code>，然后按照终端操作提示完成一系列设置来创建配置文件。</p><ul><li><p>How would you like to use ESLint? （你想如何使用 ESLint?）</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.6hp2qaeguvk0.png"                        alt="image"                 ></p><p>我们这里选择 <strong>To check syntax, find problems, and enforce code style（检查语法、发现问题并强制执行代码风格）</strong></p></li><li><p>What type of modules does your project use?（你的项目使用哪种类型的模块？）</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.6m4op1lj8jw0.png"                        alt="image"                 ></p><p>我们这里选择 <strong>JavaScript modules (import&#x2F;export)</strong></p></li><li><p>Which framework does your project use? （你的项目使用哪种框架？）</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.71kbglpvuv40.png"                        alt="image"                 ></p><p>我们这里选择 <strong>Vue.js</strong></p></li><li><p>Does your project use TypeScript?（你的项目是否使用 TypeScript？）</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.7dtfqhli6zc0.png"                        alt="image"                 ></p><p>我们这里选择 <strong>Yes</strong></p></li><li><p>Where does your code run?（你的代码在哪里运行？）</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.sii441muitc.png"                        alt="image"                 ></p><p>我们这里选择 <strong>Browser 和 Node</strong>（按空格键进行选择，选完按回车键确定）</p></li><li><p>How would you like to define a style for your project?（你想怎样为你的项目定义风格？）</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.5v0m1ka49l00.png"                        alt="image"                 ></p><p>我们这里选择 <strong>Use a popular style guide（使用一种流行的风格指南）</strong></p></li><li><p>Which style guide do you want to follow?（你想遵循哪一种风格指南？）</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.olsqco7y3ww.png"                        alt="image"                 ></p><p>我们这里选择 <strong>Airbnb: <a class="link"   href="https://github.com/airbnb/javascript" >https://github.com/airbnb/javascript<i class="fas fa-external-link-alt"></i></a></strong></p><p>ESLint 为我们列出了三种社区流行的 JavaScript 风格指南，分别是 Airbnb、Standard、Google。</p><p>这三份风格指南都是由众多大佬根据多年开发经验编写，足够优秀，全球很多大小公司都在使用。我们选用 <strong>GitHub 上 star 最多的 Airbnb</strong>，免去繁琐的配置 ESLint 规则时间，然后让团队成员去学习 Airbnb JavaScript 风格指南即可。</p><p>此时，我们在 ESLint 配置了 Airbnb JavaScript 规则，在编码时，所有不符合 Airbnb 风格的代码，编辑器都会给出提示，并且可以自动修复。</p><p><strong>这里作者不建议大家去自由配置 ESLint 规则，相信我，这三份 JavaScript 代码风格指南值得我们反复学习，掌握后，编程能力能上一大台阶。</strong></p><ul><li><p><a class="link"   href="https://github.com/airbnb/javascript" >Airbnb JavaScript Style Guide<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/lin-123/javascript" >Airbnb JavaScript 风格指南 - 中文版<i class="fas fa-external-link-alt"></i></a></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.6bg6mj95i340.png"                        alt="image"                 ></p></li><li><p><a class="link"   href="https://github.com/standard/standard" >JavaScript Standard Style<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/standard/standard/blob/master/docs/README-zhcn.md" >JavaScript Standard Style - 中文版<i class="fas fa-external-link-alt"></i></a></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.3tyxmo1ge0s0.png"                        alt="image"                 ></p></li><li><p><a class="link"   href="https://google.github.io/styleguide/jsguide.html" >Google JavaScript Style Guide<i class="fas fa-external-link-alt"></i></a></p></li></ul></li><li><p>What format do you want your config file to be in?（你希望你的配置文件是什么格式？）</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.6p7k166rq8o0.png"                        alt="image"                 ></p><p>我们这里选择 <strong>JavaScript</strong></p></li><li><p>Would you like to install them now with npm?（你想现在就用 NPM 安装它们吗？）</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.1gn91ehp12kg.png"                        alt="image"                 ></p><p>根据上面的选择，ESLint 会自动去查找缺失的依赖，我们这里选择 <strong>Yes</strong>，使用 NPM 下载安装这些依赖包。</p><p>注意：如果自动安装依赖失败，那么需要手动安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint-config-airbnb-base eslint-plugin-import eslint-plugin-vue -D</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ESLint 配置文件 <code>.eslintrc.js</code></p><p>在<strong>上一步</strong>操作完成后，会在项目根目录下自动生成 <code>.eslintrc.js</code> 配置文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;plugin:vue/essential&#x27;</span>, <span class="string">&#x27;airbnb-base&#x27;</span>],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">parser</span>: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;vue&#x27;</span>, <span class="string">&#x27;@typescript-eslint&#x27;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据项目实际情况，如果我们有额外的 ESLint 规则，也在此文件中追加。</p></li></ol><p>注意：</p><ul><li><p>VSCode 使用 ESLint 配置文件需要去插件市场下载插件 <strong>ESLint</strong> 。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.74p98iz7dfg0.png"                        alt="image"                 ></p></li><li><p>JetBrains 系列（WebStorm、IntelliJ IDEA 等）则不用额外安装插件。</p></li></ul><p>配置好以后，我们在 VSCode 或 WebStorm 等编辑器中开启 ESLin，写代码时，ESLint 就会按照我们配置的规则来进行实时代码检查，发现问题会给出对应错误提示和修复方案。</p><p>如图：</p><ul><li><p>VSCode<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.c62yn1mjkyo.png"                        alt="image"                 ></p></li><li><p>WebStorm<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.47a98zb9bv60.png"                        alt="image"                 ></p></li></ul><p>虽然，现在编辑器已经给出错误提示和修复方案，但需要我们一个一个去点击修复，还是挺麻烦的。很简单，我们只需设置编辑器保存文件时自动执行 <code>eslint --fix</code> 命令进行代码风格修复。</p><ul><li><p>VSCode<br>在 <code>settings.json</code> 设置文件中，增加以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WebStorm<br>打开设置窗口，按如下操作，最后点击 <code>Apply</code> -&gt; <code>OK</code>。<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.30jyc44ht540.png"                        alt="image"                 ></p></li></ul><h3 id="解决-Prettier-和-ESLint-的冲突"><a href="#解决-Prettier-和-ESLint-的冲突" class="headerlink" title="解决 Prettier 和 ESLint 的冲突"></a>解决 Prettier 和 ESLint 的冲突</h3><p>通常大家会在项目中根据实际情况添加一些额外的 ESLint 和 Prettier 配置规则，难免会存在规则冲突情况。</p><p>本项目中的 ESLint 配置中使用了 Airbnb JavaScript 风格指南校验，其规则之一是<em>代码结束后面要加分号</em>，而我们在 Prettier 配置文件中加了<em>代码结束后面不加分号</em>的配置项，这样就有冲突了，会出现用 Prettier 格式化后的代码，ESLint 检测到格式有问题的，从而抛出错误提示。</p><p>解决两者冲突问题，需要用到 <strong>eslint-plugin-prettier</strong> 和 <strong>eslint-config-prettier</strong>。</p><ul><li><p><code>eslint-plugin-prettier</code> 将 Prettier 的规则设置到 ESLint 的规则中。</p></li><li><p><code>eslint-config-prettier</code> 关闭 ESLint 中与 Prettier 中会发生冲突的规则。</p></li></ul><p>最后形成优先级：<code>Prettier 配置规则</code> &gt; <code>ESLint 配置规则</code>。</p><ul><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint-plugin-prettier eslint-config-prettier -D</span><br></pre></td></tr></table></figure></li><li><p>在 <code>.eslintrc.js</code> 添加 prettier 插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;plugin:vue/essential&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;airbnb-base&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:prettier/recommended&#x27;</span> <span class="comment">// 添加 prettier 插件</span></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样，我们在执行 <code>eslint --fix</code> 命令时，ESLint 就会按照 Prettier 的配置规则来格式化代码，轻松解决二者冲突问题。</p><h3 id="集成-husky-和-lint-staged"><a href="#集成-husky-和-lint-staged" class="headerlink" title="集成 husky 和 lint-staged"></a>集成 husky 和 lint-staged</h3><p>我们在项目中已集成 ESLint 和 Prettier，在编码时，这些工具可以对我们写的代码进行实时校验，在一定程度上能有效规范我们写的代码，但团队可能会有些人觉得这些条条框框的限制很麻烦，选择视“提示”而不见，依旧按自己的一套风格来写代码，或者干脆禁用掉这些工具，开发完成就直接把代码提交到了仓库，日积月累，ESLint 也就形同虚设。</p><p>所以，我们还需要做一些限制，让没通过 ESLint 检测和修复的代码禁止提交，从而保证仓库代码都是符合规范的。</p><p>为了解决这个问题，我们需要用到 Git Hook，在本地执行 <code>git commit</code> 的时候，就对所提交的代码进行 ESLint 检测和修复（即执行 <code>eslint --fix</code>），如果这些代码没通过 ESLint 规则校验，则禁止提交。</p><p>实现这一功能，我们借助 <a class="link"   href="https://github.com/typicode/husky" >husky<i class="fas fa-external-link-alt"></i></a> + <a class="link"   href="https://github.com/okonet/lint-staged" >lint-staged<i class="fas fa-external-link-alt"></i></a> 。</p><blockquote><p><a class="link"   href="https://github.com/typicode/husky" >husky<i class="fas fa-external-link-alt"></i></a> —— Git Hook 工具，可以设置在 git 各个阶段（<code>pre-commit</code>、<code>commit-msg</code>、<code>pre-push</code> 等）触发我们的命令。<br><a class="link"   href="https://github.com/okonet/lint-staged" >lint-staged<i class="fas fa-external-link-alt"></i></a> —— 在 git 暂存的文件上运行 linters。</p></blockquote><h4 id="配置-husky"><a href="#配置-husky" class="headerlink" title="配置 husky"></a>配置 husky</h4><ul><li><p>自动配置（推荐）</p><p>使用 <code>husky-init</code> 命令快速在项目初始化一个 husky 配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky-init &amp;&amp; npm install</span><br></pre></td></tr></table></figure><p>这行命令做了四件事：</p><ol><li><p>安装 husky 到开发依赖<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.3yknd7cdfvg0.png"                        alt="image"                 ></p></li><li><p>在项目根目录下创建 <code>.husky</code> 目录<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.3ki5epkriew0.png"                        alt="image"                 ></p></li><li><p>在 <code>.husky</code> 目录创建 <code>pre-commit</code> hook，并初始化 <code>pre-commit</code> 命令为 <code>npm test</code><br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.6n7dripqhg00.png"                        alt="image"                 ></p></li><li><p>修改 <code>package.json</code> 的 <code>scripts</code>，增加 <code>&quot;prepare&quot;: &quot;husky install&quot;</code><br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.3c0m6wd9p8o0.png"                        alt="image"                 ></p></li></ol></li><li><p>手动配置（不推荐，懒是程序员第一生产力）</p><ol><li><p>安装 husky</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i husky -D</span><br></pre></td></tr></table></figure></li><li><p>创建 Git hooks</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky install</span><br></pre></td></tr></table></figure><p>该命令做了两件事：</p><ul><li><p>在项目根目录下创建 <code>.husky</code> 目录<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.3ki5epkriew0.png"                        alt="image"                 ></p></li><li><p>在 <code>.husky</code> 目录创建 <code>pre-commit</code> hook，并初始化 <code>pre-commit</code> 命令为 <code>npm test</code><br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.6n7dripqhg00.png"                        alt="image"                 ></p></li></ul></li><li><p>手动修改 <code>package.json</code> 的 <code>scripts</code>，增加 <code>&quot;prepare&quot;: &quot;husky install&quot;</code><br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.3c0m6wd9p8o0.png"                        alt="image"                 ></p></li></ol></li></ul><blockquote><p><strong>特别注意：本项目使用 husky 6.x 版本，6.x 版本配置方式跟之前的版本有较大差异。目前网上大部分有关 husky 的教程都是 6 以前的版本，跟本文教程不太一样，当发现配置方法不一致时，一切以 <a class="link"   href="https://typicode.github.io/husky/#/?id=usage" >husky 官网<i class="fas fa-external-link-alt"></i></a>为准。</strong></p></blockquote><p>到这里，husky 配置完毕，现在我们来使用它：</p><p>husky 包含很多 <code>hook</code>（钩子），常用有：<code>pre-commit</code>、<code>commit-msg</code>、<code>pre-push</code>。这里，我们使用 <code>pre-commit</code> 来触发 ESLint 命令。</p><p>修改 <code>.husky/pre-commit</code> hook 文件的触发命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint --fix ./src --ext .vue,.js,.ts</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.6j6cey4uj800.png"                        alt="image"                 ></p><p>上面这个 <code>pre-commit</code> hook 文件的作用是：当我们执行 <code>git commit -m &quot;xxx&quot;</code> 时，会先对 <code>src</code> 目录下所有的 <code>.vue</code>、<code>.js</code>、<code>.ts </code> 文件执行 <code>eslint --fix</code> 命令，如果 ESLint 通过，成功 <code>commit</code>，否则终止 <code>commit</code>。</p><p>但是又存在一个问题：有时候我们明明只改动了一两个文件，却要对所有的文件执行 <code>eslint --fix</code>。假如这是一个历史项目，我们在中途配置了 ESLint 规则，那么在提交代码时，也会对其他未修改的“历史”文件都进行检查，可能会造成大量文件出现 ESLint 错误，显然不是我们想要的结果。</p><p>我们要做到只用 ESLint 修复自己此次写的代码，而不去影响其他的代码。所以我们还需借助一个神奇的工具 <strong>lint-staged</strong> 。</p><h4 id="配置-lint-staged"><a href="#配置-lint-staged" class="headerlink" title="配置 lint-staged"></a>配置 lint-staged</h4><p>lint-staged 这个工具一般结合 husky 来使用，它可以让 husky 的 <code>hook</code> 触发的命令只作用于 <code>git add</code>那些文件（即 git 暂存区的文件），而不会影响到其他文件。</p><p>接下来，我们使用 lint-staged 继续优化项目。</p><ol><li><p>安装 lint-staged</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i lint-staged -D</span><br></pre></td></tr></table></figure></li><li><p>在 <code>package.json</code>里增加 lint-staged 配置项</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.2uth3b5ni200.png"                        alt="image"                 ></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;lint-staged&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;*.&#123;vue,js,ts&#125;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint --fix&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>这行命令表示：只对 git 暂存区的 <code>.vue</code>、<code>.js</code>、<code>.ts</code> 文件执行 <code>eslint --fix</code>。</p></li><li><p>修改 <code>.husky/pre-commit</code> hook 的触发命令为：<code>npx lint-staged</code></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.cdgtch7kle0.png"                        alt="image"                 ></p></li></ol><p>至此，husky 和 lint-staged 组合配置完成。</p><p>现在我们提交代码时就会变成这样：</p><p>假如我们修改了 <code>scr</code> 目录下的 <code>test-1.js</code>、<code>test-2.ts</code> 和 <code>test-3.md</code> 文件，然后 <code>git add ./src/</code>，最后 <code>git commit -m &quot;test...&quot;</code>，这时候就会只对 <code>test-1.js</code>、<code>test-2.ts</code> 这两个文件执行 <code>eslint --fix</code>。如果 ESLint 通过，成功提交，否则终止提交。从而保证了我们提交到 Git 仓库的代码都是规范的。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.30u6zhpu0ry0.png"                        alt="image"                 ></p><ul><li><p>提交前 <code>test-1.js</code>、<code>test-2.ts</code><br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.1dm1yn0jv1a8.png"                        alt="image"                 ></p></li><li><p>提交后 <code>test-1.js</code>、<code>test-2.ts</code> 自动修复代码格式<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.5wtsmyhllx00.png"                        alt="image"                 ></p></li></ul><p>无论写代码还是做其他事情，都应该用长远的眼光来看，刚开始使用 ESint 的时候可能会有很多问题，改起来也很费时费力，只要坚持下去，代码质量和开发效率都会得到提升，前期的付出都是值得的。</p><p>这些工具并不是必须的，没有它们你同样可以可以完成功能开发，但是利用好这些工具，你可以写出更高质量的代码。特别是一些刚刚接触的人，可能会觉得麻烦而放弃使用这些工具，失去了一次提升编程能力的好机会。</p><blockquote><p>本项目完整的代码托管在 <a class="link"   href="https://github.com/XPoet/vite-vue3-starter" >GitHub 仓库<i class="fas fa-external-link-alt"></i></a>，有需要的同学可以去下载下来，参考学习。<br><a class="link"   href="https://github.com/XPoet/vite-vue3-starter" >点亮小星星 🌟 支持作者~<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="提交规范"><a href="#提交规范" class="headerlink" title="提交规范"></a>提交规范</h2><p>前面我们已经统一代码规范，并且在提交代码时进行强约束来保证仓库代码质量。多人协作的项目中，在提交代码这个环节，也存在一种情况：不能保证每个人对提交信息的准确描述，因此会出现提交信息紊乱、风格不一致的情况。</p><p>如果 <code>git commit</code> 的描述信息精准，在后期维护和 Bug 处理时会变得有据可查，项目开发周期内还可以根据规范的提交信息快速生成开发日志，从而方便我们追踪项目和把控进度。</p><p>这里，我们使用社区最流行、最知名、最受认可的 Angular 团队提交规范。</p><p>先看看 <a class="link"   href="https://github.com/angular/angular/commits/master" >Angular 项目的提交记录<i class="fas fa-external-link-alt"></i></a>：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.3c8hrngc5aq0.png"                        alt="image"                 ></p><p>如上图，可以看出这些提交信息都是有固定格式的，下面我们来学习 Angular 规范的 commit message 格式。</p><h3 id="commit-message-格式规范"><a href="#commit-message-格式规范" class="headerlink" title="commit message 格式规范"></a>commit message 格式规范</h3><p>commit message 由 Header、Body、Footer 组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Header&gt;</span><br><span class="line"></span><br><span class="line">&lt;Body&gt;</span><br><span class="line"></span><br><span class="line">&lt;Footer&gt;</span><br></pre></td></tr></table></figure><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>Header 部分包括三个字段 type（必需）、scope（可选）和 subject（必需）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>type 用于说明 commit 的提交类型（必须是以下几种之一）。</p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">feat</td><td align="left">新增一个功能</td></tr><tr><td align="left">fix</td><td align="left">修复一个 Bug</td></tr><tr><td align="left">docs</td><td align="left">文档变更</td></tr><tr><td align="left">style</td><td align="left">代码格式（不影响功能，例如空格、分号等格式修正）</td></tr><tr><td align="left">refactor</td><td align="left">代码重构</td></tr><tr><td align="left">perf</td><td align="left">改善性能</td></tr><tr><td align="left">test</td><td align="left">测试</td></tr><tr><td align="left">build</td><td align="left">变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）</td></tr><tr><td align="left">ci</td><td align="left">更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等</td></tr><tr><td align="left">chore</td><td align="left">变更构建流程或辅助工具</td></tr><tr><td align="left">revert</td><td align="left">代码回退</td></tr></tbody></table><h5 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h5><p>scope 用于指定本次 commit 影响的范围。scope 依据项目而定，例如在业务项目中可以依据菜单或者功能模块划分，如果是组件库开发，则可以依据组件划分。（scope 可省略）</p><h5 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h5><p>subject 是本次 commit 的简洁描述，长度约定在 50 个字符以内，通常遵循以下几个规范：</p><ul><li>用动词开头，第一人称现在时表述，例如：change 代替 changed 或 changes</li><li>第一个字母小写</li><li>结尾不加句号（.）</li></ul><h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><p>body 是对本次 commit 的详细描述，可以分成多行。（body 可省略）</p><p>跟 subject 类似，用动词开头，body 应该说明修改的原因和更改前后的行为对比。</p><h4 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h4><p>如果本次提交的代码是突破性的变更或关闭缺陷，则 Footer 必需，否则可以省略。</p><ul><li><p>突破性的变更</p><p>当前代码与上一个版本有突破性改变，则 Footer 以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动的理由。</p></li><li><p>关闭缺陷</p><p>如果当前提交是针对特定的 issue，那么可以在 Footer 部分填写需要关闭的单个 issue 或一系列 issues。</p></li></ul><h4 id="参考例子"><a href="#参考例子" class="headerlink" title="参考例子"></a>参考例子</h4><ul><li><p>feat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">feat(browser): onUrlChange event (popstate/hashchange/polling)</span><br><span class="line"></span><br><span class="line">Added new event to browser:</span><br><span class="line">- forward popstate event if available</span><br><span class="line">- forward hashchange event if popstate not available</span><br><span class="line">- do polling when neither popstate nor hashchange available</span><br><span class="line"></span><br><span class="line">Breaks $browser.onHashChange, which was removed (use onUrlChange instead)</span><br></pre></td></tr></table></figure></li><li><p>fix</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fix(compile): couple of unit tests for IE9</span><br><span class="line"></span><br><span class="line">Older IEs serialize html uppercased, but IE9 does not...</span><br><span class="line">Would be better to expect case insensitive, unfortunately jasmine does</span><br><span class="line">not allow to user regexps for throw expectations.</span><br><span class="line"></span><br><span class="line">Closes #392</span><br><span class="line">Breaks foo.bar api, foo.baz should be used instead</span><br></pre></td></tr></table></figure></li><li><p>style</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style(location): add couple of missing semi colons</span><br></pre></td></tr></table></figure></li><li><p>chore</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chore(release): v3.4.2</span><br></pre></td></tr></table></figure></li></ul><h4 id="规范-commit-message-的好处"><a href="#规范-commit-message-的好处" class="headerlink" title="规范 commit message 的好处"></a>规范 commit message 的好处</h4><ul><li>首行就是简洁实用的关键信息，方便在 git history 中快速浏览。</li><li>具有更加详细的 body 和 footer，可以清晰的看出某次提交的目的和影响。</li><li>可以通过 type 过滤出想要查找的信息，也可以通过关键字快速查找相关提交。</li><li>可以直接从 commit 生成 change log。</li></ul><h3 id="集成-Commitizen-实现规范提交"><a href="#集成-Commitizen-实现规范提交" class="headerlink" title="集成 Commitizen 实现规范提交"></a>集成 Commitizen 实现规范提交</h3><p>上面介绍了 Angular 规范提交的格式，初次接触的同学咋一看可能会觉得复杂，其实不然，如果让大家在 <code>git commit</code> 的时候严格按照上面的格式来写，肯定是有压力的，首先得记住不同的类型到底是用来定义什么，subject 怎么写，body 怎么写，footer 要不要写等等问题，懒才是程序员第一生产力，为此我们使用 Commitizen 工具来帮助我们自动生成 commit message 格式，从而实现规范提交。</p><blockquote><p>Commitizen 是一个帮助撰写规范 commit message 的工具。它有一个命令行工具 cz-cli。</p></blockquote><h4 id="安装-Commitizen"><a href="#安装-Commitizen" class="headerlink" title="安装 Commitizen"></a>安装 Commitizen</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commitizen -D</span><br></pre></td></tr></table></figure><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>成功安装 Commitizen 后，我们用 <strong>cz-conventional-changelog</strong> 适配器来初始化项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx commitizen init cz-conventional-changelog --save-dev --save-exact</span><br></pre></td></tr></table></figure><p>这行命令做了两件事：</p><ul><li>安装 cz-conventional-changelog 到开发依赖（devDependencies）</li><li>在 <code>package.json</code> 中增加了 <code>config.commitizen</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;config&quot;: &#123;</span><br><span class="line">  &quot;commitizen&quot;: &#123;</span><br><span class="line">    &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.2au710lnmrrw.png"                        alt="image"                 ></li></ul><h4 id="使用-Commitizen"><a href="#使用-Commitizen" class="headerlink" title="使用 Commitizen"></a>使用 Commitizen</h4><p>以前我们提交代码都是 <code>git commit -m &quot;xxx&quot;</code>，现在改为 <code>git cz</code>，然后按照终端操作提示，逐步填入信息，就能自动生成规范的 commit message。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.1y6p85zepj4w.png"                        alt="image"                 ><br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.52xl0rolt5k0.png"                        alt="image"                 ></p><p>最后，在 Git 提交历史中就能看到刚刚规范的提交记录了：<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.6p9fdr6rupo0.png"                        alt="image"                 ></p><h4 id="自定义配置提交说明"><a href="#自定义配置提交说明" class="headerlink" title="自定义配置提交说明"></a>自定义配置提交说明</h4><p>从上面的截图可以看到，<code>git cz</code> 终端操作提示都是英文的，如果想改成中文的或者自定义这些配置选项，我们使用 <strong>cz-customizable</strong> 适配器。</p><h5 id="cz-customizable-初始化项目"><a href="#cz-customizable-初始化项目" class="headerlink" title="cz-customizable 初始化项目"></a>cz-customizable 初始化项目</h5><p>运行如下命令使用 cz-customizable 初始化项目，注意之前已经初始化过一次，这次再初始化，需要加 <code>--force</code> 覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx commitizen init cz-customizable --save-dev --save-exact --force</span><br></pre></td></tr></table></figure><p>这行命令做了两件事：</p><ul><li><p>安装 cz-customizable 到开发依赖（devDependencies）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;cz-customizable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.3.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li><li><p>修改 <code>package.json</code> 中的 <code>config.commitizen</code> 字段为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;commitizen&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./node_modules/cz-customizable&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="使用-cz-customizable"><a href="#使用-cz-customizable" class="headerlink" title="使用 cz-customizable"></a>使用 cz-customizable</h5><p>在项目根目录下创建 <code>.cz-config.js</code> 文件，然后按照官方提供的<a class="link"   href="https://github.com/leoforfree/cz-customizable/blob/master/cz-config-EXAMPLE.js" >示例<i class="fas fa-external-link-alt"></i></a>来配置。</p><p>在本项目中我们修改成中文：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// type 类型（定义之后，可通过上下键选择）</span></span><br><span class="line">  <span class="attr">types</span>: [</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;feat&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;feat:     新增功能&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;fix&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;fix:      修复 bug&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;docs&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;docs:     文档变更&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;style&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;style:    代码格式（不影响功能，例如空格、分号等格式修正）&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;refactor&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;refactor: 代码重构（不包括 bug 修复、功能新增）&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;perf&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;perf:     性能优化&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;test&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;test:     添加、修改测试用例&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;build&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;build:    构建流程、外部依赖变更（如升级 npm 包、修改 webpack 配置等）&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;ci&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;ci:       修改 CI 配置、脚本&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;chore&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;chore:    对构建过程或辅助工具和库的更改（不影响源文件、测试用例）&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;revert&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;revert:   回滚 commit&#x27;</span> &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scope 类型（定义之后，可通过上下键选择）</span></span><br><span class="line">  <span class="attr">scopes</span>: [</span><br><span class="line">    [<span class="string">&#x27;components&#x27;</span>, <span class="string">&#x27;组件相关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;hooks&#x27;</span>, <span class="string">&#x27;hook 相关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;utils&#x27;</span>, <span class="string">&#x27;utils 相关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;element-ui&#x27;</span>, <span class="string">&#x27;对 element-ui 的调整&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;styles&#x27;</span>, <span class="string">&#x27;样式相关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;deps&#x27;</span>, <span class="string">&#x27;项目依赖&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;auth&#x27;</span>, <span class="string">&#x27;对 auth 修改&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;other&#x27;</span>, <span class="string">&#x27;其他修改&#x27;</span>],</span><br><span class="line">    <span class="comment">// 如果选择 custom，后面会让你再输入一个自定义的 scope。也可以不设置此项，把后面的 allowCustomScopes 设置为 true</span></span><br><span class="line">    [<span class="string">&#x27;custom&#x27;</span>, <span class="string">&#x27;以上都不是？我要自定义&#x27;</span>]</span><br><span class="line">  ].<span class="title function_">map</span>(<span class="function">(<span class="params">[value, description]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">`<span class="subst">$&#123;value.padEnd(<span class="number">30</span>)&#125;</span> (<span class="subst">$&#123;description&#125;</span>)`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否允许自定义填写 scope，在 scope 选择的时候，会有 empty 和 custom 可以选择。</span></span><br><span class="line">  <span class="comment">// allowCustomScopes: true,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// allowTicketNumber: false,</span></span><br><span class="line">  <span class="comment">// isTicketNumberRequired: false,</span></span><br><span class="line">  <span class="comment">// ticketNumberPrefix: &#x27;TICKET-&#x27;,</span></span><br><span class="line">  <span class="comment">// ticketNumberRegExp: &#x27;\\d&#123;1,5&#125;&#x27;,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对每一个 type 去定义对应的 scopes，例如 fix</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  scopeOverrides: &#123;</span></span><br><span class="line"><span class="comment">    fix: [</span></span><br><span class="line"><span class="comment">      &#123; name: &#x27;merge&#x27; &#125;,</span></span><br><span class="line"><span class="comment">      &#123; name: &#x27;style&#x27; &#125;,</span></span><br><span class="line"><span class="comment">      &#123; name: &#x27;e2eTest&#x27; &#125;,</span></span><br><span class="line"><span class="comment">      &#123; name: &#x27;unitTest&#x27; &#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交互提示信息</span></span><br><span class="line">  <span class="attr">messages</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;确保本次提交遵循 Angular 规范！\n选择你要提交的类型：&#x27;</span>,</span><br><span class="line">    <span class="attr">scope</span>: <span class="string">&#x27;\n选择一个 scope（可选）：&#x27;</span>,</span><br><span class="line">    <span class="comment">// 选择 scope: custom 时会出下面的提示</span></span><br><span class="line">    <span class="attr">customScope</span>: <span class="string">&#x27;请输入自定义的 scope：&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;填写简短精炼的变更描述：\n&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>:</span><br><span class="line">      <span class="string">&#x27;填写更加详细的变更描述（可选）。使用 &quot;|&quot; 换行：\n&#x27;</span>,</span><br><span class="line">    <span class="attr">breaking</span>: <span class="string">&#x27;列举非兼容性重大的变更（可选）：\n&#x27;</span>,</span><br><span class="line">    <span class="attr">footer</span>: <span class="string">&#x27;列举出所有变更的 ISSUES CLOSED（可选）。例如：#31, #34：\n&#x27;</span>,</span><br><span class="line">    <span class="attr">confirmCommit</span>: <span class="string">&#x27;确认提交？&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置只有 type 选择了 feat 或 fix，才询问 breaking message</span></span><br><span class="line">  <span class="attr">allowBreakingChanges</span>: [<span class="string">&#x27;feat&#x27;</span>, <span class="string">&#x27;fix&#x27;</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳过要询问的步骤</span></span><br><span class="line">  <span class="comment">// skipQuestions: [&#x27;body&#x27;, &#x27;footer&#x27;],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// subject 限制长度</span></span><br><span class="line">  <span class="attr">subjectLimit</span>: <span class="number">100</span></span><br><span class="line">  <span class="attr">breaklineChar</span>: <span class="string">&#x27;|&#x27;</span>, <span class="comment">// 支持 body 和 footer</span></span><br><span class="line">  <span class="comment">// footerPrefix : &#x27;ISSUES CLOSED:&#x27;</span></span><br><span class="line">  <span class="comment">// askForBreakingChangeFirst : true,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议大家结合项目实际情况来自定义配置提交规则，例如很多时候我们不需要写长描述，公司内部的代码仓库也不需要管理 issue，那么可以把询问 body 和 footer 的步骤跳过（在 <code>.cz-config.js</code> 中修改成 <code>skipQuestions: [&#39;body&#39;, &#39;footer&#39;]</code>）。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.4ko1hj86bno0.png"                        alt="image"                 ></p><h3 id="集成-commitlint-验证提交规范"><a href="#集成-commitlint-验证提交规范" class="headerlink" title="集成 commitlint 验证提交规范"></a>集成 commitlint 验证提交规范</h3><p>在“代码规范”章节，我们已经讲到过，尽管制定了规范，但在多人协作的项目中，总有些人依旧我行我素，因此提交代码这个环节，我们也增加一个限制：<strong>只让符合 Angular 规范的 commit message 通过</strong>，我们借助 @commitlint&#x2F;config-conventional 和 @commitlint&#x2F;cli 来实现。</p><h4 id="安装-commitlint"><a href="#安装-commitlint" class="headerlink" title="安装 commitlint"></a>安装 commitlint</h4><p>安装 @commitlint&#x2F;config-conventional 和 @commitlint&#x2F;cli</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @commitlint/config-conventional @commitlint/cli -D</span><br></pre></td></tr></table></figure><h4 id="配置-commitlint"><a href="#配置-commitlint" class="headerlink" title="配置 commitlint"></a>配置 commitlint</h4><ul><li><p>创建 commitlint.config.js 文件<br>在项目根目录下创建 <code>commitlint.config.js</code> 文件，并填入以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; <span class="attr">extends</span>: [<span class="string">&#x27;@commitlint/config-conventional&#x27;</span>] &#125;</span><br></pre></td></tr></table></figure><p>或直接使用快捷命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot;</span> &gt; commitlint.config.js</span><br></pre></td></tr></table></figure></li><li><p>使用 husky 的 <code>commit-msg</code> hook 触发验证提交信息的命令<br>我们使用 husky 命令在 <code>.husky</code> 目录下创建 <code>commit-msg</code> 文件，并在此执行 commit message 的验证命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/commit-msg <span class="string">&quot;npx --no-install commitlint --edit <span class="variable">$1</span>&quot;</span></span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.1it1cslfjt6o.png"                        alt="image"                 ></p></li></ul><h4 id="commitlint-验证"><a href="#commitlint-验证" class="headerlink" title="commitlint 验证"></a>commitlint 验证</h4><ul><li><p>不符合规范的提交信息<br>如下图，提交信息 <code>test commitlint</code> 不符合规范，提交失败。<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.7ijz5vyl4040.png"                        alt="image"                 ></p></li><li><p>符合规范的提交信息<br>如下图，提交信息 <code>test: commitlint test</code> 符合规范，成功提交到仓库。<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.6s0vj74uz8g0.png"                        alt="image"                 ></p></li></ul><p>因为已在项目中集成 commitizen，建议大家用 <code>git cz</code> 来代替 <code>git commit</code> 提交代码，可以保证提交信息规范。</p><blockquote><p>本项目完整的代码托管在 <a class="link"   href="https://github.com/XPoet/vite-vue3-starter" >GitHub 仓库<i class="fas fa-external-link-alt"></i></a>，同学可以去下载下来，参考学习。<br><a class="link"   href="https://github.com/XPoet/vite-vue3-starter" >点亮小星星 🌟 支持作者~<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试是项目开发中一个非常重要的环节，完整的测试能为代码和业务提供质量保证，减少 Bug 的出现。</p><p>本章节将带领大家在 Vite + Vue3 + TypeScript 的项目中集成单元测试工具。</p><h3 id="安装核心依赖"><a href="#安装核心依赖" class="headerlink" title="安装核心依赖"></a>安装核心依赖</h3><p>我们使用 Vue 官方提供的 <strong>vue-test-utils</strong> 和社区流行的测试工具 <strong>jest</strong> 来进行 Vue 组件的单元测试。</p><ul><li><strong><a class="link"   href="https://github.com/vuejs/vue-test-utils-next" >vue-test-utils<i class="fas fa-external-link-alt"></i></a></strong> The next iteration of Vue Test Utils. It targets Vue 3.</li><li><strong><a class="link"   href="https://github.com/facebook/jest" >jest<i class="fas fa-external-link-alt"></i></a></strong> Delightful JavaScript Testing.</li><li><strong><a class="link"   href="https://github.com/vuejs/vue-jest" >vue-jest<i class="fas fa-external-link-alt"></i></a></strong> Jest Vue transformer</li><li><strong><a class="link"   href="https://github.com/kulshekhar/ts-jest" >ts-jest<i class="fas fa-external-link-alt"></i></a></strong> A Jest transformer with source map support that lets you use Jest to test projects written in TypeScript.</li></ul><p>安装这些工具为开发依赖（devDependencies）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @vue/test-utils@next jest vue-jest@next ts-jest -D</span><br></pre></td></tr></table></figure><h3 id="创建-jest-配置文件"><a href="#创建-jest-配置文件" class="headerlink" title="创建 jest 配置文件"></a>创建 jest 配置文件</h3><p>在项目根目录下新建 <code>jest.config.js</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">moduleFileExtensions</span>: [<span class="string">&#x27;vue&#x27;</span>, <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;ts&#x27;</span>],</span><br><span class="line">  <span class="attr">preset</span>: <span class="string">&#x27;ts-jest&#x27;</span>,</span><br><span class="line">  <span class="attr">testEnvironment</span>: <span class="string">&#x27;jsdom&#x27;</span>,</span><br><span class="line">  <span class="attr">transform</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^.+\\.vue$&#x27;</span>: <span class="string">&#x27;vue-jest&#x27;</span>, <span class="comment">// vue 文件用 vue-jest 转换</span></span><br><span class="line">    <span class="string">&#x27;^.+\\.ts$&#x27;</span>: <span class="string">&#x27;ts-jest&#x27;</span> <span class="comment">// ts 文件用 ts-jest 转换</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 匹配 __tests__ 目录下的 .js/.ts 文件 或其他目录下的 xx.test.js/ts xx.spec.js/ts</span></span><br><span class="line">  <span class="attr">testRegex</span>: <span class="string">&#x27;(/__tests__/.*|(\\.|/)(test|spec))\\.(ts)$&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建单元测试文件"><a href="#创建单元测试文件" class="headerlink" title="创建单元测试文件"></a>创建单元测试文件</h3><p>在上面的 <code>jest.config.js</code> 文件中，我们配置只匹配 <code>__tests__</code> 目录下的任意 <code>.ts</code> 文件或其他目录下的 <code>xx.test.ts</code>&#x2F;<code>xx.spec.ts</code> 文件进行单元测试。</p><p>这里，我们在项目根目录下创建 <code>tests</code> 目录来存储单元测试文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── src/</span><br><span class="line">└── tests/                           // 单元测试目录</span><br><span class="line">    ├── Test.spec.ts                 // Test 组件测试</span><br></pre></td></tr></table></figure><ul><li><code>Test.vue</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test-container page-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-title&quot;</span>&gt;</span>Unit Test Page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&#x27;Vuex&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> count = ref&lt;number&gt;(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        count.<span class="property">value</span> += <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123; count, increment &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>Test.spec.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Test</span> <span class="keyword">from</span> <span class="string">&#x27;../src/views/Test.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;Test.vue&#x27;</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = <span class="title function_">mount</span>(<span class="title class_">Test</span>)</span><br><span class="line">  <span class="title function_">expect</span>(wrapper.<span class="title function_">html</span>()).<span class="title function_">toContain</span>(<span class="string">&#x27;Unit Test Page&#x27;</span>)</span><br><span class="line">  <span class="title function_">expect</span>(wrapper.<span class="title function_">html</span>()).<span class="title function_">toContain</span>(<span class="string">&#x27;count is: 0&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> wrapper.<span class="title function_">find</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">trigger</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  <span class="title function_">expect</span>(wrapper.<span class="title function_">html</span>()).<span class="title function_">toContain</span>(<span class="string">&#x27;count is: 1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="集成-types-x2F-jest"><a href="#集成-types-x2F-jest" class="headerlink" title="集成 @types&#x2F;jest"></a>集成 @types&#x2F;jest</h3><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.2pg6u5vxed40.png"                        alt="image"                 ></p><p>如上图，我们使用 VSCode &#x2F; WebStrom &#x2F; IDEA 等编辑器时，在单元测试文件中，IDE 会提示某些方法不存在（如 <code>test</code>、<code>describe</code>、<code>it</code>、<code>expect</code>等），安装 @types&#x2F;jest 即可解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @types/jest -D</span><br></pre></td></tr></table></figure><p>TypeScript 的编译器也会提示 jest 的方法和类型找不到，我们还需把 @types&#x2F;jest 添加根目录下的 <code>ts.config.json</code>（TypeScript 配置文件）中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;vite/client&quot;</span><span class="punctuation">,</span> <span class="string">&quot;jest&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="添加-eslint-plugin-jest"><a href="#添加-eslint-plugin-jest" class="headerlink" title="添加 eslint-plugin-jest"></a>添加 eslint-plugin-jest</h3><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.5qxi97b658g0.png"                        alt="image"                 ></p><p>因为我们在项目中集成了 ESLint，如上图很明显是没通过 ESLint 规则检验。因此，我们还需要在 ESLint 中增加 <strong>eslint-plugin-jest</strong> 插件来解除对 jest 的校验。</p><ul><li><p>安装 eslint-plugin-jest</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint-plugin-jest -D</span><br></pre></td></tr></table></figure></li><li><p>添加 eslint-plugin-jest 到 ESLint 配置文件 <code>.eslintrc.js</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;plugin:jest/recommended&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>现在，我们的单元测试代码就不会有错误提示信息了 ؏؏☝ᖗ 乛 ◡ 乛 ᖘ☝؏؏</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.73c0vuyso1g0.png"                        alt="image"                 ></p><h3 id="执行单元测试"><a href="#执行单元测试" class="headerlink" title="执行单元测试"></a>执行单元测试</h3><p>在根目录下 <code>package.json</code> 文件的 <code>scripts</code> 中，添加一条单元测试命令： <code>&quot;test&quot;: &quot;jest&quot;</code>。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.7aqv17602lw0.png"                        alt="image"                 ></p><p>执行命令 <code>npm run test</code> 即可进行单元测试，jest 会根据 <code>jest.config.js</code> 配置文件去查找 <code>__tests__</code> 目录下的 <code>.ts</code> 文件或其他任意目录下的 <code>.spec.ts</code> 和 <code>.test.ts</code> 文件，然后执行单元测试方法。</p><blockquote><p>你可以在 <code>jest.config.js</code> 配置文件中，自由配置单元测试文件的目录。</p></blockquote><ul><li><p>单元测试全部通过时的终端显示信息<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.735bufa0bj80.png"                        alt="image"                 ></p></li><li><p>单元测试未全部通过时的终端显示信息<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.72989ryb2yw0.png"                        alt="image"                 ></p></li></ul><p>当单元测试没有全部通过时，我们需要根据报错信息去优化对应组件的代码，进一步提高项目健壮性。但是写单元测试是件比较痛苦的事，我个人觉得也没必要全部组件都写单元测试，根据项目实际情况有针对性去写就行了。</p><h3 id="单元测试约束"><a href="#单元测试约束" class="headerlink" title="单元测试约束"></a>单元测试约束</h3><p>前面，我们使用 husky 在 Git 的 <code>pre-commit</code> 和 <code>commit-msg</code> 阶段分别约束代码风格规范和提交信息规范。这一步，我们在 <code>pre-push</code> 阶段进行单元测试，只有单元测试全部通过才让代码 <code>push</code> 到远端仓库，否则终止 <code>push</code>。</p><p>使用 husky 命令在 <code>.husky</code> 目录下自动创建 <code>pre-push</code> hook 文件，并在此执行单元测试命令 <code>npm run test</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-push &quot;npm run test $1&quot;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.2lmc92of0ak0.png"                        alt="image"                 ></p><p>现在，我们在 <code>git push</code> 时就能先进行单元测试了，只有单元测试全部通过，才能成功 <code>push</code>。</p><blockquote><p>本项目完整的代码托管在 <a class="link"   href="https://github.com/XPoet/vite-vue3-starter" >GitHub 仓库<i class="fas fa-external-link-alt"></i></a>，同学可以去下载下来，参考学习。<br><a class="link"   href="https://github.com/XPoet/vite-vue3-starter" >点亮小星星 🌟 支持作者~<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><p>到了这一步，我们已经在项目中集成<strong>代码规范约束</strong>、<strong>提交信息规范约束</strong>，<strong>单元测试约束</strong>，从而保证我们远端仓库（如 GitHub、GitLab、Gitee 仓库等）的代码都是高质量的。</p><p>本项目是要搭建一套规范的前端工程化环境，为此我们使用 CI（Continuous Integration 持续集成）来完成项目最后的部署工作。</p><p>常见的 CI 工具有 GitHub Actions、GitLab CI、Travis CI、Circle CI 等。</p><p>这里，我们使用 GitHub Actions。</p><h3 id="什么是-GitHub-Actions"><a href="#什么是-GitHub-Actions" class="headerlink" title="什么是 GitHub Actions"></a>什么是 GitHub Actions</h3><p>GitHub Actions 是 GitHub 的持续集成服务，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器、发布到第三方服务等等，GitHub 把这些操作称为 actions。</p><h3 id="配置-GitHub-Actions"><a href="#配置-GitHub-Actions" class="headerlink" title="配置 GitHub Actions"></a>配置 GitHub Actions</h3><h4 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 GitHub 仓库</h4><p>因为 GitHub Actions 只对 GitHub 仓库有效，所以我们<a class="link"   href="https://github.com/new" >创建 GitHub 仓库<i class="fas fa-external-link-alt"></i></a>来托管项目代码。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.5m6a0jmmx140.png"                        alt="image"                 ></p><p>其中，我们用：</p><ul><li><code>master</code> 分支存储项目源代码</li><li><code>gh-pages</code> 分支存储打包后的静态文件</li></ul><blockquote><p><code>gh-pages</code> 分支，是 GitHub Pages 服务的固定分支，可以通过 HTTP 的方式访问到这个分支的静态文件资源。</p></blockquote><h4 id="创建-GitHub-Token"><a href="#创建-GitHub-Token" class="headerlink" title="创建 GitHub Token"></a>创建 GitHub Token</h4><p>创建一个有 <strong>repo</strong> 和 <strong>workflow</strong> 权限的 <a class="link"   href="https://github.com/settings/tokens/new" >GitHub Token<i class="fas fa-external-link-alt"></i></a></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.635qmlsgjtc0.png"                        alt="image"                 ></p><p>注意：新生成的 Token 只会显示一次，保存起来，后面要用到。如有遗失，重新生成即可。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.vbmix82c9n4.png"                        alt="image"                 ></p><h4 id="在仓库中添加-secret"><a href="#在仓库中添加-secret" class="headerlink" title="在仓库中添加 secret"></a>在仓库中添加 secret</h4><p>将上面新创建的 Token 添加到 GitHub 仓库的 <code>Secrets</code> 里，并将这个新增的 <code>secret</code> 命名为 <code>VUE3_DEPLOY</code> （名字无所谓，看你喜欢）。</p><p>步骤：仓库 -&gt; <code>settings</code> -&gt; <code>Secrets</code> -&gt; <code>New repository secret</code>。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.3eww17h7c7c0.png"                        alt="image"                 ></p><blockquote><p>新创建的 secret <code>VUE3_DEPLOY</code> 在 Actions 配置文件中要用到，两个地方需保持一致！</p></blockquote><h4 id="创建-Actions-配置文件"><a href="#创建-Actions-配置文件" class="headerlink" title="创建 Actions 配置文件"></a>创建 Actions 配置文件</h4><ol><li>在项目根目录下创建 <code>.github</code> 目录。</li><li>在 <code>.github</code> 目录下创建 <code>workflows</code> 目录。</li><li>在 <code>workflows</code> 目录下创建 <code>deploy.yml</code> 文件。</li></ol><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/vite-vue3/image.1rjxbhvs2dcw.png"                        alt="image"                 ></p><p><code>deploy.yml</code> 文件的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">master</span>] <span class="comment"># master 分支有 push 时触发</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span> <span class="string">v14.x</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;14.x&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 安装依赖</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="comment"># 打包</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span> <span class="comment"># 使用部署到 GitHub pages 的 action</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./dist</span> <span class="comment"># 部署打包后的 dist 目录</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.VUE3_DEPLOY</span> <span class="string">&#125;&#125;</span> <span class="comment"># secret 名</span></span><br><span class="line">          <span class="attr">user_name:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MY_USER_NAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">user_email:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MY_USER_EMAIL</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">commit_message:</span> <span class="string">Update</span> <span class="string">Vite2.x</span> <span class="string">+</span> <span class="string">Vue3.x</span> <span class="string">+</span> <span class="string">TypeScript</span> <span class="string">Starter</span> <span class="comment"># 部署时的 git 提交信息，自由填写</span></span><br></pre></td></tr></table></figure><h3 id="自动部署触发原理"><a href="#自动部署触发原理" class="headerlink" title="自动部署触发原理"></a>自动部署触发原理</h3><p>当有新提交的代码 <code>push</code> 到 GitHub 仓库时，就会触发 GitHub Actions，在 GitHub 服务器上执行 Action 配置文件里面的命令，例如：<strong>安装依赖</strong>、<strong>项目打包</strong>等，然后将打包好的静态文件部署到 GitHub Pages 上，最后，我们就能通过域名访问了。</p><blockquote><p>🌏 通过域名 <a class="link"   href="https://vite-vue3-starter.xpoet.cn/" >https://vite-vue3-starter.xpoet.cn/<i class="fas fa-external-link-alt"></i></a> 访问本项目</p></blockquote><p>使用自动部署，我们只需专注于项目开发阶段，任何重复且枯燥的行为都交由程序去完成，懒才是程序员第一生产力。</p><p>事实上，自动部署只是 GitHub Actions 功能的冰山一角，GitHub Actions 能做的事还很多很多，大家感兴趣的话自行查阅。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文从技术选项到架构搭建、从代码规范约束到提交信息规范约束，从单元测试到自动部署，一步一步带领大家如何从一个最简单的前端项目骨架到规范的前端工程化环境，基本上涵盖了前端项目开发的整个流程。</p><p>因篇幅较长，所涉及技术点较多，难免会出现错误，希望大家多多指正，谢谢大家！</p><hr><p><img                         lazyload                       alt="image"                       data-src="/images/fp/fp-slogan.webp"                        alt="FP"                 ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vue3 跟 Vite 正式版发布有很长一段时间了，生态圈也渐渐丰富起来，作者已在多个项目中使用，总结一下：就是快！也不用担心稳定性问题，开发体验真不是一般好！还没尝试的同学可以从本文开始学习，从 0 开始手把手带你搭建一套规范的 Vite + Vue3 + TypeScript 前端工程化项目环境。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://xpoet.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="https://xpoet.cn/tags/Vue/"/>
    
    <category term="Vite" scheme="https://xpoet.cn/tags/Vite/"/>
    
    <category term="前端工程化" scheme="https://xpoet.cn/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化入门</title>
    <link href="https://xpoet.cn/post/936c9599737d/"/>
    <id>https://xpoet.cn/post/936c9599737d/</id>
    <published>2021-03-16T10:20:16.000Z</published>
    <updated>2023-12-01T07:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文带你入门前端工程化，分为 7 个小节讲解：</p><ul><li>技术选型</li><li>统一规范</li><li>测试</li><li>部署</li><li>监控</li><li>性能优化</li><li>重构</li></ul><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>对于前端工程师来说，技术选型挺简单的，就是做选择题，三大框架中选一个。个人认为可以依据以下两个特点来选：</p><ol><li>选你或团队最熟的，保证在遇到棘手的问题时有人能填坑。</li><li>选市场占有率高的。换句话说，就是选好招人的。</li></ol><p>第二点对于小公司来说，特别重要。本来小公司就不好招人，要是还选一个市场占有率不高的框架（例如 Angular），简历你都看不到几个…</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.epcwhdte5js.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.epcwhdte5js.png"                        alt="image"                 ></p><p>UI 组件库更简单，github 上哪个 star 多就用哪个。star 多，说明用的人就多，很多坑别人都替你踩过了，省事。</p><h2 id="统一规范"><a href="#统一规范" class="headerlink" title="统一规范"></a>统一规范</h2><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>先来看看统一代码规范的好处：</p><ul><li>规范的代码可以促进团队合作</li><li>规范的代码可以降低维护成本</li><li>规范的代码有助于 code review（代码审查）</li><li>养成代码规范的习惯，有助于程序员自身的成长</li></ul><p>当团队的成员都严格按照代码规范来写代码时，可以保证每个人的代码看起来都像是一个人写的，看别人的代码就像是在看自己的代码。更重要的是我们能够认识到规范的重要性，并坚持规范的开发习惯。</p><h4 id="如何制订代码规范"><a href="#如何制订代码规范" class="headerlink" title="如何制订代码规范"></a>如何制订代码规范</h4><p>建议找一份好的代码规范，在此基础上结合团队的需求作个性化修改。</p><p>下面列举一些 star 较多的 js 代码规范：</p><ul><li><a class="link"   href="https://github.com/airbnb/javascript" >airbnb（英文版）<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/lin-123/javascript" >airbnb（中文版）<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/standard/standard/blob/master/docs/README-zhcn.md" >standard (中文版) <i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/ecomfe/spec" >百度前端编码规范<i class="fas fa-external-link-alt"></i></a></li></ul><p>CSS 代码规范也有不少，例如：</p><ul><li><a class="link"   href="https://github.com/fex-team/styleguide/blob/master/css.md" >styleguide<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/ecomfe/spec/blob/master/css-style-guide.md" >spec<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="如何检查代码规范"><a href="#如何检查代码规范" class="headerlink" title="如何检查代码规范"></a>如何检查代码规范</h4><p>使用 eslint 可以检查代码符不符合团队制订的规范，下面来看一下如何配置 eslint 来检查代码。</p><ol><li>下载依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// eslint-config-airbnb-base 使用 airbnb 代码规范</span><br><span class="line">npm i -D babel-eslint eslint eslint-config-airbnb-base eslint-plugin-import</span><br></pre></td></tr></table></figure><ol><li>配置 .eslintrc 文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;parserOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ecmaVersion&quot;</span><span class="punctuation">:</span> <span class="number">2019</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;es6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parser&quot;</span><span class="punctuation">:</span> <span class="string">&quot;babel-eslint&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;airbnb-base&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol><li>在 <code>package.json</code> 的 <code>scripts</code> 加上这行代码 <code>&quot;lint&quot;: &quot;eslint --ext .js test/ src/&quot;</code>。然后执行 <code>npm run lint</code> 即可开始验证代码。代码中的 <code>test/ src/</code> 是指你要进行校验的代码目录，这里指明了要检查 <code>test</code>、<code>src</code> 目录下的代码。</li></ol><p>不过这样检查代码效率太低，每次都得手动检查。并且报错了还得手动修改代码。</p><p>为了改善以上缺点，我们可以使用 VSCode。使用它并加上适当的配置可以在每次保存代码的时候，自动验证代码并进行格式化，省去了动手的麻烦。</p><p>css 检查代码规范则使用 <code>stylelint</code> 插件。</p><p>由于篇幅有限，具体如何配置请看我的另一篇文章 <a class="link"   href="https://juejin.cn/post/6892000216020189198/" >ESlint + stylelint + VSCode 自动格式化代码 (2020)<i class="fas fa-external-link-alt"></i></a>。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/fe.1yceth8ay01s.gif"                        alt="fe"                 ></p><h3 id="git-规范"><a href="#git-规范" class="headerlink" title="git 规范"></a>git 规范</h3><p>git 规范包括两点：分支管理规范、git commit 规范。</p><h4 id="分支管理规范"><a href="#分支管理规范" class="headerlink" title="分支管理规范"></a>分支管理规范</h4><p>一般项目分主分支（master）和其他分支。<br>当有团队成员要开发新功能或改 BUG 时，就从 master 分支开一个新的分支。例如项目要从客户端渲染改成服务端渲染，就开一个分支叫 ssr，开发完了再合并回 master 分支。<br>如果改一个 BUG，也可以从 master 分支开一个新分支，并用 BUG 号命名（不过我们小团队嫌麻烦，没这样做，除非有特别大的 BUG）。</p><h4 id="git-commit-规范"><a href="#git-commit-规范" class="headerlink" title="git commit 规范"></a>git commit 规范</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>大致分为三个部分 (使用空行分割):</p><ul><li>标题行：必填，描述主要修改类型和内容</li><li>主题内容：描述为什么修改，做了什么样的修改，以及开发的思路等等</li><li>页脚注释：可以写注释，BUG 号链接</li></ul><h4 id="type-commit-的类型"><a href="#type-commit-的类型" class="headerlink" title="type: commit 的类型"></a>type: commit 的类型</h4><ul><li>feat: 新功能、新特性</li><li>fix: 修改 bug</li><li>perf: 更改代码，以提高性能</li><li>refactor: 代码重构（重构，在不影响代码内部行为、功能下的代码修改）</li><li>docs: 文档修改</li><li>style: 代码格式修改，注意不是 css 修改（例如分号修改）</li><li>test: 测试用例新增、修改</li><li>build: 影响项目构建或依赖项修改</li><li>revert: 恢复上一次提交</li><li>ci: 持续集成相关文件修改</li><li>chore: 其他修改（不在上述类型中的修改）</li><li>release: 发布新版本</li><li>workflow: 工作流相关文件修改</li></ul><ol><li>scope: commit 影响的范围，比如：route, component, utils, build…</li><li>subject: commit 的概述</li><li>body: commit 具体修改内容，可以分为多行。</li><li>footer: 一些备注，通常是 BREAKING CHANGE 或修复的 bug 的链接。</li></ol><p>示例：</p><ul><li><p>fix（修复 BUG）</p><p>如果修复的这个 BUG 只影响当前修改的文件，可不加范围。如果影响的范围比较大，要加上范围描述。</p><p>例如这次 BUG 修复影响到全局，可以加个 global。如果影响的是某个目录或某个功能，可以加上该目录的路径，或者对应的功能名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 示例 1</span><br><span class="line">fix(global): 修复 checkbox 不能复选的问题</span><br><span class="line"></span><br><span class="line">// 示例 2 下面圆括号里的 common 为通用管理的名称</span><br><span class="line">fix(common): 修复字体过小的 BUG，将通用管理下所有页面的默认字体大小修改为 14px</span><br><span class="line"></span><br><span class="line">// 示例 3</span><br><span class="line">fix: value.length -&gt; values.length</span><br></pre></td></tr></table></figure></li><li><p>feat（添加新功能或新页面）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feat: 添加网站主页静态页面</span><br><span class="line"></span><br><span class="line">这是一个示例，假设对点检任务静态页面进行了一些描述。</span><br><span class="line"></span><br><span class="line">这里是备注，可以是放 BUG 链接或者一些重要性的东西。</span><br></pre></td></tr></table></figure></li><li><p>chore（其他修改）</p><p>chore 的中文翻译为日常事务、例行工作，顾名思义，即不在其他 commit 类型中的修改，都可以用 chore 表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chore: 将表格中的查看详情改为详情</span><br></pre></td></tr></table></figure><p>其他类型的 commit 和上面三个示例差不多，就不说了。</p></li></ul><h4 id="验证-git-commit-规范"><a href="#验证-git-commit-规范" class="headerlink" title="验证 git commit 规范"></a>验证 git commit 规范</h4><p>验证 git commit 规范，主要通过 git 的 pre-commit 钩子函数来进行。当然，你还需要下载一个辅助工具来帮助你进行验证。</p><p>下载辅助工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D husky</span><br></pre></td></tr></table></figure><p>在 <code>package.json</code> 加上下面的代码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;husky&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;hooks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pre-commit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run lint&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;commit-msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node script/verify-commit.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pre-push&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm test&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后在你项目根目录下新建一个文件夹 script，并在下面新建一个文件 verify-commit.js，输入以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msgPath = process.<span class="property">env</span>.<span class="property">HUSKY_GIT_PARAMS</span>;</span><br><span class="line"><span class="keyword">const</span> msg = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).<span class="title function_">readFileSync</span>(msgPath, <span class="string">&quot;utf-8&quot;</span>).<span class="title function_">trim</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commitRE = <span class="regexp">/^(feat|fix|docs|style|refactor|perf|test|workflow|build|ci|chore|release|workflow)(\(.+\))?: .&#123;1,50&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!commitRE.<span class="title function_">test</span>(msg)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`</span></span><br><span class="line"><span class="string">        不合法的 commit 消息格式。</span></span><br><span class="line"><span class="string">        请查看 git commit 提交规范：https://github.com/woai3c/Front-end-articles/blob/master/git%20commit%20style.md</span></span><br><span class="line"><span class="string">    `</span>);</span><br><span class="line"></span><br><span class="line">  process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来解释下各个钩子的含义：</p><ol><li><p><code>&quot;pre-commit&quot;: &quot;npm run lint&quot;</code> 在 <code>git commit</code> 前执行 <code>npm run lint</code> 检查代码格式。</p></li><li><p><code>&quot;commit-msg&quot;: &quot;node script/verify-commit.js&quot;</code> 在 <code>git commit</code> 时执行脚本。verify-commit.js 验证 commit 消息。如果不符合脚本中定义的格式，将会报错。</p></li><li><p><code>&quot;pre-push&quot;: &quot;npm test&quot;</code> 在你执行 <code>git push</code> 将代码推送到远程仓库前，执行 <code>npm test</code> 进行测试。如果测试失败，将不会执行这次推送。</p></li></ol><h3 id="项目规范"><a href="#项目规范" class="headerlink" title="项目规范"></a>项目规范</h3><p>主要是项目文件的组织方式和命名方式。</p><p>用我们的 Vue 项目举个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├─public</span><br><span class="line">├─src</span><br><span class="line">├─test</span><br></pre></td></tr></table></figure><p>一个项目包含 public（公共资源，不会被 webpack 处理）、src（源码）、test（测试代码），其中 src 目录，又可以细分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├─api （接口）</span><br><span class="line">├─assets （静态资源）</span><br><span class="line">├─components （公共组件）</span><br><span class="line">├─styles （公共样式）</span><br><span class="line">├─router （路由）</span><br><span class="line">├─store （vuex 全局数据）</span><br><span class="line">├─utils （工具函数）</span><br><span class="line">└─views （页面）</span><br></pre></td></tr></table></figure><p>文件名称如果过长则用 - 隔开。</p><h3 id="UI-规范"><a href="#UI-规范" class="headerlink" title="UI 规范"></a>UI 规范</h3><p>UI 规范需要前端、UI、产品沟通，互相商量，最后制定下来，建议使用统一的 UI 组件库。</p><p>制定 UI 规范的好处：</p><ul><li>统一页面 UI 标准，节省 UI 设计时间</li><li>提高前端开发效率</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试是前端工程化建设必不可少的一部分，它的作用就是找出 bug，越早发现 bug，所需要付出的成本就越低。并且，它更重要的作用是在将来，而不是当下。</p><p>设想一下半年后，你的项目要加一个新功能。在加完新功能后，你不确定有没有影响到原有的功能，需要测试一下。由于时间过去太久，你对项目的代码已经不了解了。在这种情况下，如果没有写测试，你就得手动一遍一遍的去试。而如果写了测试，你只需要跑一遍测试代码就 OK 了，省时省力。</p><p>写测试还可以让你修改代码时没有心理负担，不用一直想着改这里有没有问题？会不会引起 BUG？而写了测试就没有这种担心了。</p><p>在前端用得最多的就是单元测试（主要是端到端测试我用得很少，不熟），这里着重讲解一下。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试就是对一个函数、一个组件、一个类做的测试，它针对的粒度比较小。</p><p>它应该怎么写呢？</p><ol><li>根据正确性写测试，即正确的输入应该有正常的结果。</li><li>根据异常写测试，即错误的输入应该是错误的结果。</li></ol><h4 id="对一个函数做测试"><a href="#对一个函数做测试" class="headerlink" title="对一个函数做测试"></a>对一个函数做测试</h4><p>例如一个取绝对值的函数 <code>abs()</code>，输入 <code>1,2</code>，结果应该与输入相同；输入 <code>-1,-2</code>，结果应该与输入相反。如果输入非数字，例如 <code>&quot;abc&quot;</code>，应该抛出一个类型错误。</p><h4 id="对一个类做测试"><a href="#对一个类做测试" class="headerlink" title="对一个类做测试"></a>对一个类做测试</h4><p>假设有这样一个类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line">    <span class="title function_">abs</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">sqrt</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">pow</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试，必须把这个类的所有方法都测一遍。</p><h4 id="对一个组件做测试"><a href="#对一个组件做测试" class="headerlink" title="对一个组件做测试"></a>对一个组件做测试</h4><p>组件测试比较难，因为很多组件都涉及了 DOM 操作。</p><p>例如一个上传图片组件，它有一个将图片转成 base64 码的方法，那要怎么测试呢？一般测试都是跑在 node 环境下的，而 node 环境没有 DOM 对象。</p><p>我们先来回顾一下上传图片的过程：</p><ol><li>点击 <code>&lt;input type=&quot;file&quot; /&gt;</code>，选择图片上传。</li><li>触发 <code>input</code> 的 <code>change</code> 事件，获取 <code>file</code> 对象。</li><li>用 <code>FileReader</code> 将图片转换成 <code>base64</code> 码。</li></ol><p>这个过程和下面的代码是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input&quot;</span>).<span class="property">onchange</span> = <span class="keyword">function</span> <span class="title function_">fileChangeHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> file = e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">  reader.<span class="property">onload</span> = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fileResult = res.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(fileResult); <span class="comment">// 输出 base64 码</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码只是模拟，真实情况下应该是这样使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input&quot;</span>).<span class="property">onchange</span> = <span class="keyword">function</span> <span class="title function_">fileChangeHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> file = e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="title function_">tobase64</span>(file);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tobase64</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    reader.<span class="property">onload</span> = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fileResult = res.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">      <span class="title function_">resolve</span>(fileResult); <span class="comment">// 输出 base64 码</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面代码出现了 window 的事件对象 <code>event</code>、<code>FileReader</code>。也就是说，只要我们能够提供这两个对象，就可以在任何环境下运行它。所以我们可以在测试环境下加上这两个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写 File</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">File</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 FileReader</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">FileReader</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">readAsDataURL</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onload</span> &amp;&amp;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onload</span>(&#123;</span><br><span class="line">        <span class="attr">target</span>: &#123;</span><br><span class="line">          <span class="attr">result</span>: fileData,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后测试可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提前写好文件内容</span></span><br><span class="line"><span class="keyword">const</span> fileData = <span class="string">&quot;data:image/test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个假的 file 对象给 tobase64() 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> file = <span class="keyword">new</span> <span class="title class_">File</span>();</span><br><span class="line">  <span class="keyword">const</span> event = &#123; <span class="attr">target</span>: &#123; <span class="attr">files</span>: [file] &#125; &#125;;</span><br><span class="line">  file.<span class="property">type</span> = <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line">  file.<span class="property">name</span> = <span class="string">&quot;test.png&quot;</span>;</span><br><span class="line">  file.<span class="property">size</span> = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;file content&quot;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">tobase64</span>(file).<span class="title function_">then</span>(<span class="function">(<span class="params">base64</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">expect</span>(base64).<span class="title function_">toEqual</span>(fileData); <span class="comment">// &#x27;data:image/test&#x27;</span></span><br><span class="line">      <span class="title function_">done</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行测试</span></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure><p>通过这种 hack 的方式，我们就实现了对涉及 DOM 操作的组件的测试。我的 <a class="link"   href="https://github.com/woai3c/vue-upload-imgs" >vue-upload-imgs<i class="fas fa-external-link-alt"></i></a> 库就是通过这种方式写的单元测试，有兴趣可以了解一下。</p><h4 id="TDD-测试驱动开发"><a href="#TDD-测试驱动开发" class="headerlink" title="TDD 测试驱动开发"></a>TDD 测试驱动开发</h4><p>TDD 就是根据需求提前把测试代码写好，然后根据测试代码实现功能。</p><p>TDD 的初衷是好的，但如果你的需求经常变（你懂的），那就不是一件好事了。很有可能你天天都在改测试代码，业务代码反而没怎么动。所以到现在为止，三年多的程序员生涯，我还没尝试过 TDD 开发。</p><p>虽然环境如此艰难，但有条件的情况下还是应该试一下 TDD 的。例如在你自己负责一个项目又不忙的时候，可以采用此方法编写测试用例。</p><h4 id="测试框架推荐"><a href="#测试框架推荐" class="headerlink" title="测试框架推荐"></a>测试框架推荐</h4><p>我常用的测试框架是 <a class="link"   href="https://jestjs.io/zh-Hans/docs/getting-started" >jest<i class="fas fa-external-link-alt"></i></a>，好处是有中文文档，API 清晰明了，一看就知道是干什么用的。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在没有学会自动部署前，我是这样部署项目的：</p><ol><li>执行测试 <code>npm run test</code>。</li><li>构建项目 <code>npm run build</code>。</li><li>将打包好的文件放到静态服务器。</li></ol><p>一次两次还行，如果天天都这样，就会把很多时间浪费在重复的操作上。所以我们要学会自动部署，彻底解放双手。</p><p>自动部署（又叫持续部署 Continuous Deployment，英文缩写 CD）一般有两种触发方式：</p><ol><li>轮询。</li><li>监听 <code>webhook</code> 事件。</li></ol><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>轮询，就是构建软件每隔一段时间自动执行打包、部署操作。</p><p>这种方式不太好，很有可能软件刚部署完我就改代码了。为了看到新的页面效果，不得不等到下一次构建开始。</p><p>另外还有一个副作用，假如我一天都没更改代码，构建软件还是会不停的执行打包、部署操作，白白的浪费资源。</p><p>所以现在的构建软件基本采用监听 <code>webhook</code> 事件的方式来进行部署。</p><h3 id="监听-webhook-事件"><a href="#监听-webhook-事件" class="headerlink" title="监听 webhook 事件"></a>监听 webhook 事件</h3><p>webhook 钩子函数，就是在你的构建软件上进行设置，监听某一个事件（一般是监听 <code>push</code> 事件），当事件触发时，自动执行定义好的脚本。</p><p>例如 Github Actions 就有这个功能。</p><p>对于新人来说，仅看我这一段讲解是不可能学会自动部署的。为此我特地写了一篇自动化部署教程，不需要你提前学习自动化部署的知识，只要照着指引做，就能实现前端项目自动化部署。</p><p><a class="link"   href="https://juejin.cn/post/6887751398499287054" >前端项目自动化部署——超详细教程（Jenkins、Github Actions）<i class="fas fa-external-link-alt"></i></a>，教程已经奉上，各位大佬看完后要是觉得有用，不要忘了点赞，感激不尽。</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>监控，又分性能监控和错误监控，它的作用是预警和追踪定位问题。</p><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p>性能监控一般利用 <code>window.performance</code> 来进行数据采集。</p><blockquote><p>Performance 接口可以获取到当前页面中与性能相关的信息，它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、User Timing API 和 Resource Timing API。</p></blockquote><p>这个 API 的属性 <code>timing</code>，包含了页面加载各个阶段的起始及结束时间。</p><p><img                         lazyload                       alt="image"                       data-src="https://raw.githubusercontent.com/XPoet/image-hosting/master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.1rb2amet2rcw.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://raw.githubusercontent.com/XPoet/image-hosting/master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.59uaxyeshkw0.png"                        alt="image"                 ></p><p>为了方便大家理解 <code>timing</code> 各个属性的意义，我在知乎找到一位网友对于 <code>timing</code> 写的简介（忘了姓名，后来找不到了，见谅），在此转载一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">timing</span>: &#123;</span><br><span class="line">    <span class="comment">// 同一个浏览器上一个页面卸载 (unload) 结束时的时间戳。如果没有上一个页面，这个值会和 fetchStart 相同。</span></span><br><span class="line"><span class="attr">navigationStart</span>: <span class="number">1543806782096</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一个页面 unload 事件抛出时的时间戳。如果没有上一个页面，这个值会返回 0。</span></span><br><span class="line"><span class="attr">unloadEventStart</span>: <span class="number">1543806782523</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 unloadEventStart 相对应，unload 事件处理完成时的时间戳。如果没有上一个页面，这个值会返回 0。</span></span><br><span class="line"><span class="attr">unloadEventEnd</span>: <span class="number">1543806782523</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个 HTTP 重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回 0。</span></span><br><span class="line"><span class="attr">redirectStart</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一个 HTTP 重定向完成时（也就是说是 HTTP 响应的最后一个比特直接被收到的时间）的时间戳。</span></span><br><span class="line"><span class="comment">// 如果没有重定向，或者重定向中的一个不同源，这个值会返回 0.</span></span><br><span class="line"><span class="attr">redirectEnd</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器准备好使用 HTTP 请求来获取 (fetch) 文档的时间戳。这个时间点会在检查任何应用缓存之前。</span></span><br><span class="line"><span class="attr">fetchStart</span>: <span class="number">1543806782096</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// DNS 域名查询开始的 UNIX 时间戳。</span></span><br><span class="line">        <span class="comment">//如果使用了持续连接 (persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart 一致。</span></span><br><span class="line"><span class="attr">domainLookupStart</span>: <span class="number">1543806782096</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// DNS 域名查询完成的时间。</span></span><br><span class="line"><span class="comment">//如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span></span><br><span class="line"><span class="attr">domainLookupEnd</span>: <span class="number">1543806782096</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP（TCP）域名查询结束的时间戳。</span></span><br><span class="line">        <span class="comment">//如果使用了持续连接 (persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart 一致。</span></span><br><span class="line"><span class="attr">connectStart</span>: <span class="number">1543806782099</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP（TCP）返回浏览器与服务器之间的连接建立时的时间戳。</span></span><br><span class="line">        <span class="comment">// 如果建立的是持久连接，则返回值等同于 fetchStart 属性的值。连接建立指的是所有握手和认证过程全部结束。</span></span><br><span class="line"><span class="attr">connectEnd</span>: <span class="number">1543806782227</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回 0。</span></span><br><span class="line"><span class="attr">secureConnectionStart</span>: <span class="number">1543806782162</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回浏览器向服务器发出 HTTP 请求时（或开始读取本地缓存时）的时间戳。</span></span><br><span class="line"><span class="attr">requestStart</span>: <span class="number">1543806782241</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。</span></span><br><span class="line">        <span class="comment">//如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。</span></span><br><span class="line"><span class="attr">responseStart</span>: <span class="number">1543806782516</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时</span></span><br><span class="line">        <span class="comment">//（如果在此之前 HTTP 连接已经关闭，则返回关闭时）的时间戳。</span></span><br><span class="line"><span class="attr">responseEnd</span>: <span class="number">1543806782537</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前网页 DOM 结构开始解析时（即 Document.readyState 属性变为“loading”、相应的 readystatechange 事件触发时）的时间戳。</span></span><br><span class="line"><span class="attr">domLoading</span>: <span class="number">1543806782573</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前网页 DOM 结构结束解析、开始加载内嵌资源时（即 Document.readyState 属性变为“interactive”、相应的 readystatechange 事件触发时）的时间戳。</span></span><br><span class="line"><span class="attr">domInteractive</span>: <span class="number">1543806783203</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当解析器发送 DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。</span></span><br><span class="line"><span class="attr">domContentLoadedEventStart</span>: <span class="number">1543806783203</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。</span></span><br><span class="line"><span class="attr">domContentLoadedEventEnd</span>: <span class="number">1543806783216</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前文档解析完成，即 Document.readyState 变为 &#x27;complete&#x27;且相对应的 readystatechange 被触发时的时间戳</span></span><br><span class="line"><span class="attr">domComplete</span>: <span class="number">1543806783796</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// load 事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是 0。</span></span><br><span class="line"><span class="attr">loadEventStart</span>: <span class="number">1543806783796</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 load 事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是 0.</span></span><br><span class="line"><span class="attr">loadEventEnd</span>: <span class="number">1543806783802</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上数据，我们可以得到几个有用的时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 重定向耗时</span><br><span class="line">redirect: timing.redirectEnd - timing.redirectStart,</span><br><span class="line">// DOM 渲染耗时</span><br><span class="line">dom: timing.domComplete - timing.domLoading,</span><br><span class="line">// 页面加载耗时</span><br><span class="line">load: timing.loadEventEnd - timing.navigationStart,</span><br><span class="line">// 页面卸载耗时</span><br><span class="line">unload: timing.unloadEventEnd - timing.unloadEventStart,</span><br><span class="line">// 请求耗时</span><br><span class="line">request: timing.responseEnd - timing.requestStart,</span><br><span class="line">// 获取性能信息时当前时间</span><br><span class="line">time: new Date().getTime(),</span><br></pre></td></tr></table></figure><p>还有一个比较重要的时间就是<strong>白屏时间</strong>，它指从输入网址，到页面开始显示内容的时间。</p><p>将以下脚本放在 <code>&lt;/head&gt;</code> 前面就能获取白屏时间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  whiteScreen = <span class="keyword">new</span> <span class="title class_">Date</span>() - performance.<span class="property">timing</span>.<span class="property">navigationStart</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这几个时间，就可以得知页面首屏加载性能如何了。</p><p>另外，通过 <code>window.performance.getEntriesByType(&#39;resource&#39;)</code> 这个方法，我们还可以获取相关资源（js、css、img…）的加载时间，它会返回页面当前所加载的所有资源。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.2um5k8wwze4.png"                        alt="image"                 ></p><p>它一般包括以下几个类型</p><ul><li>sciprt</li><li>link</li><li>img</li><li>css</li><li>fetch</li><li>other</li><li>xmlhttprequest</li></ul><p>我们只需用到以下几个信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 资源的名称</span><br><span class="line">name: item.name,</span><br><span class="line">// 资源加载耗时</span><br><span class="line">duration: item.duration.toFixed(2),</span><br><span class="line">// 资源大小</span><br><span class="line">size: item.transferSize,</span><br><span class="line">// 资源所用协议</span><br><span class="line">protocol: item.nextHopProtocol,</span><br></pre></td></tr></table></figure><p>现在，写几行代码来收集这些数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收集性能信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getPerformance</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">performance</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> timing = <span class="variable language_">window</span>.<span class="property">performance</span>.<span class="property">timing</span>;</span><br><span class="line">  <span class="keyword">const</span> performance = &#123;</span><br><span class="line">    <span class="comment">// 重定向耗时</span></span><br><span class="line">    <span class="attr">redirect</span>: timing.<span class="property">redirectEnd</span> - timing.<span class="property">redirectStart</span>,</span><br><span class="line">    <span class="comment">// 白屏时间</span></span><br><span class="line">    <span class="attr">whiteScreen</span>: whiteScreen,</span><br><span class="line">    <span class="comment">// DOM 渲染耗时</span></span><br><span class="line">    <span class="attr">dom</span>: timing.<span class="property">domComplete</span> - timing.<span class="property">domLoading</span>,</span><br><span class="line">    <span class="comment">// 页面加载耗时</span></span><br><span class="line">    <span class="attr">load</span>: timing.<span class="property">loadEventEnd</span> - timing.<span class="property">navigationStart</span>,</span><br><span class="line">    <span class="comment">// 页面卸载耗时</span></span><br><span class="line">    <span class="attr">unload</span>: timing.<span class="property">unloadEventEnd</span> - timing.<span class="property">unloadEventStart</span>,</span><br><span class="line">    <span class="comment">// 请求耗时</span></span><br><span class="line">    <span class="attr">request</span>: timing.<span class="property">responseEnd</span> - timing.<span class="property">requestStart</span>,</span><br><span class="line">    <span class="comment">// 获取性能信息时当前时间</span></span><br><span class="line">    <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> performance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取资源信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getResources</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">performance</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="variable language_">window</span>.<span class="property">performance</span>.<span class="title function_">getEntriesByType</span>(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> resource = &#123;</span><br><span class="line">    <span class="attr">xmlhttprequest</span>: [],</span><br><span class="line">    <span class="attr">css</span>: [],</span><br><span class="line">    <span class="attr">other</span>: [],</span><br><span class="line">    <span class="attr">script</span>: [],</span><br><span class="line">    <span class="attr">img</span>: [],</span><br><span class="line">    <span class="attr">link</span>: [],</span><br><span class="line">    <span class="attr">fetch</span>: [],</span><br><span class="line">    <span class="comment">// 获取资源信息时当前时间</span></span><br><span class="line">    <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arry = resource[item.<span class="property">initiatorType</span>];</span><br><span class="line">    arry &amp;&amp;</span><br><span class="line">      arry.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="comment">// 资源的名称</span></span><br><span class="line">        <span class="attr">name</span>: item.<span class="property">name</span>,</span><br><span class="line">        <span class="comment">// 资源加载耗时</span></span><br><span class="line">        <span class="attr">duration</span>: item.<span class="property">duration</span>.<span class="title function_">toFixed</span>(<span class="number">2</span>),</span><br><span class="line">        <span class="comment">// 资源大小</span></span><br><span class="line">        <span class="attr">size</span>: item.<span class="property">transferSize</span>,</span><br><span class="line">        <span class="comment">// 资源所用协议</span></span><br><span class="line">        <span class="attr">protocol</span>: item.<span class="property">nextHopProtocol</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resource;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过对性能及资源信息的解读，我们可以判断出页面加载慢有以下几个原因：</p><ol><li>资源过多</li><li>网速过慢</li><li>DOM 元素过多</li></ol><p>除了用户网速过慢，我们没办法之外，其他两个原因都是有办法解决的，性能优化将在下一节《性能优化》中会讲到。</p><h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><p>现在能捕捉的错误有三种。</p><ol><li>资源加载错误，通过 <code>addEventListener(&#39;error&#39;, callback, true)</code> 在捕获阶段捕捉资源加载失败错误。</li><li>js 执行错误，通过 <code>window.onerror</code> 捕捉 js 错误。</li><li>promise 错误，通过 <code>addEventListener(&#39;unhandledrejection&#39;, callback)</code> 捕捉 promise 错误，但是没有发生错误的行数，列数等信息，只能手动抛出相关错误信息。</li></ol><p>我们可以建一个错误数组变量 errors 在错误发生时，将错误的相关信息添加到数组，然后在某个阶段统一上报，具体如何操作请看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 捕获资源加载失败错误 js css img...</span></span><br><span class="line"><span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;error&quot;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> target = e.<span class="property">target</span>;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="variable language_">window</span>) &#123;</span><br><span class="line">      monitor.<span class="property">errors</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: target.<span class="property">localName</span>,</span><br><span class="line">        <span class="attr">url</span>: target.<span class="property">src</span> || target.<span class="property">href</span>,</span><br><span class="line">        <span class="attr">msg</span>: (target.<span class="property">src</span> || target.<span class="property">href</span>) + <span class="string">&quot; is load error&quot;</span>,</span><br><span class="line">        <span class="comment">// 错误发生的时间</span></span><br><span class="line">        <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(),</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 js 错误</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">msg, url, row, col, error</span>) &#123;</span><br><span class="line">  monitor.<span class="property">errors</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    <span class="attr">row</span>: row,</span><br><span class="line">    <span class="attr">col</span>: col,</span><br><span class="line">    <span class="attr">msg</span>: error &amp;&amp; error.<span class="property">stack</span> ? error.<span class="property">stack</span> : msg,</span><br><span class="line">    <span class="attr">url</span>: url,</span><br><span class="line">    <span class="comment">// 错误发生的时间</span></span><br><span class="line">    <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 promise 错误 缺点是获取不到行数数据</span></span><br><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  monitor.<span class="property">errors</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;promise&quot;</span>,</span><br><span class="line">    <span class="attr">msg</span>: (e.<span class="property">reason</span> &amp;&amp; e.<span class="property">reason</span>.<span class="property">msg</span>) || e.<span class="property">reason</span> || <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">// 错误发生的时间</span></span><br><span class="line">    <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>通过错误收集，可以了解到网站错误发生的类型及数量，从而可以做相应的调整，以减少错误发生。完整代码和 DEMO 请看我另一篇文章 <a class="link"   href="https://juejin.cn/post/6844903998412029959" >前端性能和错误监控<i class="fas fa-external-link-alt"></i></a> 的末尾，大家可以复制代码（HTML 文件）在本地测试一下。</p><h3 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h3><h4 id="性能数据上报"><a href="#性能数据上报" class="headerlink" title="性能数据上报"></a>性能数据上报</h4><p>性能数据可以在页面加载完之后上报，尽量不要对页面性能造成影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在浏览器空闲时间获取性能及资源信息</span></span><br><span class="line">  <span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">requestIdleCallback</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      monitor.<span class="property">performance</span> = <span class="title function_">getPerformance</span>();</span><br><span class="line">      monitor.<span class="property">resources</span> = <span class="title function_">getResources</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      monitor.<span class="property">performance</span> = <span class="title function_">getPerformance</span>();</span><br><span class="line">      monitor.<span class="property">resources</span> = <span class="title function_">getResources</span>();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，你也可以设一个定时器，循环上报。不过每次上报最好做一下对比去重再上报，避免同样的数据重复上报。</p><h4 id="错误数据上报"><a href="#错误数据上报" class="headerlink" title="错误数据上报"></a>错误数据上报</h4><p>我在 DEMO 里提供的代码，是用一个 <code>errors</code> 数组收集所有的错误，再在某一阶段统一上报（延时上报）。其实，也可以改成在错误发生时上报（即时上报）。这样可以避免在收集完错误延时上报还没触发，用户却已经关掉网页导致错误数据丢失的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听 js 错误</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">msg, url, row, col, error</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    <span class="attr">row</span>: row,</span><br><span class="line">    <span class="attr">col</span>: col,</span><br><span class="line">    <span class="attr">msg</span>: error &amp;&amp; error.<span class="property">stack</span> ? error.<span class="property">stack</span> : msg,</span><br><span class="line">    <span class="attr">url</span>: url,</span><br><span class="line">    <span class="comment">// 错误发生的时间</span></span><br><span class="line">    <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 即时上报</span></span><br><span class="line">  axios.<span class="title function_">post</span>(&#123; <span class="attr">url</span>: <span class="string">&quot;xxx&quot;</span>, data &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h3><p><code>window.performance</code> API 是有缺点的，在 SPA 切换路由时，<code>window.performance.timing</code> 的数据不会更新。所以我们需要另想办法来统计切换路由到加载完成的时间。<br>拿 Vue 举例，一个可行的办法就是切换路由时，在路由的全局前置守卫 <code>beforeEach</code> 里获取开始时间，在组件的 <code>mounted</code> 钩子里执行 <code>vm.$nextTick</code> 函数来获取组件的渲染完毕时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  store.<span class="title function_">commit</span>(<span class="string">&quot;setPageLoadedStartTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;setPageLoadedTime&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>() - <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">pageLoadedStartTime</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了性能和错误监控，其实我们还可以做得更多。</p><h3 id="用户信息收集"><a href="#用户信息收集" class="headerlink" title="用户信息收集"></a>用户信息收集</h3><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><p>使用 <code>window.navigator</code> 可以收集到用户的设备信息，操作系统，浏览器信息…</p><h4 id="UV-Unique-visitor"><a href="#UV-Unique-visitor" class="headerlink" title="UV (Unique visitor)"></a>UV (Unique visitor)</h4><p>是指通过互联网访问、浏览这个网页的自然人。访问您网站的一台电脑客户端为一个访客。00:00-24:00 内相同的客户端只被计算一次。一天内同个访客多次访问仅计算一个 UV。<br>在用户访问网站时，可以生成一个随机字符串 + 时间日期，保存在本地。在网页发生请求时（如果超过当天 24 小时，则重新生成），把这些参数传到后端，后端利用这些信息生成 UV 统计报告。</p><h4 id="PV-Page-View"><a href="#PV-Page-View" class="headerlink" title="PV (Page View)"></a>PV (Page View)</h4><p>即页面浏览量或点击量，用户每 1 次对网站中的每个网页访问均被记录 1 个 PV。用户对同一页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。</p><h4 id="页面停留时间"><a href="#页面停留时间" class="headerlink" title="页面停留时间"></a>页面停留时间</h4><ul><li><p>传统网站<br>用户在进入 A 页面时，通过后台请求把用户进入页面的时间捎上。过了 10 分钟，用户进入 B 页面，这时后台可以通过接口捎带的参数可以判断出用户在 A 页面停留了 10 分钟。</p></li><li><p>SPA<br>可以利用 router 来获取用户停留时间，拿 Vue 举例，通过 r<code>outer.beforeEach</code>、<code>destroyed</code> 这两个钩子函数来获取用户停留该路由组件的时间。</p></li></ul><h4 id="浏览深度"><a href="#浏览深度" class="headerlink" title="浏览深度"></a>浏览深度</h4><p>通过 <code>document.documentElement.scrollTop</code> 属性以及屏幕高度，可以判断用户是否浏览完网站内容。</p><h4 id="页面跳转来源"><a href="#页面跳转来源" class="headerlink" title="页面跳转来源"></a>页面跳转来源</h4><p>通过 <code>document.referrer</code> 属性，可以知道用户是从哪个网站跳转而来。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>通过分析用户数据，我们可以了解到用户的浏览习惯、爱好等等信息，想想真是恐怖，毫无隐私可言。</p><h3 id="前端监控部署教程"><a href="#前端监控部署教程" class="headerlink" title="前端监控部署教程"></a>前端监控部署教程</h3><p>前面说的都是监控原理，但要实现还是得自己动手写代码。为了避免麻烦，我们可以用现有的工具 sentry 去做这件事。</p><p>sentry 是一个用 python 写的性能和错误监控工具，你可以使用 sentry 提供的服务（免费功能少），也可以自己部署服务。现在来看一下如何使用 sentry 提供的服务实现监控。</p><h4 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h4><p>打开 <a class="link"   href="https://sentry.io/signup/" >https://sentry.io/signup/<i class="fas fa-external-link-alt"></i></a> 网站，进行注册。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.7jd4e853lw80.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.3vq1s8jpd4o0.png"                        alt="image"                 ></p><p>选择项目，我选的 Vue。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.6f4m9343a840.png"                        alt="image"                 ></p><h4 id="安装-sentry-依赖"><a href="#安装-sentry-依赖" class="headerlink" title="安装 sentry 依赖"></a>安装 sentry 依赖</h4><p>选完项目，下面会有具体的 sentry 依赖安装指南。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.3i7u19pr83g0.png"                        alt="image"                 ></p><p>根据提示，在你的 Vue 项目执行这段代码 <code>npm install --save @sentry/browser @sentry/integrations @sentry/tracing</code>，安装 sentry 所需的依赖。</p><p>再将下面的代码拷到你的 <code>main.js</code>，放在 <code>new Vue()</code> 之前。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Sentry</span> <span class="keyword">from</span> <span class="string">&quot;@sentry/browser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span> <span class="keyword">as</span> <span class="title class_">VueIntegration</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@sentry/integrations&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Integrations</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@sentry/tracing&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sentry</span>.<span class="title function_">init</span>(&#123;</span><br><span class="line">  <span class="attr">dsn</span>: <span class="string">&quot;xxxxx&quot;</span>, <span class="comment">// 这里是你的 dsn 地址，注册完就有</span></span><br><span class="line">  <span class="attr">integrations</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">VueIntegration</span>(&#123;</span><br><span class="line">      <span class="title class_">Vue</span>,</span><br><span class="line">      <span class="attr">tracing</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Integrations</span>.<span class="title class_">BrowserTracing</span>(),</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We recommend adjusting this value in production, or using tracesSampler</span></span><br><span class="line">  <span class="comment">// for finer control</span></span><br><span class="line">  <span class="attr">tracesSampleRate</span>: <span class="number">1.0</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后点击第一步中的 <code>skip this onboarding</code>，进入控制台页面。</p><p>如果忘了自己的 DSN，请点击左边的菜单栏选择 Settings -&gt; Projects -&gt; 点击自己的项目 -&gt; Client Keys(DSN)。</p><h4 id="创建第一个错误"><a href="#创建第一个错误" class="headerlink" title="创建第一个错误"></a>创建第一个错误</h4><p>在你的 Vue 项目执行一个打印语句 <code>console.log(b)</code>。</p><p>这时点开 sentry 主页的 issues 一项，可以发现有一个报错信息 <code>b is not defined</code>：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.5w2pucwba480.png"                        alt="image"                 ></p><p>这个报错信息包含了错误的具体信息，还有你的 IP、浏览器信息等等。</p><p>但奇怪的是，我们的浏览器控制台并没有输出报错信息。</p><p>这是因为被 sentry 屏蔽了，所以我们需要加上一个选项 <code>logErrors: true</code>。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.22rx8mip0nq8.png"                        alt="image"                 ></p><p>然后再查看页面，发现控制台也有报错信息了：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.747fn7m5rw40.png"                        alt="image"                 ></p><h4 id="上传-sourcemap"><a href="#上传-sourcemap" class="headerlink" title="上传 sourcemap"></a>上传 sourcemap</h4><p>一般打包后的代码都是经过压缩的，如果没有 sourcemap，即使有报错信息，你也很难根据提示找到对应的源码在哪。</p><p>下面来看一下如何上传 sourcemap。</p><p>首先创建 auth token。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.6w7q0oxfurs0.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.3cg2pjj58qk0.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.7iqo7alnppg0.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.4v2hzuyxw940.png"                        alt="image"                 ></p><p>这个生成的 token 一会要用到。</p><p>安装 <code>sentry-cli</code> 和 <code>@sentry/webpack-plugin</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install sentry-cli-binary -g</span><br><span class="line">npm install --save-dev @sentry/webpack-plugin</span><br></pre></td></tr></table></figure><p>安装完上面两个插件后，在项目根目录创建一个 <code>.sentryclirc</code> 文件（不要忘了在 <code>.gitignore</code> 把这个文件添加上，以免暴露 token），内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[auth]</span><br><span class="line">token=xxx</span><br><span class="line"></span><br><span class="line">[defaults]</span><br><span class="line">url=https://sentry.io/</span><br><span class="line">org=woai3c</span><br><span class="line">project=woai3c</span><br></pre></td></tr></table></figure><p>把 xxx 替换成刚才生成的 token。</p><p>org 是你的组织名称。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.3lgiick9l4c0.png"                        alt="image"                 ></p><p>project 是你的项目名称，根据下面的提示可以找到。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.63h29nch8300.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.266t13dd798g.png"                        alt="image"                 ></p><p>在项目下新建 <code>vue.config.js</code> 文件，把下面的内容填进去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SentryWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;@sentry/webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SentryWebpackPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">include</span>: <span class="string">&quot;./dist&quot;</span>, <span class="comment">// 打包后的目录</span></span><br><span class="line">        <span class="attr">ignore</span>: [<span class="string">&quot;node_modules&quot;</span>, <span class="string">&quot;vue.config.js&quot;</span>, <span class="string">&quot;babel.config.js&quot;</span>],</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只在生产环境下上传 sourcemap</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> == <span class="string">&quot;production&quot;</span> ? config : &#123;&#125;;</span><br></pre></td></tr></table></figure><p>填完以后，执行 <code>npm run build</code>，就可以看到 <code>sourcemap</code> 的上传结果了。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.vtifvhs3h6.png"                        alt="image"                 ></p><p>我们再来看一下没上传 sourcemap 和上传之后的报错信息对比。</p><h5 id="未上传-sourcemap"><a href="#未上传-sourcemap" class="headerlink" title="未上传 sourcemap"></a>未上传 sourcemap</h5><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.57gn1tm4jps0.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.3au6f8tmkwi0.png"                        alt="image"                 ></p><h5 id="已上传-sourcemap"><a href="#已上传-sourcemap" class="headerlink" title="已上传 sourcemap"></a>已上传 sourcemap</h5><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.289qjt3x0fvo.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.668wlj1ee1w0.png"                        alt="image"                 ></p><p>可以看到，上传 sourcemap 后的报错信息更加准确。</p><h4 id="切换中文环境和时区"><a href="#切换中文环境和时区" class="headerlink" title="切换中文环境和时区"></a>切换中文环境和时区</h4><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.54xrae5g8m40.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.41gtnvd615c0.png"                        alt="image"                 ></p><p>选完刷新即可。</p><h4 id="性能监控-1"><a href="#性能监控-1" class="headerlink" title="性能监控"></a>性能监控</h4><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.2il8pvtpc880.png"                        alt="image"                 ></p><p>打开 performance 选项，就能看到你每个项目的运行情况。具体的参数解释请看文档 <a class="link"   href="https://docs.sentry.io/product/performance/" >Performance Monitoring<i class="fas fa-external-link-alt"></i></a>。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>性能优化主要分为两类：</p><ol><li>加载时优化</li><li>运行时优化</li></ol><p>例如压缩文件、使用 CDN 就属于加载时优化；减少 DOM 操作，使用事件委托属于运行时优化。<br>在解决问题之前，必须先找出问题，否则无从下手。所以在做性能优化之前，最好先调查一下网站的加载性能和运行性能。</p><h3 id="手动检查"><a href="#手动检查" class="headerlink" title="手动检查"></a>手动检查</h3><h4 id="检查加载性能"><a href="#检查加载性能" class="headerlink" title="检查加载性能"></a>检查加载性能</h4><p>一个网站加载性能如何主要看白屏时间和首屏时间。</p><ul><li>白屏时间：指从输入网址，到页面开始显示内容的时间。</li><li>首屏时间：指从输入网址，到页面完全渲染的时间。</li></ul><p>将以下脚本放在 <code>&lt;/head&gt;</code> 前面就能获取白屏时间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Date</span>() - performance.<span class="property">timing</span>.<span class="property">navigationStart</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>window.onload</code> 事件里执行 <code>new Date() - performance.timing.navigationStart</code> 即可获取首屏时间。</p><h4 id="检查运行性能"><a href="#检查运行性能" class="headerlink" title="检查运行性能"></a>检查运行性能</h4><p>配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。<br>打开网站，按 F12 选择 performance，点击左上角的灰色圆点，变成红色就代表开始记录了。这时可以模仿用户使用网站，在使用完毕后，点击 stop，然后你就能看到网站运行期间的性能报告。如果有红色的块，代表有掉帧的情况；如果是绿色，则代表 FPS 很好。<br>另外，在 performance 标签下，按 ESC 会弹出来一个小框。点击小框左边的三个点，把 rendering 勾出来。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.zsikkg7cqdc.png"                        alt="image"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.7hybbsvdtdc0.png"                        alt="image"                 ></p><p>这两个选项，第一个是高亮重绘区域，另一个是显示帧渲染信息。把这两个选项勾上，然后浏览网页，可以实时的看到你网页渲染变化。</p><h3 id="利用工具检查"><a href="#利用工具检查" class="headerlink" title="利用工具检查"></a>利用工具检查</h3><h4 id="监控工具"><a href="#监控工具" class="headerlink" title="监控工具"></a>监控工具</h4><p>可以部署一个前端监控系统来监控网站性能，上一节中讲到的 sentry 就属于这一类。</p><h4 id="chrome-工具-Lighthouse"><a href="#chrome-工具-Lighthouse" class="headerlink" title="chrome 工具 Lighthouse"></a>chrome 工具 Lighthouse</h4><p>如果你安装了 Chrome 52+ 版本，请按 F12 打开开发者工具。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.111eyfj3py9s.png"                        alt="image"                 ></p><p>它不仅会对你网站的性能打分，还会对 SEO 打分。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image.49edazgan600.png"                        alt="image"                 ></p><p><a class="link"   href="https://developers.google.com/web/tools/lighthouse" >使用 Lighthouse 审查网络应用<i class="fas fa-external-link-alt"></i></a></p><h3 id="如何做性能优化"><a href="#如何做性能优化" class="headerlink" title="如何做性能优化"></a>如何做性能优化</h3><p>网上关于性能优化的文章和书籍多不胜数，但有很多优化规则已经过时了。所以我写了一篇性能优化文章 <a class="link"   href="https://juejin.cn/post/6892994632968306702" >前端性能优化 24 条建议 (2020)<i class="fas fa-external-link-alt"></i></a>，分析总结出了 24 条性能优化建议，强烈推荐。</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p><a class="link"   href="https://book.douban.com/subject/30468597/" >《重构 2》<i class="fas fa-external-link-alt"></i></a>一书中对重构进行了定义：</p><blockquote><p>所谓重构（refactoring）是这样一个过程：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减小整理过程中引入错误的概率。本质上说，重构就是在代码写好之后改进它的设计。</p></blockquote><p>重构和性能优化有相同点，也有不同点。</p><p>相同的地方是它们都在不改变程序功能的情况下修改代码；不同的地方是重构为了让代码变得更加易读、理解，性能优化则是为了让程序运行得更快。<br>重构可以一边写代码一边重构，也可以在程序写完后，拿出一段时间专门去做重构。没有说哪个方式更好，视个人情况而定。</p><p>如果你专门拿一段时间来做重构，建议你在重构一段代码后，立即进行测试。这样可以避免修改代码太多，在出错时找不到错误点。</p><h3 id="重构的原则"><a href="#重构的原则" class="headerlink" title="重构的原则"></a>重构的原则</h3><ol><li>事不过三，三则重构。即不能重复写同样的代码，在这种情况下要去重构。</li><li>如果一段代码让人很难看懂，那就该考虑重构了。</li><li>如果已经理解了代码，但是非常繁琐或者不够好，也可以重构。</li><li>过长的函数，需要重构。</li><li>一个函数最好对应一个功能，如果一个函数被塞入多个功能，那就要对它进行重构了。</li></ol><h3 id="重构手法"><a href="#重构手法" class="headerlink" title="重构手法"></a>重构手法</h3><p>在《重构 2》这本书中，介绍了多达上百个重构手法。但我觉得有两个是比较常用的：</p><ol><li>提取重复代码，封装成函数</li><li>拆分太长或功能太多的函数</li></ol><h4 id="提取重复代码，封装成函数"><a href="#提取重复代码，封装成函数" class="headerlink" title="提取重复代码，封装成函数"></a>提取重复代码，封装成函数</h4><p>假设有一个查询数据的接口 <code>/getUserData?age=17&amp;city=beijing</code>。现在需要做的是把用户数据：<code>&#123; age: 17, city: &#39;beijing&#39; &#125;</code> 转成 URL 参数的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data); <span class="comment">// &#123; age: 17, city: &#x27;beijing&#x27; &#125;</span></span><br><span class="line">keys.<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  result += <span class="string">&quot;&amp;&quot;</span> + key + <span class="string">&quot;=&quot;</span> + data[key];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">result.<span class="title function_">substr</span>(<span class="number">1</span>); <span class="comment">// age=17&amp;city=beijing</span></span><br></pre></td></tr></table></figure><p>如果只有这一个接口需要转换，不封装成函数是没问题的。但如果有多个接口都有这种需求，那就得把它封装成函数了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">JSON2Params</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data);</span><br><span class="line">  keys.<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    result += <span class="string">&quot;&amp;&quot;</span> + key + <span class="string">&quot;=&quot;</span> + data[key];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">substr</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拆分太长或功能太多的函数"><a href="#拆分太长或功能太多的函数" class="headerlink" title="拆分太长或功能太多的函数"></a>拆分太长或功能太多的函数</h4><p>假设现在有一个注册功能，用伪代码表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">register</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 验证用户数据是否合法</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 验证账号</span></span><br><span class="line"><span class="comment">   * 验证密码</span></span><br><span class="line"><span class="comment">   * 验证短信验证码</span></span><br><span class="line"><span class="comment">   * 验证身份证</span></span><br><span class="line"><span class="comment">   * 验证邮箱</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 2. 如果用户上传了头像，则将用户头像转成 base64 码保存</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 新建 FileReader 对象</span></span><br><span class="line"><span class="comment">   * 将图片转换成 base64 码</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 3. 调用注册接口</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数包含了三个功能，验证、转换、注册。其中验证和转换功能是可以提取出来单独封装成函数的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">register</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 验证用户数据是否合法</span></span><br><span class="line">  <span class="comment">// verify()</span></span><br><span class="line">  <span class="comment">// 2. 如果用户上传了头像，则将用户头像转成 base64 码保存</span></span><br><span class="line">  <span class="comment">// tobase64()</span></span><br><span class="line">  <span class="comment">// 3. 调用注册接口</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你对重构有兴趣，强烈推荐你阅读 <a class="link"   href="https://book.douban.com/subject/30468597/" >《重构 2》<i class="fas fa-external-link-alt"></i></a> 这本书。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文带你入门前端工程化，分为 7 个小节讲解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术选型&lt;/li&gt;
&lt;li&gt;统一规范&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;部署&lt;/li&gt;
&lt;li&gt;监控&lt;/li&gt;
&lt;li&gt;性能优化&lt;/li&gt;
&lt;li&gt;重构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://xpoet.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端工程化" scheme="https://xpoet.cn/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>快速掌握 Vue 3.0 基础语法</title>
    <link href="https://xpoet.cn/post/c8069422dc20/"/>
    <id>https://xpoet.cn/post/c8069422dc20/</id>
    <published>2020-10-05T02:53:13.000Z</published>
    <updated>2023-12-01T07:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>经过两年多的迭代，Vue 3.0 终于在 9 月 18 日 发布了正式版，底层使用 TypeScript 进行大规模重构，有着很大的改变。Vue 3.0 采用 Composition API，类似 React Hook，使用更加灵活。</p><h2 id="Vue-2-x-与-Vue-3-0-的对比"><a href="#Vue-2-x-与-Vue-3-0-的对比" class="headerlink" title="Vue 2.x 与 Vue 3.0 的对比"></a>Vue 2.x 与 Vue 3.0 的对比</h2><ul><li>Vue 2 对 TypeScript 支持不友好，所有属性都放在 <code>this</code> 对象上，难以推断出数据类型。</li><li>Vue 2 大量的 API 挂载在 Vue 对象的原型上，难以实现 tree shaking。</li><li>Vue 2 架构层面对跨平台 DOM 渲染开发支持不友好。</li><li>Vue 3 采用 Composition API，受 React Hook 启发。</li><li>Vue 3 更好地支持 JSX。</li><li>Vue 3 的 Template 支持多个根标签，Vue 2.x 不支持。</li><li>Vue 3 对虚拟 DOM 进行了重写、对模板的编译进行了优化。</li><li>…</li></ul><h2 id="setup-函数"><a href="#setup-函数" class="headerlink" title="setup() 函数"></a>setup() 函数</h2><p><code>setup()</code> 是 Vue 3.0 专门为组件提供的新属性。它为我们使用 Vue 3.0 的 Composition API 新特性提供了统一的入口，<code>setup()</code> 在 <code>beforeCreate()</code> 之后和 <code>created()</code> 之前执行，Vue 3.0 取消了这两个 2.x 版本的生命周期钩子函数，统一用 <code>setup()</code> 代替，该函数相当于一个生命周期函数，Vue 2.x 中的 <code>data</code>，<code>methods</code>，<code>watch</code> 等全部都用对应的新增 API 写在 <code>setup()</code> 中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// context.attrs</span></span><br><span class="line">    <span class="comment">// context.slots</span></span><br><span class="line">    <span class="comment">// context.parent</span></span><br><span class="line">    <span class="comment">// context.root</span></span><br><span class="line">    <span class="comment">// context.emit</span></span><br><span class="line">    <span class="comment">// context.refs</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>props</code> 用来接收 <code>props</code> 数据。</li><li><code>context</code> 用来定义上下文，上下文对象中包含了一些有用的属性，这些属性在 Vue 2.x 中需要通过 <code>this</code> 才能访问到，但在 <code>setup()</code> 中无法访问到 <code>this</code>。</li><li><code>return &#123;&#125;</code> 返回值，返回的是响应式数据，template 模版中需要使用的函数。</li></ul><h2 id="reactive-函数"><a href="#reactive-函数" class="headerlink" title="reactive() 函数"></a>reactive() 函数</h2><p><code>reactive()</code> 接收一个普通对象，返回一个响应式的数据对象，响应式数据对象创建出来之后，在 <code>setup()</code> 中 <code>return</code> 出去，即可在 <code>template</code> 中使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> &#123;&#123; name &#125;&#125; <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; defineComponent, reactive, ref, toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> person = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> person;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ref-函数"><a href="#ref-函数" class="headerlink" title="ref() 函数"></a>ref() 函数</h2><p><code>ref()</code> 用来根据给定的值创建一个响应式的数据对象，<code>ref()</code> 调用的返回值是一个对象，这个对象上只包含一个 <code>value</code> 属性，只在 <code>setup()</code> 函数内部获取 <code>ref()</code> 对象的值需要加上 <code>.value</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mine&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> count = ref&lt;number&gt;(<span class="number">10</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        count,</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>reactive()</code> 对象中访问 <code>ref()</code> 创建的响应式数据对象时，不需要加 <code>.value</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mine&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125; - &#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; defineComponent, reactive, ref, toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> count = ref&lt;number&gt;(<span class="number">10</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">n</span>: <span class="number">100</span>,</span></span><br><span class="line"><span class="language-javascript">        count,</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 通过 reactive 来获取 ref 的值时，不需要使用 .value 属性</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span>); <span class="comment">// 10</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        ...<span class="title function_">toRefs</span>(obj),</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="isRef-函数"><a href="#isRef-函数" class="headerlink" title="isRef() 函数"></a>isRef() 函数</h2><p><code>isRef()</code> 用来判断某个值是否为 <code>ref()</code> 创建出来的对象。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, isRef, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> age = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">18</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isRef</span>(age)); <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isRef</span>(name)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      age,</span><br><span class="line">      name,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toRefs-函数"><a href="#toRefs-函数" class="headerlink" title="toRefs() 函数"></a>toRefs() 函数</h2><p><code>toRefs()</code> 可以将 <code>reactive()</code> 创建出来的响应式对象，转换为普通的对象，这个普通对象上的每个属性节点，都是 <code>ref()</code> 类型的响应式数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mine&quot;</span>&gt;</span>&#123;&#123; name &#125;&#125; &#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; defineComponent, reactive, ref, toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> person = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        ...<span class="title function_">toRefs</span>(person),</span></span><br><span class="line"><span class="language-javascript">        age,</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="computed-函数"><a href="#computed-函数" class="headerlink" title="computed() 函数"></a>computed() 函数</h2><p><code>computed()</code> 用来创建计算属性，和前面一样，它返回的值是一个 <code>ref()</code> 对象。里面可以传方法，或者对象，对象中包含 <code>set()</code>、<code>get()</code> 方法。</p><h3 id="创建只读的计算属性"><a href="#创建只读的计算属性" class="headerlink" title="创建只读的计算属性"></a>创建只读的计算属性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 age 的值，创建一个响应式的计算属性 readOnlyAge，它会根据依赖的 ref 自动计算并返回一个新的 ref</span></span><br><span class="line">    <span class="keyword">const</span> readOnlyAge = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> age.<span class="property">value</span>++); <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      age,</span><br><span class="line">      readOnlyAge,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="通过-set-、get-方法创建一个可读可写的计算属性"><a href="#通过-set-、get-方法创建一个可读可写的计算属性" class="headerlink" title="通过 set()、get() 方法创建一个可读可写的计算属性"></a>通过 set()、get() 方法创建一个可读可写的计算属性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> age = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> computedAge = <span class="title function_">computed</span>(&#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function">() =&gt;</span> age.<span class="property">value</span> + <span class="number">1</span>,</span><br><span class="line">      <span class="attr">set</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> age.<span class="property">value</span> + value,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为计算属性赋值的操作，会触发 set 函数，触发 set 函数后，age 的值会被更新</span></span><br><span class="line">    age.<span class="property">value</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      age,</span><br><span class="line">      computedAge,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="watch-函数"><a href="#watch-函数" class="headerlink" title="watch() 函数"></a>watch() 函数</h2><p><code>watch()</code> 用来监听特定的数据源，并在回调函数中返回。默认情况是懒执行的，仅在监听的源数据变更时才执行回调。</p><h3 id="监听-reactive-创建的数据源"><a href="#监听-reactive-创建的数据源" class="headerlink" title="监听 reactive() 创建的数据源"></a>监听 reactive() 创建的数据源</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, defineComponent, reactive, toRefs, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> person = reactive&lt;<span class="title class_">Person</span>&gt;(&#123; <span class="attr">name</span>: <span class="string">&quot;vue&quot;</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> person.<span class="property">age</span>,</span><br><span class="line">      <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue); <span class="comment">// 100</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(oldValue); <span class="comment">// 10</span></span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 age 时会触发 watch 的回调，打印出改变前后的值</span></span><br><span class="line">    person.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...<span class="title function_">toRefs</span>(person),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="监听用-ref-创建的数据源"><a href="#监听用-ref-创建的数据源" class="headerlink" title="监听用 ref() 创建的数据源"></a>监听用 ref() 创建的数据源</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> age = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(age, <span class="function">(<span class="params">oldValue, newValue</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;oldValue: &quot;</span>, oldValue); <span class="comment">// 10</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;newValue: &quot;</span>, newValue); <span class="comment">// 100</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 age 时会触发 watch 的回调，打印变更后的值</span></span><br><span class="line">    age.<span class="property">value</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      age,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="同时监听多个值"><a href="#同时监听多个值" class="headerlink" title="同时监听多个值"></a>同时监听多个值</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, defineComponent, reactive, toRefs, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive&lt;<span class="title class_">Person</span>&gt;(&#123; <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      [<span class="function">() =&gt;</span> state.<span class="property">age</span>, <span class="function">() =&gt;</span> state.<span class="property">name</span>],</span><br><span class="line">      <span class="function">(<span class="params">[newAge, newName], [oldAge, oldName]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newAge);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newName);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(oldAge);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(oldName);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 修改 state 时会触发 watch 的回调，打印变更前后的值，此时需要注意，更改其中一个值，都会执行 watch 的回调</span></span><br><span class="line">    state.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line">    state.<span class="property">name</span> = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...<span class="title function_">toRefs</span>(state),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="stop-停止监听"><a href="#stop-停止监听" class="headerlink" title="stop 停止监听"></a>stop 停止监听</h3><p>在 <code>setup()</code> 内创建的 <code>watch()</code> 监视，会在当前组件被销毁的时候自动停止。如果想要明确地停止某个监听，可以调用 <code>watch()</code> 的返回值即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, defineComponent, reactive, toRefs, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive&lt;<span class="title class_">Person</span>&gt;(&#123; <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stop = <span class="title function_">watch</span>(</span><br><span class="line">      [<span class="function">() =&gt;</span> state.<span class="property">age</span>, <span class="function">() =&gt;</span> state.<span class="property">name</span>],</span><br><span class="line">      <span class="function">(<span class="params">[newAge, newName], [oldAge, oldName]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newAge);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newName);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(oldAge);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(oldName);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    state.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line">    state.<span class="property">name</span> = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">stop</span>();</span><br><span class="line">      <span class="comment">// 此时修改时，不会触发 watch 回调</span></span><br><span class="line">      state.<span class="property">age</span> = <span class="number">1000</span>;</span><br><span class="line">      state.<span class="property">name</span> = <span class="string">&quot;wangwu&quot;</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>); <span class="comment">// 1 秒之后讲取消 watch 的监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...<span class="title function_">toRefs</span>(state),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="LifeCycle-Hooks-新的生命周期函数"><a href="#LifeCycle-Hooks-新的生命周期函数" class="headerlink" title="LifeCycle Hooks 新的生命周期函数"></a>LifeCycle Hooks 新的生命周期函数</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  defineComponent,</span><br><span class="line">  onBeforeMount,</span><br><span class="line">  onBeforeUnmount,</span><br><span class="line">  onBeforeUpdate,</span><br><span class="line">  onErrorCaptured,</span><br><span class="line">  onMounted,</span><br><span class="line">  onUnmounted,</span><br><span class="line">  onUpdated,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beformounted!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mounted!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onBeforeUpdate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforupdated!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;updated!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforunmounted!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;unmounted!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onErrorCaptured</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;errorCaptured!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Template-refs"><a href="#Template-refs" class="headerlink" title="Template refs"></a>Template refs</h2><p>通过 <code>refs</code> 来返回真实 DOM 元素，为了获得对模板内元素或组件实例的引用，我们可以在 <code>setup()</code> 中声明一个 <code>ref()</code> 并返回它。</p><ol><li>在 HTML 添加 <code>ref</code> 的属性。</li><li>在 <code>steup()</code> 中定义一个 <code>ref()</code>。</li><li>在 <code>steup()</code> 中返回 <code>ref()</code> 的实例。</li><li><code>onMounted()</code> 中可以得到 <code>ref()</code> 的 RefImpl 的对象，通过 <code>.value</code> 获取真实 DOM。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;elmRefs&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; defineComponent, onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 获取真实 DOM</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> elmRefs = ref&lt;<span class="literal">null</span> | <span class="title class_">HTMLElement</span>&gt;(<span class="literal">null</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(elmRefs.<span class="property">value</span>); <span class="comment">// 得到一个 RefImpl 的对象，通过 .value 访问到数据</span></span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        elmRefs,</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Vue-3-全局配置"><a href="#Vue-3-全局配置" class="headerlink" title="Vue 3 全局配置"></a>Vue 3 全局配置</h2><p>通过 Vue 实例上 config 来配置，包含 Vue 应用程序全局配置的对象。在挂载应用程序之前修改下面列出的属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line">app.<span class="property">config</span> = &#123;...&#125;</span><br></pre></td></tr></table></figure><p>为组件渲染功能和观察程序期间的未捕获错误分配处理程序</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="property">config</span>.<span class="property">errorHandler</span> = <span class="function">(<span class="params">err, vm, info</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>可以在应用程序内的任何组件实例中访问的全局属性，组件的属性将具有优先权。这可以代替 Vue 2.x <code>Vue.prototype</code> 扩展。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;);</span><br><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$http</span> = axios;</span><br></pre></td></tr></table></figure><p>可以在组件内通过 <code>getCurrentInstance()</code> 来获取全局 <code>globalProperties</code> 中配置的信息，<code>getCurrentInstance()</code> 获取当前组件的实例，然后通过 ctx 属性获得当前上下文，这样我们就能在 <code>setup()</code> 中使用 router 和 vuex，通过这个属性我们就可以操作变量、全局属性、组件属性等等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; ctx &#125; = <span class="title function_">getCurrentInstance</span>();</span><br><span class="line">  <span class="comment">// ctx.$http</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Suspense-组件"><a href="#Suspense-组件" class="headerlink" title="Suspense 组件"></a>Suspense 组件</h2><p>在介绍 Vue 的 Suspense 组件之前，我们有必要先了解一下 React 的 Suspense 组件，因为它们的功能类似。<br>React.lazy 接受一个函数，这个函数需要动态调用 <code>import()</code>。它必须返回一个 <code>Promise</code>，该 <code>Promise</code> 需要 <code>resolve</code> 一个 default export 的 React 组件。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myComponent = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./Component&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">myComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 3 也新增了 React.lazy 类似功能的 <code>defineAsyncComponent</code> 函数，处理动态引入的组件。<code>defineAsyncComponent</code> 可以接受返回 <code>Promise</code> 的工厂函数。从服务器检索到组件定义时，应该调用 <code>Promise</code> 的解析回调。您还可以调用 <code>reject(reason)</code> 来指示负载已经失败。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./components/AsyncComponent.vue&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&quot;async-component&quot;</span>, <span class="title class_">AsyncComp</span>);</span><br></pre></td></tr></table></figure><p>Vue 3 也新增了 Suspense 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Suspense</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-component</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">fallback</span>&gt;</span> Loading ... <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; defineComponent, defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./Component&quot;</span>));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">MyComponent</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;&#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经过两年多的迭代，Vue 3.0 终于在 9 月 18 日 发布了正式版，底层使用 TypeScript 进行大规模重构，有着很大的改变。Vue 3.0 采用 Composition API，类似 React Hook，使用更加灵活。&lt;/p&gt;
&lt;h2 id=&quot;Vue-2-x</summary>
      
    
    
    
    <category term="前端" scheme="https://xpoet.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="https://xpoet.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 项目动态修改 DOM 的 CSS 伪类</title>
    <link href="https://xpoet.cn/post/694f8d9b6034/"/>
    <id>https://xpoet.cn/post/694f8d9b6034/</id>
    <published>2020-09-29T08:03:06.000Z</published>
    <updated>2023-12-01T07:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Vue 项目中，如何动态修改某个 DOM 元素的 CSS 伪类的值？</p><p>实现方法非常简单，其原理是使用 CSS3 的 <code>var()</code> 函数和 <code>--</code> 变量。</p><p>如下代码案例，动态修改 <code>.demo</code> 元素鼠标悬浮时的背景颜色：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:style</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">         &#x27;--hover-background-color&#x27;: hoverBackgroundColor</span></span></span><br><span class="line"><span class="string"><span class="tag">       &#125;&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">hoverBackgroundColor</span>: <span class="string">&quot;#ccc&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.demo</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="built_in">var</span>(--hover-background-color);</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>template</code> 中，绑定一个 CSS 变量 <code>--hover-background-color</code>。</p></li><li><p><code>script</code> 中，定义一个 JS 变量 <code>hoverBackgroundColor</code>，用以动态控制背景颜色。</p></li><li><p><code>style</code> 中，<code>background</code> 的值用 <code>var(--hover-background-color)</code> 表示。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Vue 项目中，如何动态修改某个 DOM 元素的 CSS 伪类的值？&lt;/p&gt;
&lt;p&gt;实现方法非常简单，其原理是使用 CSS3 的 &lt;code&gt;var()&lt;/code&gt; 函数和 &lt;code&gt;--&lt;/code&gt; 变量。&lt;/p&gt;
&lt;p&gt;如下代码案例，动态修改 &lt;code&gt;.d</summary>
      
    
    
    
    <category term="前端" scheme="https://xpoet.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="https://xpoet.cn/tags/CSS/"/>
    
    <category term="Vue" scheme="https://xpoet.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据结构与算法（十四）图</title>
    <link href="https://xpoet.cn/post/b47bb8401ee1/"/>
    <id>https://xpoet.cn/post/b47bb8401ee1/</id>
    <published>2020-08-09T12:07:45.000Z</published>
    <updated>2024-05-23T08:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h2><p>在计算机程序设计中，图也是一种非常常见的数据结构，图论其实是一个非常大的话题，在数学上起源于哥尼斯堡七桥问题。</p><h3 id="什么是图？"><a href="#什么是图？" class="headerlink" title="什么是图？"></a>什么是图？</h3><ul><li><p>图是一种与树有些相似的数据结构。</p><ul><li>实际上，在数学的概念上，树是图的一种。</li><li>我们知道树可以用来模拟很多现实的数据结构，比如：家谱&#x2F;公司组织架构等等。</li></ul></li><li><p>那么图长什么样子呢？或者什么样的数据使用图来模拟更合适呢？</p><ul><li><p>人与人之间的关系网<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4cdhxz0ereu0.png"                        alt="image"                 ></p></li><li><p>互联网中的网络关系<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4ljxyy69a1s0.png"                        alt="image"                 ></p></li><li><p>广州地铁图<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.46k2cvwmthw0.png"                        alt="image"                 ></p></li></ul></li><li><p>那么，什么是图呢？</p><ul><li>我们会发现，上面的结点（其实图中叫顶点 Vertex）之间的关系，是不能使用树来表示（几叉树都不可以）。</li><li>这个时候，我们就可以使用<strong>图</strong>来模拟它们。</li></ul></li><li><p>图通常有什么特点呢？</p><ul><li>一组顶点：通常用 V (Vertex) 表示顶点的集合</li><li>一组边：通常用 E (Edge) 表示边的集合</li><li>边是顶点和顶点之间的连线</li><li>边可以是有向的，也可以是无向的。（比如 A — B，通常表示无向。A –&gt; B，通常表示有向）</li></ul></li></ul><h3 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><p>我们在学习树的时候，树有很多的其他术语，了解这些术语有助于我们更深层次的理解图。</p></li><li><p>但是图的术语其实非常多，如果你找一本专门讲图的各个方面的书籍，会发现只是术语就可以占据一个章节。</p></li><li><p>这里，这里介绍几个比较常见的术语，某些术语后面用到的时候，再了解，没有用到的，不做赘述。</p></li><li><p>下面这是个抽象出来的图<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.rr153grdbc0.png"                        alt="image"                 ></p></li><li><p>顶点</p><ul><li>顶点刚才我们已经介绍过了，表示图中的一个结点。</li><li>比如地铁站中某个站&#x2F;多个村庄中的某个村庄&#x2F;互联网中的某台主机&#x2F;人际关系中的人。</li></ul></li><li><p>边</p><ul><li>边表示顶点和顶点之间的连线。</li><li>比如地铁站中两个站点之间的直接连线，就是一个边。</li><li>注意：这里的边不要叫做路径，路径有其他的概念，后面会区分。</li></ul></li><li><p>相邻顶点</p><ul><li>由一条边连接在一起的顶点称为相邻顶点。</li><li>比如 <code>0 - 1</code> 是相邻的，<code>0 - 3</code> 是相邻的。<code>0 - 2</code> 是不相邻的。</li></ul></li><li><p>度</p><ul><li>一个顶点的度是相邻顶点的数量</li><li>比如 0 顶点和其他两个顶点相连，0 顶点的度是 2</li><li>比如 1 顶点和其他四个顶点相连，1 顶点的度是 4</li></ul></li><li><p>路径</p><ul><li>路径是顶点 <code>v1</code>，<code>v2</code>…，<code>vn</code> 的一个连续序列，比如上图中 <code>0 1 5 9</code> 就是一条路径。</li><li>简单路径：简单路径要求不包含重复的顶点。比如 <code>0 1 5 9</code> 是一条简单路径。</li><li>回路：第一个顶点和最后一个顶点相同的路径称为回路。比如 <code>0 1 5 6 3 0</code>。</li></ul></li><li><p>无向图</p><ul><li>上面的图就是一张无向图，因为所有的边都没有方向。</li><li>比如 <code>0 - 1</code> 之间有变，那么说明这条边可以保证 <code>0 -&gt; 1</code>，也可以保证 <code>1 -&gt; 0</code>。</li></ul></li><li><p>有向图</p><ul><li>有向图表示的图中的边是有方向的。</li><li>比如 <code>0 -&gt; 1</code>，不能保证一定可以 <code>1 -&gt; 0</code>，要根据方向来定。</li></ul></li></ul><h4 id="无权图和带权图"><a href="#无权图和带权图" class="headerlink" title="无权图和带权图"></a>无权图和带权图</h4><ul><li><p>无权图</p><ul><li>我们上面的图就是一张无权图（边没有携带权重）</li><li>我们上面的图中的边是没有任何意义的，不能收 <code>0 - 1</code> 的边，比 <code>4 - 9</code> 的边更远或者用的时间更长。</li></ul></li><li><p>带权图</p><ul><li>带权图表示边有一定的权重</li><li>这里的权重可以是任意你希望表示的数据：比如距离或者花费的时间或者票价。</li><li>我们来看一张有向和带权的图<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3q0nj5eq5p80.png"                        alt="image"                 ></li></ul></li></ul><h3 id="现实建模"><a href="#现实建模" class="headerlink" title="现实建模"></a>现实建模</h3><ul><li><p>对交通流量建模</p><ul><li>顶点可以表示街道的十字路口，边可以表示街道.。</li><li>加权的边可以表示限速或者车道的数量或者街道的距离。</li><li>建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道。</li></ul></li><li><p>对飞机航线建模</p><ul><li>航空公司可以用图来为其飞行系统建模。</li><li>将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。</li><li>加权的边可以表示从一个机场到另一个机场的航班成本，或两个机场间的距离。</li><li>建模人员可以利用这个系统有效的判断从一个城市到另一个城市的最小航行成本。<br>​</li></ul></li></ul><h2 id="二、图的表示"><a href="#二、图的表示" class="headerlink" title="二、图的表示"></a>二、图的表示</h2><p>我们知道一个图包含很多顶点，另外包含顶点和顶点之间的连线（边），这两个都是非常重要的图信息，因此都需要在程序中体现出来。</p><h3 id="顶点表示"><a href="#顶点表示" class="headerlink" title="顶点表示"></a>顶点表示</h3><ul><li><p>顶点的表示相对简单</p><ul><li>上面的顶点，我们抽象成了 1 2 3 4，也可以抽象成 A B C D。在后面的案例中，我们使用 A B C D。</li><li>那么这些 A B C D 我们可以使用一个数组来存储起来 (存储所有的顶点)。</li><li>当然，A B C D 有可能还表示其他含义的数据 (比如村庄的名字)，这个时候，可以另外创建一个数组，用于存储对应的其他数据。</li></ul></li><li><p>边的表示略微复杂</p><ul><li>因为边是两个顶点之间的关系，所以表示起来会稍微麻烦一些。</li><li>下面是变常见的表示方式。</li></ul></li></ul><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><ul><li><p>概述</p><ul><li>邻接矩阵让每个节点和一个整数向关联，该整数作为数组的下标值。</li><li>我们用一个二维数组来表示顶点之间的连接。</li><li>演示<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.66y7l5b21nw0.png"                        alt="image"                 ></li></ul></li><li><p>图片解析</p><ul><li>在二维数组中，0 表示没有连线，1 表示有连线。</li><li>通过二维数组，我们可以很快的找到一个顶点和哪些顶点有连线。（比如 A 顶点，只需要 遍历第一行即可）</li><li>另外，A - A，B - B（也就是顶点到自己的连线），通常使用 0 表示。</li></ul></li><li><p>邻接矩阵的问题</p><ul><li><p>如果是一个无向图，邻接矩阵展示出来的二维数组，其实是一个对称图。</p><ul><li>也就是 A -&gt; D 是 1 的时候，对称的位置 D -&gt; 1 一定也是 1。</li><li>那么这种情况下会造成空间的浪费，解决办法需自己去研究下。</li></ul></li><li><p>邻接矩阵还有一个比较严重的问题就是如果图是一个稀疏图</p><ul><li>那么矩阵中将存在大量的 0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。</li><li>而且即使只有一个边，我们也必须遍历一行来找出这个边，也浪费很多时间。</li></ul></li></ul></li></ul><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ul><li><p>概述</p><ul><li>邻接表由图中每个顶点以及和顶点相邻的顶点列表组成。</li><li>这个列表有很多中方式来存储：数组&#x2F;链表&#x2F;字典 (哈希表) 都可以。</li><li>演示<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3mu1hv8a84u0.png"                        alt="image"                 ></li></ul></li><li><p>图片解析</p><ul><li>其实图片比较容易理解</li><li>比如我们要表示和 A 顶点有关联的顶点（边），A 和 B&#x2F;C&#x2F;D 有边，那么我们可以通过 A 找到 对应的数组&#x2F;链表&#x2F;字典，再取出其中的内容就可以啦。</li></ul></li><li><p>邻接表的问题</p><ul><li>邻接表计算“出度”是比较简单的（出度：指向别人的数量，入度：指向自己的数量）</li><li>邻接表如果需要计算有向图的“入度”，那么是一件非常麻烦的事情。</li><li>它必须构造一个“逆邻接表”，才能有效的计算“入度”。而临街矩阵会非常简单。</li></ul></li></ul><h2 id="三、图的封装"><a href="#三、图的封装" class="headerlink" title="三、图的封装"></a>三、图的封装</h2><h3 id="创建图类"><a href="#创建图类" class="headerlink" title="创建图类"></a>创建图类</h3><ul><li>先来创建 Graph 类，定义了两个属性：<ul><li><code>vertexes</code> 用于存储所有的顶点，使用一个数组来保存。</li><li><code>adjList</code> adj 是 adjoin 的缩写，邻接的意思。adjList 用于存储所有的边，这里采用邻接表的形式。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vertexes</span> = []; <span class="comment">// 存储顶点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjList</span> = <span class="keyword">new</span> <span class="title class_">Dictionay</span>(); <span class="comment">//存储边信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><ul><li>添加顶点：可以向图中添加一些顶点。<ul><li>将添加的顶点放入到数组中。</li><li>另外，给该顶点创建一个数组<code>[]</code>，该数组用于存储顶点连接的所有的边.（回顾邻接表的实现方式）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加顶点</span></span><br><span class="line"><span class="title function_">addVertex</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="comment">// 添加点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vertexes</span>.<span class="title function_">push</span>(val)</span><br><span class="line">    <span class="comment">// 添加点的关系  采用邻接矩阵法 结构用 Map</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">set</span>(val, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加边：可以指定顶点和顶点之间的边。<ul><li>添加边需要传入两个顶点，因为边是两个顶点之间的边，边不可能单独存在。</li><li>根据顶点 v 取出对应的数组，将 w 加入到它的数组中。</li><li>根据顶点 w 取出对应的数组，将 v 加入到它的数组中。</li><li>因为这里实现的是无向图，所以边是可以双向的。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加边</span></span><br><span class="line"><span class="title function_">addEdge</span>(<span class="params">val1, val2</span>) &#123;</span><br><span class="line">    <span class="comment">// 添加边需要传入两个顶点，因为边是两个顶点之间的边，边不可能单独存在。</span></span><br><span class="line">    <span class="comment">// 这里实现的是无向图，所以这里不考虑方向问题</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(val1).<span class="title function_">push</span>(val2)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(val2).<span class="title function_">push</span>(val1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toString 方法：为了能够正确的显示图的结果，就是拿出二维数组的每一项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出图结构</span></span><br><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">vertexes</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        res += <span class="variable language_">this</span>.<span class="property">vertexes</span>[i] + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">        <span class="keyword">let</span> adj = <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">vertexes</span>[i])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; adj.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            res += adj[j] + <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="string">&quot;\n&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> graph = <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加顶点</span></span><br><span class="line"><span class="keyword">let</span> myVertexes = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="string">&quot;I&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertexes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  graph.<span class="title function_">addVertex</span>(myVertexes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边</span></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;F&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="四、图的遍历"><a href="#四、图的遍历" class="headerlink" title="四、图的遍历"></a>四、图的遍历</h2><p>和其他数据结构一样，需要通过某种算法来遍历图结构中每一个数据。这样可以保证，在我们需要时，通过这种算法来访问某个顶点的数据以及它对应的边。</p><h3 id="遍历的方式"><a href="#遍历的方式" class="headerlink" title="遍历的方式"></a>遍历的方式</h3><ul><li><p>图的遍历思想<br>图的遍历算法的思想在于必须访问每个第一次访问的节点，并且追踪有哪些顶点还没有被访问到。</p></li><li><p>有两种算法可以对图进行遍历</p><ul><li>广度优先搜索 (Breadth-First Search, 简称 BFS)</li><li>深度优先搜索 (Depth-First Search, 简称 DFS)</li><li>两种遍历算法，都需要明确指定第一个被访问的顶点。</li></ul></li><li><p>遍历的注意点</p><ul><li>完全探索一个顶点要求我们便查看该顶点的每一条边。</li><li>对于每一条所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</li><li>为了保证算法的效率：每个顶点至多访问两次。</li></ul></li><li><p>两种算法的思想</p><ul><li>BFS 基于队列，入队列的顶点先被探索。</li><li>DFS 基于栈，通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问。</li></ul></li><li><p>为了记录顶点是否被访问过，我们使用三种颜色来反应它们的状态。(或者两种颜色也可以)</p><ul><li><strong>白色</strong>表示该顶点还没有被访问。</li><li><strong>灰色</strong>表示该顶点被访问过，但并未被探索过。</li><li><strong>黑色</strong>表示该顶点被访问过且被完全探索过。</li><li>初始化颜色代码</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化顶点的颜色</span></span><br><span class="line"><span class="title function_">_initializeColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 白色：表示该顶点还没有被访问。</span></span><br><span class="line">    <span class="comment">// 灰色：表示该顶点被访问过，但并未被探索过。</span></span><br><span class="line">    <span class="comment">// 黑色：表示该顶点被访问过且被完全探索过。</span></span><br><span class="line">    <span class="keyword">let</span> colors = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">vertexes</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        colors[<span class="variable language_">this</span>.<span class="property">vertexes</span>[i]] = <span class="string">&quot;white&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> colors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 (BFS)"></a>广度优先搜索 (BFS)</h3><ul><li><p>广度优先搜索算法的思路<br>广度优先算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深的访问顶点。</p></li><li><p>图解 BFS<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3vz7fx7tgvs0.png"                        alt="image"                 ></p></li><li><p>广度优先搜索的实现</p><ol><li>创建一个队列 Q</li><li>将 v 标注为被发现的 (灰色), 并将 v 将入队列 Q</li><li>如果 Q 非空，执行下面的步骤：<ul><li>将 v 从 Q 中取出队列</li><li>将 v 标注为被发现的灰色</li><li>将 v 所有的未被访问过的邻接点（白色），加入到队列中</li><li>将 v 标志为黑色</li></ul></li></ol></li><li><p>广度优先搜索的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先搜索</span></span><br><span class="line"><span class="title function_">bfs</span>(<span class="params">handle</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.初始化颜色</span></span><br><span class="line">    <span class="keyword">let</span> color = <span class="variable language_">this</span>.<span class="title function_">_initializeColor</span>()</span><br><span class="line">    <span class="comment">// 2. 创建队列</span></span><br><span class="line">    <span class="keyword">let</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span></span><br><span class="line">    <span class="comment">// 3. 将传入的顶点放入队列</span></span><br><span class="line">    queue.<span class="title function_">enqueue</span>(<span class="variable language_">this</span>.<span class="property">vertexes</span>[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 4.依赖队列操作数据   队列不为空时一直持续</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 4.1 拿到队头</span></span><br><span class="line">        <span class="keyword">let</span> qVal = queue.<span class="title function_">dequeue</span>()</span><br><span class="line">        <span class="comment">//  4.2 拿到队头所关联（相连）的点并设置为访问中状态（灰色）</span></span><br><span class="line">        <span class="keyword">let</span> qAdj = <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(qVal)</span><br><span class="line">        color[qVal] = <span class="string">&quot;gray&quot;</span></span><br><span class="line">        <span class="comment">// 4.3 将队头关联的点添加到队尾</span></span><br><span class="line">        <span class="comment">// 这一步是完成bfs的关键，依赖队列的先进先出的特点。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; qAdj.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> a = qAdj[i]</span><br><span class="line">            <span class="keyword">if</span> (color[a] === <span class="string">&quot;white&quot;</span>) &#123;</span><br><span class="line">                color[a] = <span class="string">&quot;gray&quot;</span></span><br><span class="line">                queue.<span class="title function_">enqueue</span>(a)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.5设置访问完的点为黑色。</span></span><br><span class="line">        color[qVal] = <span class="string">&quot;black&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (handle) [</span><br><span class="line">            <span class="title function_">handle</span>(qVal)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用广度优先算法</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">graph.<span class="title function_">bfs</span>(graph.<span class="property">vertexes</span>[<span class="number">0</span>], <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">  result += v + <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// A B C D E F G H I</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 (DFS)"></a>深度优先搜索 (DFS)</h3><p>深度优先搜索的思路：</p><ul><li>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径知道这条路径最后被访问了。</li><li>接着原路回退并探索吓一条路径。</li><li>图解 DFS<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.1bjimck65r8g.png"                        alt="image"                 ></li></ul><p>深度优先搜索算法的实现：</p><ul><li><p>广度优先搜索算法我们使用的是队列，这里可以使用栈完成，也可以使用递归。</p></li><li><p>方便代码书写，我们还是使用递归 (递归本质上就是函数栈的调用)</p></li><li><p>深度优先搜索算法的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="title function_">dfs</span>(<span class="params">handle</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.初始化颜色</span></span><br><span class="line">    <span class="keyword">let</span> color = <span class="variable language_">this</span>.<span class="title function_">_initializeColor</span>()</span><br><span class="line">    <span class="comment">// 2. 遍历所有顶点，开始访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">vertexes</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[<span class="variable language_">this</span>.<span class="property">vertexes</span>[i]] === <span class="string">&quot;white&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">_dfsVisit</span>(<span class="variable language_">this</span>.<span class="property">vertexes</span>[i], color, handle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dfs 的递归方法  这里直接使用函数的调用栈</span></span><br><span class="line"><span class="title function_">_dfsVisit</span>(<span class="params">val, color, handle</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 将颜色设置为访问中</span></span><br><span class="line">    color[val] = <span class="string">&quot;gray&quot;</span></span><br><span class="line">    <span class="comment">// 2. 执行相应的回调</span></span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        <span class="title function_">handle</span>(val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 拿与该点相邻的点，对每个点操作</span></span><br><span class="line">    <span class="keyword">let</span> adj = <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(val)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; adj.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> w = adj[i]</span><br><span class="line">        <span class="comment">// 如果相邻点未未访问状态，开始访问。</span></span><br><span class="line">        <span class="keyword">if</span> (color[w] === <span class="string">&quot;white&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">_dfsVisit</span>(w, color, handle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 处理完后设置为访问过点。</span></span><br><span class="line">    color[val] = <span class="string">&quot;black&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用深度优先算法</span></span><br><span class="line">result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">graph.<span class="title function_">dfs</span>(<span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">  result += v + <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出深度优先</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//A B E I F C D G H</span></span><br></pre></td></tr></table></figure></li><li><p>递归的代码较难理解一些，这副图来帮助理解过程：<br><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.6z6nkgmevxo0.png"                        alt="image"                 ></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图的概念&quot;&gt;&lt;a href=&quot;#图的概念&quot; class=&quot;headerlink&quot; title=&quot;图的概念&quot;&gt;&lt;/a&gt;图的概念&lt;/h2&gt;&lt;p&gt;在计算机程序设计中，图也是一种非常常见的数据结构，图论其实是一个非常大的话题，在数学上起源于哥尼斯堡七桥问题。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="https://xpoet.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图" scheme="https://xpoet.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据结构与算法（十三）二叉搜索树</title>
    <link href="https://xpoet.cn/post/e35d97c028eb/"/>
    <id>https://xpoet.cn/post/e35d97c028eb/</id>
    <published>2020-08-06T08:10:00.000Z</published>
    <updated>2024-05-23T08:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。</p><p>二叉搜索树是一棵二叉树，可以为空。</p><p>如果不为空，则满足以下性质：</p><ul><li>条件 1：非空左子树的所有键值小于其根节点的键值。比如三中节点 6 的所有非空左子树的键值都小于 6；</li><li>条件 2：非空右子树的所有键值大于其根节点的键值；比如三中节点 6 的所有非空右子树的键值都大于 6；</li><li>条件 3：左、右子树本身也都是二叉搜索树；</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.1lhxcdph4vpc.png"                        alt="image"                 ></p><p>如上图所示，树二和树三符合 3 个条件属于二叉树，树一不满足条件 3 所以不是二叉树。</p><p>总结：二叉搜索树的特点主要是较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中“搜索”的来源。</p><h3 id="二叉搜索树应用举例"><a href="#二叉搜索树应用举例" class="headerlink" title="二叉搜索树应用举例"></a>二叉搜索树应用举例</h3><p>下面是一个二叉搜索树：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3l21fsg6qbc0.png"                        alt="image"                 ></p><p>若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。</p><ul><li>第 1 次：将 10 与根节点 9 进行比较，由于 10 &gt; 9，所以 10 下一步与根节点 9 的右子节点 13 比较；</li><li>第 2 次：由于 10 &lt; 13，所以 10 下一步与父节点 13 的左子节点 11 比较；</li><li>第 3 次：由于 10 &lt; 11，所以 10 下一步与父节点 11 的左子节点 10 比较；</li><li>第 4 次：由于 10 &#x3D; 10，最终查找到数据 10。</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.5x9xyvmbxy80.png"                        alt="image"                 ></p><p>同样是 15 个数据，在排序好的数组中查询数据 10，需要查询 10 次：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.2gqz4t2jekw0.png"                        alt="image"                 ></p><p>其实：如果是排序好的数组，可以通过二分查找：第一次找 9，第二次找 13，第三次找 15…。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树。这就是数组二分法查找效率之所以高的原因。</p><h3 id="二叉搜索树的封装"><a href="#二叉搜索树的封装" class="headerlink" title="二叉搜索树的封装"></a>二叉搜索树的封装</h3><p>二叉搜索树有四个最基本的属性：指向节点的根（root），节点中的键（key）、左指针（right）、右指针（right）。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.5vdbb5to1n40.png"                        alt="image"                 ></p><p>所以，二叉搜索树中除了定义 root 属性外，还应定义一个节点内部类，里面包含每个节点中的 left、right 和 key 三个属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的常见操作："><a href="#二叉搜索树的常见操作：" class="headerlink" title="二叉搜索树的常见操作："></a>二叉搜索树的常见操作：</h4><ul><li><code>insert(key)</code> 向树中插入一个新的键。</li><li><code>search(key)</code> 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 <code>false</code>。</li><li><code>preOrderTraverse</code> 通过先序遍历方式遍历所有节点。</li><li><code>inOrderTraverse</code> 通过中序遍历方式遍历所有节点。</li><li><code>postOrderTraverse</code> 通过后序遍历方式遍历所有节点。</li><li><code>min</code> 返回树中最小的值&#x2F;键。</li><li><code>max</code> 返回树中最大的值&#x2F;键。</li><li><code>remove(key)</code> 从树中移除某个键。</li></ul><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>实现思路：</p><ul><li>首先根据传入的 key 创建节点对象。</li><li>然后判断根节点是否存在，不存在时通过：this.root &#x3D; newNode，直接把新节点作为二叉搜索树的根节点。</li><li>若存在根节点则重新定义一个内部方法 <code>insertNode()</code> 用于查找插入点。</li></ul><p>insert(key) 代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert(key) 插入数据</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insertNode() 的实现思路：</p><p>根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。</p><ul><li><p>当 newNode.key &lt; node.key 向左查找：</p><ul><li><p>情况 1：当 node 无左子节点时，直接插入：</p></li><li><p>情况 2：当 node 有左子节点时，递归调用 insertNode()，直到遇到无左子节点成功插入 newNode 后，不再符合该情况，也就不再调用 insertNode()，递归停止。</p></li></ul></li><li><p>当 newNode.key &gt;&#x3D; node.key 向右查找，与向左查找类似：</p><ul><li><p>情况 1：当 node 无右子节点时，直接插入：</p></li><li><p>情况 2：当 node 有右子节点时，依然递归调用 insertNode()，直到遇到传入 insertNode 方法 的 node 无右子节点成功插入 newNode 为止。</p></li></ul></li></ul><p>insertNode(root, node) 代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">insertNode</span>(<span class="params">root, node</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">key</span> &lt; root.<span class="property">key</span>) &#123; <span class="comment">// 往左边查找插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      root.<span class="property">left</span> = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(root.<span class="property">left</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 往右边查找插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      root.<span class="property">right</span> = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(root.<span class="property">right</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h4><p>这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：</p><ul><li>先序遍历；</li><li>中序遍历；</li><li>后序遍历；</li></ul><p>还有层序遍历，使用较少。</p><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p>先序遍历的过程为：</p><p>首先，遍历根节点；<br>然后，遍历其左子树；<br>最后，遍历其右子树；</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.69ooahvtbbo0.png"                        alt="image"                 ></p><p>如上图所示，二叉树的节点遍历顺序为：A -&gt; B -&gt; D -&gt; H -&gt; I -&gt; E -&gt; C -&gt; F -&gt; G。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历（根左右 DLR）</span></span><br><span class="line"><span class="title function_">preorderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">preorderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">preorderTraversalNode</span>(<span class="params">node, result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  result.<span class="title function_">push</span>(node.<span class="property">key</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">preorderTraversalNode</span>(node.<span class="property">left</span>, result);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">preorderTraversalNode</span>(node.<span class="property">right</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p><p>首先，遍历其左子树；<br>然后，遍历根（父）节点；<br>最后，遍历其右子树；</p><p>过程图解：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.762l4sxdr7o0.png"                        alt="image"                 ></p><p>输出节点的顺序应为：3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 14 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 25。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历（左根右 LDR）</span></span><br><span class="line"><span class="title function_">inorderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">inorderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inorderTraversalNode</span>(<span class="params">node, result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">inorderTraversalNode</span>(node.<span class="property">left</span>, result);</span><br><span class="line">  result.<span class="title function_">push</span>(node.<span class="property">key</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">inorderTraversalNode</span>(node.<span class="property">right</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p><p>首先，遍历其左子树；<br>然后，遍历其右子树；<br>最后，遍历根（父）节点；</p><p>过程图解：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.5lqmen4jds80.png"                        alt="image"                 ></p><p>输出节点的顺序应为：3 -&gt; 6 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 9 -&gt; 7 -&gt; 12 -&gt; 14 -&gt; 13 -&gt; 18 -&gt; 25 -&gt; 20 -&gt; 15 -&gt; 11。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历（左右根 LRD）</span></span><br><span class="line"><span class="title function_">postorderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">postorderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">postorderTraversalNode</span>(<span class="params">node, result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">postorderTraversalNode</span>(node.<span class="property">left</span>, result);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">postorderTraversalNode</span>(node.<span class="property">right</span>, result);</span><br><span class="line">  result.<span class="title function_">push</span>(node.<span class="property">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。</p><h4 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h4><h5 id="查找最大值或最小值"><a href="#查找最大值或最小值" class="headerlink" title="查找最大值或最小值"></a>查找最大值或最小值</h5><p>在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左&#x2F;右查找就能得到最值，如下图所示：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3h3yfhyqgi00.png"                        alt="image"                 ></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// min() 获取二叉搜索树最小值</span></span><br><span class="line"><span class="title function_">min</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">  <span class="keyword">while</span> (node.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    node = node.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node.<span class="property">key</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max() 获取二叉搜索树最大值</span></span><br><span class="line"><span class="title function_">max</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">  <span class="keyword">while</span> (node.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    node = node.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node.<span class="property">key</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找特定值"><a href="#查找特定值" class="headerlink" title="查找特定值"></a>查找特定值</h5><p>查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的 key 值与之比较，若 node.key &lt; root 则向左查找，若 node.key &gt; root 就向右查找，直到找到或查找到 null 为止。这里可以使用递归实现，也可以采用循环来实现。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search(key) 查找二叉搜索树中是否有相同的 key，存在返回 true，否则返回 false</span></span><br><span class="line"><span class="title function_">search</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过递归实现</span></span><br><span class="line"><span class="title function_">searchNode</span>(<span class="params">node, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (key &lt; node.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(node.<span class="property">left</span>, key);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(node.<span class="property">right</span>, key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 while 循环实现</span></span><br><span class="line"><span class="title function_">search2</span>(<span class="params">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      node = node.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      node = node.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>实现思路：</p><p>第一步：先找到需要删除的节点，若没找到，则不需要删除；</p><p>首先定义变量 current 用于保存需要删除的节点、变量 parent 用于保存它的父节点、变量 isLeftChild 保存 current 是否为 parent 的左节点，这样方便之后删除节点时改变相关节点的指向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line"><span class="keyword">let</span> parentNode = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild</span></span><br><span class="line"><span class="keyword">while</span> (currentNode.<span class="property">key</span> !== key) &#123;</span><br><span class="line">  parentNode = currentNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 小于，往左查找</span></span><br><span class="line">  <span class="keyword">if</span> (key &lt; currentNode.<span class="property">key</span>) &#123;</span><br><span class="line">    isLeftChild = <span class="literal">true</span>;</span><br><span class="line">    currentNode = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则往右查找</span></span><br><span class="line">    isLeftChild = <span class="literal">false</span>;</span><br><span class="line">    currentNode = currentNode.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到最后都没找到相等的节点，返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (currentNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：删除找到的指定节点，后分 3 种情况：</p><ul><li>删除的是叶子节点；</li><li>删除的是只有一个子节点的节点；</li><li>删除的是有两个子节点的节点；</li></ul><h5 id="删除的是叶子节点"><a href="#删除的是叶子节点" class="headerlink" title="删除的是叶子节点"></a>删除的是叶子节点</h5><p>删除的是叶子节点分两种情况：</p><ul><li><p>叶子节点也是根节点</p><p>当该叶子节点为根节点时，如下图所示，此时 current &#x3D;&#x3D; this.root，直接通过：this.root &#x3D; null，删除根节点。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.1j9353rx9b7k.png"                        alt="image"                 ></p></li><li><p>叶子节点不为根节点</p><p>当该叶子节点不为根节点时也有两种情况，如下图所示</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3r99a6ocvug0.png"                        alt="image"                 ></p><p>若 current &#x3D; 8，可以通过：parent.left &#x3D; null，删除节点 8；</p><p>若 current &#x3D; 10，可以通过：parent.right &#x3D; null，删除节点 10；</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、删除的是叶子节点的情况</span></span><br><span class="line"><span class="keyword">if</span> (currentNode.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; currentNode.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">    parentNode.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parentNode.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、删除的是只有一个子节点的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="删除的是只有一个子节点的节点"><a href="#删除的是只有一个子节点的节点" class="headerlink" title="删除的是只有一个子节点的节点"></a>删除的是只有一个子节点的节点</h5><p>有六种情况：</p><p>当 current 存在左子节点时（current.right &#x3D;&#x3D; null）：</p><ul><li><p>情况 1：current 为根节点（current &#x3D;&#x3D; this.root），如节点 11，此时通过：this.root &#x3D; current.left，删除根节点 11；</p></li><li><p>情况 2：current 为父节点 parent 的左子节点（isLeftChild &#x3D;&#x3D; true），如节点 5，此时通过：parent.left &#x3D; current.left，删除节点 5；</p></li><li><p>情况 3：current 为父节点 parent 的右子节点（isLeftChild &#x3D;&#x3D; false），如节点 9，此时通过：parent.right &#x3D; current.left，删除节点 9；</p></li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.27lwqd0qfnpc.png"                        alt="image"                 ></p><p>当 current 存在右子节点时（current.left &#x3D; null）：</p><ul><li><p>情况 4：current 为根节点（current &#x3D;&#x3D; this.root），如节点 11，此时通过：this.root &#x3D; current.right，删除根节点 11。</p></li><li><p>情况 5：current 为父节点 parent 的左子节点（isLeftChild &#x3D;&#x3D; true），如节点 5，此时通过：parent.left &#x3D; current.right，删除节点 5；</p></li><li><p>情况 6：current 为父节点 parent 的右子节点（isLeftChild &#x3D;&#x3D; false），如节点 9，此时通过：parent.right &#x3D; current.right，删除节点 9；</p></li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3edzg72fx7y0.png"                        alt="image"                 ></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、删除的是只有一个子节点的节点</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.<span class="property">right</span> === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在左节点</span></span><br><span class="line">  <span class="comment">//-- 2.1、currentNode 只存在&lt;左节点&gt;的情况</span></span><br><span class="line">  <span class="comment">//---- 2.1.1、currentNode 等于 root</span></span><br><span class="line">  <span class="comment">//---- 2.1.2、parentNode.left 等于 currentNode</span></span><br><span class="line">  <span class="comment">//---- 2.1.3、parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">    parentNode.<span class="property">left</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parentNode.<span class="property">right</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.<span class="property">left</span> === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在右节点</span></span><br><span class="line">  <span class="comment">//-- 2.2、currentNode 只存在&lt;右节点&gt;的情况</span></span><br><span class="line">  <span class="comment">//---- 2.1.1 currentNode 等于 root</span></span><br><span class="line">  <span class="comment">//---- 2.1.1 parentNode.left 等于 currentNode</span></span><br><span class="line">  <span class="comment">//---- 2.1.1 parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">    parentNode.<span class="property">left</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parentNode.<span class="property">right</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="删除的是有两个子节点的节点"><a href="#删除的是有两个子节点的节点" class="headerlink" title="删除的是有两个子节点的节点"></a>删除的是有两个子节点的节点</h5><p>这种情况十分复杂，首先依据以下二叉搜索树，讨论这样的问题：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4g0geeyv6ya0.png"                        alt="image"                 ></p><p><strong>删除节点 9</strong></p><p>在保证删除节点 9 后原二叉树仍为二叉搜索树的前提下，有两种方式：</p><ul><li>方式 1：从节点 9 的左子树中选择一合适的节点替代节点 9，可知节点 8 符合要求；</li><li>方式 2：从节点 9 的右子树中选择一合适的节点替代节点 9，可知节点 10 符合要求；</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.73rduwimfvo0.png"                        alt="image"                 ></p><p><strong>删除节点 7</strong></p><p>在保证删除节点 7 后原二叉树仍为二叉搜索树的前提下，也有两种方式：</p><ul><li>方式 1：从节点 7 的左子树中选择一合适的节点替代节点 7，可知节点 5 符合要求；</li><li>方式 2：从节点 7 的右子树中选择一合适的节点替代节点 7，可知节点 8 符合要求；</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.2h9hjd5bhwo0.png"                        alt="image"                 ></p><p><strong>删除节点 15</strong></p><p>在保证删除节点 15 后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：</p><ul><li>方式 1：从节点 15 的左子树中选择一合适的节点替代节点 15，可知节点 14 符合要求；</li><li>方式 2：从节点 15 的右子树中选择一合适的节点替代节点 15，可知节点 18 符合要求；</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4f5tzwdvueq0.png"                        alt="image"                 ></p><p>相信你已经发现其中的规律了！</p><p>规律总结：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点下面的子节点中找到一个合适的节点，来替换当前的节点。</p><p>若用 current 表示需要删除的节点，则合适的节点指的是：</p><ul><li>current 左子树中比 current 小一点点的节点，即 current 左子树中的最大值；</li><li>current 右子树中比 current 大一点点的节点，即 current 右子树中的最小值；</li></ul><h6 id="前驱-amp-后继"><a href="#前驱-amp-后继" class="headerlink" title="前驱&amp;后继"></a>前驱&amp;后继</h6><p>在二叉搜索树中，这两个特殊的节点有特殊的名字：</p><ul><li>比 current 小一点点的节点，称为 current 节点的前驱。比如下图中的节点 5 就是节点 7 的前驱；</li><li>比 current 大一点点的节点，称为 current 节点的后继。比如下图中的节点 8 就是节点 7 的后继；</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.71vg0g9z7io0.png"                        alt="image"                 ></p><p>查找需要被删除的节点 current 的后继时，需要在 current 的右子树中查找最小值，即在 current 的右子树中一直向左遍历查找；</p><p>查找前驱时，则需要在 current 的左子树中查找最大值，即在 current 的左子树中一直向右遍历查找。</p><p>下面只讨论查找 current 后继的情况，查找前驱的原理相同，这里暂不讨论。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 3、删除的是有两个子节点的节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、找到后续节点</span></span><br><span class="line">    <span class="keyword">let</span> successor = <span class="variable language_">this</span>.<span class="title function_">getSuccessor</span>(currentNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断是否为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.<span class="property">left</span> = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.<span class="property">right</span> = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将后续的左节点改为被删除的左节点</span></span><br><span class="line">    successor.<span class="property">left</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取后续节点，即从要删除的节点的右边开始查找最小的值</span></span><br><span class="line"><span class="title function_">getSuccessor</span>(<span class="params">delNode</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义变量，保存要找到的后续</span></span><br><span class="line">  <span class="keyword">let</span> successor = delNode;</span><br><span class="line">  <span class="keyword">let</span> current = delNode.<span class="property">right</span>;</span><br><span class="line">  <span class="keyword">let</span> successorParent = delNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找 current 的右子树节点</span></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    successorParent = successor;</span><br><span class="line">    successor = current;</span><br><span class="line">    current = current.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断寻找到的后续节点是否直接就是要删除节点的 right</span></span><br><span class="line">  <span class="keyword">if</span> (successor !== delNode.<span class="property">right</span>) &#123;</span><br><span class="line">    successorParent.<span class="property">left</span> = successor.<span class="property">right</span>;</span><br><span class="line">    successor.<span class="property">right</span> = delNode.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">  <span class="keyword">let</span> parentNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild</span></span><br><span class="line">  <span class="keyword">while</span> (currentNode.<span class="property">key</span> !== key) &#123;</span><br><span class="line"></span><br><span class="line">    parentNode = currentNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于，往左查找</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; currentNode.<span class="property">key</span>) &#123;</span><br><span class="line">      isLeftChild = <span class="literal">true</span>;</span><br><span class="line">      currentNode = currentNode.<span class="property">left</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则往右查找</span></span><br><span class="line">      isLeftChild = <span class="literal">false</span>;</span><br><span class="line">      currentNode = currentNode.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最后都没找到相等的节点，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、删除的是叶子节点的情况</span></span><br><span class="line">  <span class="keyword">if</span> (currentNode.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; currentNode.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、删除的是只有一个子节点的节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.<span class="property">right</span> === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在左节点</span></span><br><span class="line">    <span class="comment">//-- 2.1、currentNode 只存在&lt;左节点&gt;的情况</span></span><br><span class="line">    <span class="comment">//---- 2.1.1、currentNode 等于 root</span></span><br><span class="line">    <span class="comment">//---- 2.1.2、parentNode.left 等于 currentNode</span></span><br><span class="line">    <span class="comment">//---- 2.1.3、parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.<span class="property">left</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.<span class="property">right</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.<span class="property">left</span> === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在右节点</span></span><br><span class="line">    <span class="comment">//-- 2.2、currentNode 只存在&lt;右节点&gt;的情况</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 currentNode 等于 root</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 parentNode.left 等于 currentNode</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.<span class="property">left</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.<span class="property">right</span> = currentNode.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、删除的是有两个子节点的节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、找到后续节点</span></span><br><span class="line">    <span class="keyword">let</span> successor = <span class="variable language_">this</span>.<span class="title function_">getSuccessor</span>(currentNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断是否为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.<span class="property">left</span> = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.<span class="property">right</span> = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将后续的左节点改为被删除的左节点</span></span><br><span class="line">    successor.<span class="property">left</span> = currentNode.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取后续节点，即从要删除的节点的右边开始查找最小的值</span></span><br><span class="line"><span class="title function_">getSuccessor</span>(<span class="params">delNode</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义变量，保存要找到的后续</span></span><br><span class="line">  <span class="keyword">let</span> successor = delNode;</span><br><span class="line">  <span class="keyword">let</span> current = delNode.<span class="property">right</span>;</span><br><span class="line">  <span class="keyword">let</span> successorParent = delNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找 current 的右子树节点</span></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    successorParent = successor;</span><br><span class="line">    successor = current;</span><br><span class="line">    current = current.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断寻找到的后续节点是否直接就是要删除节点的 right</span></span><br><span class="line">  <span class="keyword">if</span> (successor !== delNode.<span class="property">right</span>) &#123;</span><br><span class="line">    successorParent.<span class="property">left</span> = successor.<span class="property">right</span>;</span><br><span class="line">    successor.<span class="property">right</span> = delNode.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>二叉搜索树的缺陷：当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树由 11 7 15 组成，如下图所示：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.1nkd51rg5dz4.png"                        alt="image"                 ></p><p>当插入一组有序数据：6 5 4 3 2 就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.154bnlgtd5z4.png"                        alt="image"                 ></p><p>非平衡树</p><ul><li>比较好的二叉搜索树，它的数据应该是左右均匀分布的。</li><li>但是插入连续数据后，二叉搜索树中的数据分布就变得不均匀了，我们称这种树为非平衡树。</li><li>对于一棵平衡二叉树来说，插入&#x2F;查找等操作的效率是 O(log n)。</li><li>而对于一棵非平衡二叉树来说，相当于编写了一个链表，查找效率变成了 O(n)。</li></ul><p>树的平衡性</p><p>为了能以较快的时间 O(log n) 来操作一棵树，我们需要保证树总是平衡的：</p><ul><li>起码大部分是平衡的，此时的时间复杂度也是接近 O(log n) 的；</li><li>这就要求树中每个节点左边的子孙节点的个数，应该尽可能地等于右边的子孙节点的个数；</li></ul><p>常见的平衡树</p><ul><li>AVL 树：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于 AVL 树是平衡树，所以它的时间复杂度也是 O(log n)。但是它的整体效率不如红黑树，开发中比较少用。</li><li>红黑树：同样通过一些特性来保持树的平衡，时间复杂度也是 O(log n)。进行插入&#x2F;删除等操作时，性能优于 AVL 树，所以平衡树的应用基本都是红黑树。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉搜索树&quot;&gt;&lt;a href=&quot;#二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树&quot;&gt;&lt;/a&gt;二叉搜索树&lt;/h2&gt;&lt;p&gt;二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。&lt;/p&gt;
&lt;p&gt;二叉搜索树</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="https://xpoet.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="二叉搜索树" scheme="https://xpoet.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据结构与算法（十二）二叉树</title>
    <link href="https://xpoet.cn/post/070b16d562fc/"/>
    <id>https://xpoet.cn/post/070b16d562fc/</id>
    <published>2020-08-05T10:09:00.000Z</published>
    <updated>2024-05-23T08:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>如果树中的每一个节点最多只能由两个子节点，这样的树就称为二叉树；</p><h3 id="二叉树的组成"><a href="#二叉树的组成" class="headerlink" title="二叉树的组成"></a>二叉树的组成</h3><ul><li>二叉树可以为空，也就是没有节点；</li><li>若二叉树不为空，则它由根节点和称为其左子树 TL 和右子树 TR 的两个不相交的二叉树组成；</li></ul><h3 id="二叉树的五种形态"><a href="#二叉树的五种形态" class="headerlink" title="二叉树的五种形态"></a>二叉树的五种形态</h3><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.15ycsg4fqoio.png"                        alt="image"                 ></p><p>上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树 TL 的二叉树、只有右子树 TR 的二叉树和有左右两个子树的二叉树。</p><h3 id="二叉树的特性"><a href="#二叉树的特性" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h3><ul><li>一个二叉树的第 i 层的最大节点树为：2^(i-1)^，i &gt;&#x3D; 1；</li><li>深度为 k 的二叉树的最大节点总数为：2^k^ - 1，k &gt;&#x3D; 1；</li><li>对任何非空二叉树，若 n<del>0</del> 表示叶子节点的个数，n<del>2</del>表示度为 2 的非叶子节点个数，那么两者满足关系：n<del>0</del> &#x3D; n<del>2</del> + 1；如下图所示：H，E，I，J，G 为叶子节点，总数为 5；A，B，C，F 为度为 2 的非叶子节点，总数为 4；满足 n<del>0</del> &#x3D; n<del>2</del> + 1 的规律。</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.syjwffjltmo.png"                        alt="image"                 ></p><h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><h4 id="完美二叉树"><a href="#完美二叉树" class="headerlink" title="完美二叉树"></a>完美二叉树</h4><p>完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有 2 个子节点，这就构成了完美二叉树。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.223b2axrocf4.png"                        alt="image"                 ></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>完全二叉树（Complete Binary Tree）:</p><ul><li>除了二叉树最后一层外，其他各层的节点数都达到了最大值；</li><li>并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；</li><li>完美二叉树是特殊的完全二叉树；</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.5y4rglrp8qk0.png"                        alt="image"                 ></p><p>在上图中，由于 H 缺失了右子节点，所以它不是完全二叉树。</p><h3 id="二叉树的数据存储"><a href="#二叉树的数据存储" class="headerlink" title="二叉树的数据存储"></a>二叉树的数据存储</h3><p>常见的二叉树存储方式为数组和链表：</p><h4 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h4><ul><li>完全二叉树：按从上到下，从左到右的方式存储数据。</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.29w4k62b51og.png"                        alt="image"                 ></p><table><thead><tr><th align="center">节点</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th><th align="center">G</th><th align="center">H</th><th align="center">I</th></tr></thead><tbody><tr><td align="center">序号</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td></tr></tbody></table><p>使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 _ 2，右子节点的序号等于父节点序号 _ 2 + 1。</p><ul><li>非完全二叉树：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4jgiq6r2xee0.png"                        alt="image"                 ></p><table><thead><tr><th align="center">节点</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">^</th><th align="center">^</th><th align="center">F</th><th align="center">^</th><th align="center">^</th><th align="center">^</th><th align="center">^</th><th align="center">^</th><th align="center">^</th><th align="center">M</th></tr></thead><tbody><tr><td align="center">序号</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">10</td><td align="center">11</td><td align="center">12</td><td align="center">13</td></tr></tbody></table><h4 id="使用链表"><a href="#使用链表" class="headerlink" title="使用链表"></a>使用链表</h4><p>二叉树最常见的存储方式为链表：每一个节点封装成一个 Node，Node 中包含存储的数据、左节点的引用和右节点的引用。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.2mlscfad5420.png"                        alt="image"                 ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;p&gt;如果树中的每一个节点最多只能由两个子节点，这样的树就称为二叉树；&lt;/p&gt;
&lt;h3 id=&quot;二叉树的组成&quot;&gt;&lt;a href=&quot;#二叉树</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="https://xpoet.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="二叉树" scheme="https://xpoet.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据结构与算法（十一）树</title>
    <link href="https://xpoet.cn/post/2fb3cffe3d06/"/>
    <id>https://xpoet.cn/post/2fb3cffe3d06/</id>
    <published>2020-08-03T02:01:22.000Z</published>
    <updated>2024-05-23T08:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是树？"><a href="#什么是树？" class="headerlink" title="什么是树？"></a>什么是树？</h3><h4 id="真实的树："><a href="#真实的树：" class="headerlink" title="真实的树："></a>真实的树：</h4><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.6pnzzxbinjs0.png"                        alt="image"                 ></p><h4 id="树的特点："><a href="#树的特点：" class="headerlink" title="树的特点："></a>树的特点：</h4><ul><li>树一般都有一个根，连接着根的是树干；</li><li>树干会发生分叉，形成许多树枝，树枝会继续分化成更小的树枝；</li><li>树枝的最后是叶子；</li></ul><p>现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转 <code>180°</code> 的树。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4mrygbtnd6w0.png"                        alt="image"                 ></p><h4 id="树结构对比于数组-x2F-链表-x2F-哈希表有哪些优势呢？"><a href="#树结构对比于数组-x2F-链表-x2F-哈希表有哪些优势呢？" class="headerlink" title="树结构对比于数组&#x2F;链表&#x2F;哈希表有哪些优势呢？"></a>树结构对比于数组&#x2F;链表&#x2F;哈希表有哪些优势呢？</h4><p>数组：</p><ul><li>优点：可以通过下标值访问，效率高；</li><li>缺点：查找数据时需要先对数据进行排序，生成有序数组，才能提高查找效率；并且在插入和删除元素时，需要大量的位移操作；</li></ul><p>链表：</p><ul><li>优点：数据的插入和删除操作效率都很高；</li><li>缺点：查找效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。</li></ul><p>哈希表：</p><ul><li>优点：哈希表的插入&#x2F;查询&#x2F;删除效率都非常高；</li><li>缺点：空间利用率不高，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是无序的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中最大值或最小值这些特殊值。</li></ul><p>树结构：</p><ul><li>优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。</li></ul><p>总的来说：每种数据结构都有自己特定的应用场景。</p><p>树结构：</p><ul><li><p>树（Tree）：由 n（n ≥ 0）个节点构成的有限集合。当 n &#x3D; 0 时，称为空树。</p></li><li><p>对于任意一棵非空树（n &gt; 0），它具备以下性质：</p><ul><li>数中有一个称为根（Root）的特殊节点，用 <strong>r</strong> 表示；</li><li>其余节点可分为 m（m &gt; 0）个互不相交的有限集合 T1，T2，…，Tm，其中每个集合本身又是一棵树，称为原来树的子树（SubTree）。</li></ul></li></ul><h4 id="树的常用术语："><a href="#树的常用术语：" class="headerlink" title="树的常用术语："></a>树的常用术语：</h4><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3t0ypfn5leo0.png"                        alt="image"                 ></p><ul><li>节点的度（Degree）：节点的子树个数，比如节点 B 的度为 2；</li><li>树的度：树的所有节点中最大的度数，如上图树的度为 2；</li><li>叶节点（Leaf）：度为 0 的节点（也称为叶子节点），如上图的 H，I 等；</li><li>父节点（Parent）：度不为 0 的节点称为父节点，如上图节点 B 是节点 D 和 E 的父节点；</li><li>子节点（Child）：若 B 是 D 的父节点，那么 D 就是 B 的子节点；</li><li>兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点，比如上图的 B 和 C，D 和 E 互为兄弟节点；</li><li>路径和路径长度：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如 A-&gt;H 的路径长度为 3；</li><li>节点的层次（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1。如 B 和 C 节点的层次为 2；</li><li>树的深度（Depth）：树种所有节点中的最大层次是这棵树的深度，如上图树的深度为 4；</li></ul><h4 id="树结构的表示方式"><a href="#树结构的表示方式" class="headerlink" title="树结构的表示方式"></a>树结构的表示方式</h4><h5 id="最普通的表示方法："><a href="#最普通的表示方法：" class="headerlink" title="最普通的表示方法："></a>最普通的表示方法：</h5><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4v9sayu9zu60.png"                        alt="image"                 ></p><p>如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点 A 需要 3 个引用，分别指向子节点 B，C，D；B 节点需要 2 个引用，分别指向子节点 E 和 F；K 节点由于没有子节点，所以不需要引用。</p><p>这种方法缺点在于我们无法确定某一结点的引用数。</p><h5 id="儿子-兄弟表示法："><a href="#儿子-兄弟表示法：" class="headerlink" title="儿子 - 兄弟表示法："></a>儿子 - 兄弟表示法：</h5><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3o34yy6h0420.png"                        alt="image"                 ></p><p>这种表示方法可以完整地记录每个节点的数据，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点 A</span></span><br><span class="line"><span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="comment">//存储数据</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line">  <span class="comment">//统一只记录左边的子节点</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">leftChild</span> = B</span><br><span class="line">  <span class="comment">//统一只记录右边的第一个兄弟节点</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">rightSibling</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点 B</span></span><br><span class="line"><span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">leftChild</span> = E</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">rightSibling</span> = C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点 F</span></span><br><span class="line"><span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">leftChild</span> = <span class="literal">null</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">rightSibling</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种表示法的优点在于每一个节点中引用的数量都是确定的。</p><h5 id="儿子-兄弟表示法旋转"><a href="#儿子-兄弟表示法旋转" class="headerlink" title="儿子 - 兄弟表示法旋转"></a>儿子 - 兄弟表示法旋转</h5><p>以下为儿子 - 兄弟表示法组成的树结构：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.6tucreh71ok0.png"                        alt="image"                 ></p><p>将其顺时针旋转 45° 之后：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4blmsiyhevg0.png"                        alt="image"                 ></p><p>这样就成为了一棵二叉树，由此我们可以得出结论：任何树都可以通过二叉树进行模拟。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是树？&quot;&gt;&lt;a href=&quot;#什么是树？&quot; class=&quot;headerlink&quot; title=&quot;什么是树？&quot;&gt;&lt;/a&gt;什么是树？&lt;/h3&gt;&lt;h4 id=&quot;真实的树：&quot;&gt;&lt;a href=&quot;#真实的树：&quot; class=&quot;headerlink&quot; title=&quot;真实的</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="https://xpoet.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://xpoet.cn/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据结构与算法（十）哈希表</title>
    <link href="https://xpoet.cn/post/792c9a94eea1/"/>
    <id>https://xpoet.cn/post/792c9a94eea1/</id>
    <published>2020-08-02T01:12:11.000Z</published>
    <updated>2024-05-23T08:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识哈希表"><a href="#认识哈希表" class="headerlink" title="认识哈希表"></a>认识哈希表</h2><p>哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构。</p><p>哈希表通常是基于数组实现的，但是相对于数组，它存在更多优势：</p><ul><li>哈希表可以提供非常快速的 <strong>插入 - 删除 - 查找</strong> 操作。</li><li>无论多少数据，插入和删除值都只需接近常量的时间，即 <strong>O(1)</strong> 的时间复杂度。实际上，只需要几个机器指令即可完成。</li><li>哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。</li><li>哈希表相对于树来说编码要简单得多。</li></ul><p>哈希表同样存在不足之处：</p><ul><li>哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。</li><li>通常情况下，哈希表中的 <code>key</code> 是不允许重复的，不能放置相同的 <code>key</code>，用于保存不同的元素。</li></ul><p>哈希表是什么？</p><ul><li>哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。</li><li>哈希表的结构就是数组，但它<strong>神奇之处在于对下标值的一种变换</strong>，这种变换我们可以称之为<strong>哈希函数</strong>，通过哈希函数可以获取 HashCode。</li></ul><p>通过以下案例了解哈希表：</p><ul><li><p>案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。</p></li><li><p>案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。</p></li></ul><p>也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的映射关系。</p><h3 id="认识哈希化"><a href="#认识哈希化" class="headerlink" title="认识哈希化"></a>认识哈希化</h3><p>为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如 a 为 1，b 为 2，c 为 3，以此类推 z 为 26，空格为 27（不考虑大写情况）。</p><p>有了编码系统后，将字母转化为数字也有很多种方案：</p><ul><li>方案一：数字相加。</li></ul><p>例如 cats 转化为数字：<code>3 + 1 + 20 + 19 = 43</code>，那么就把 43 作为 cats 单词的下标值储存在数组中；</p><p>但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是 43，比如 was。而在数组中一个下标值只能储存一个数据，所以该方式不合理。</p><ul><li>方案二：幂的连乘。</li></ul><p>我们平时使用的大于 10 的数字，就是用幂的连乘来表示它的唯一性的。<br>比如： <code>6543 = 6 * 10^3 + 5 * 10^2 + 4 * 10 + 3</code>；这样单词也可以用该种方式来表示：<code>cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337</code>。</p><p>虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如 aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组，然而其中却有许多下标值指向的是无效的数据（比如不存在 zxcvvv 这样的单词），造成了数组空间的浪费。</p><p>两种方案总结：</p><ul><li>第一种方案（让数字相加求和）产生的数组下标太少。</li><li>第二种方案（与 27 的幂相乘求和）产生的数组下标又太多。</li></ul><p>现在需要一种压缩方法，把幂的连乘方案系统中得到的<strong>巨大整数范围压缩到可接受的数组范围中</strong>。可以通过<strong>取余</strong>操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。</p><h3 id="哈希表的一些概念"><a href="#哈希表的一些概念" class="headerlink" title="哈希表的一些概念"></a>哈希表的一些概念</h3><ul><li><p><strong>哈希化</strong></p><p>将<strong>大数字</strong>转化成<strong>数组范围内下标</strong>的过程，称之为哈希化。</p></li><li><p><strong>哈希函数</strong></p><p>我们通常会将单词转化成大数字，把大数字进行哈希化的代码实现放在一个函数中，该函数就称为哈希函数。</p></li><li><p><strong>哈希表</strong></p><p>对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。</p></li></ul><h3 id="地址的冲突"><a href="#地址的冲突" class="headerlink" title="地址的冲突"></a>地址的冲突</h3><p>在实际中，经过哈希函数哈希化过后得到的下标值可能有重复，这种情况称为冲突，冲突是不可避免的，我们只能解决冲突。</p><p>解决冲突常见的两种方案：链地址法（拉链法）和开放地址法。</p><h4 id="链地址法（拉链法）"><a href="#链地址法（拉链法）" class="headerlink" title="链地址法（拉链法）"></a>链地址法（拉链法）</h4><p>如下图所示，我们将每一个数字都对 10 进行取余操作，则余数的范围 0~9 作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的数组或链表。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.5irlba213e00.png"                        alt="image"                 ></p><p>这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。</p><p>总结：链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一条链条，这条链条常使用的数据结构为数组或链表，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。</p><h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><p>开放地址法的主要工作方式是寻找空白的单元格来放置冲突的数据项。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.52qzixg5w4s0.png"                        alt="image"                 ></p><p>根据探测空白单元格位置方式的不同，可分为三种方法：</p><ul><li>线性探测</li><li>二次探测</li><li>再哈希法</li></ul><h5 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h5><ul><li>当插入 13 时：</li></ul><p>经过哈希化（对 10 取余）之后得到的下标值 index&#x3D;3，但是该位置已经放置了数据 33。而线性探测就是从 index 位置 +1 开始向后一个一个来查找合适的位置来放置 13，所谓合适的位置指的是空的位置，如上图中 index&#x3D;4 的位置就是合适的位置。</p><ul><li><p>当查询 13 时：</p><ul><li>首先 13 经过哈希化得到 index&#x3D;3，如果 index&#x3D;3 的位置存放的数据与需要查询的数据 13 相同，就直接返回；<br>不相同时，则线性查找，从 index+1 位置开始一个一个位置地查找数据 13。</li><li>查询过程中不会遍历整个哈希表，只要查询到空位置，就停止，因为插入 13 时不会跳过空位置去插入其他位置。</li></ul></li><li><p>当删除 13 时：</p><ul><li>删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，不能将该位置下标的内容设置为 null，否则会影响到之后其他的查询操作，因为一遇到为 null 的位置就会停止查找。</li><li>通常删除一个位置的数据项时，我们可以将它进行特殊处理（比如设置为 -1），这样在查找时遇到 -1 就知道要继续查找。</li></ul></li></ul><p>线性探测存在的问题：</p><ul><li><p>线性探测存在一个比较严重的问题，就是聚集。</p></li><li><p>如哈希表中还没插入任何元素时，插入 23、24、25、26、27，这就意味着下标值为 3、4、5、6、7 的位置都放置了数据，这种一连串填充单元就称为聚集。</p></li><li><p>聚集会影响哈希表的性能，无论是插入&#x2F;查询&#x2F;删除都会影响。</p></li><li><p>比如插入 13 时就会发现，连续的单元 3~7 都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。</p></li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.47l36021j8m0.png"                        alt="image"                 ></p><h5 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h5><p>上文所说的线性探测存在的问题：</p><ul><li><p>如果之前的数据是连续插入的，那么新插入的一个数据可能需要探测很长的距离；</p><p>二次探测是在线性探测的基础上进行了优化：</p></li><li><p>线性探测：我们可以看成是步长为 1 的探测，比如从下表值 x 开始，那么线性探测就是按照下标值：x+1、x+2、x+3 等依次探测；</p></li><li><p>二次探测：对步长进行了优化，比如从下标值 x 开始探测：x+1^2^、x+2^2^、x+3^3^ 。这样一次性探测比较长的距离，避免了数据聚集带来的影响。</p></li><li><p>二次探测存在的问题：</p><p>当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成步长不一的一种聚集（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。</p></li></ul><h5 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h5><p>在开放地址法中寻找空白单元格的最好的解决方式为再哈希化。</p><ul><li>二次探测的步长是固定的：1，4，9，16 依次类推。</li><li>现在需要一种方法：产生一种依赖关键字 (数据) 的探测序列，而不是每个关键字探测步长都一样。</li><li>这样，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。</li><li>再哈希法的做法为：把关键字用另一个哈希函数，再做一次哈希化，用这次哈希化的结果作为该关键字的步长。</li></ul><p>第二次哈希化需要满足以下两点：</p><ul><li>和第一个哈希函数不同，不然哈希化后的结果仍是原来位置；</li><li>不能输出为 0，否则每次探测都是原地踏步的死循环；</li></ul><p>优秀的哈希函数：</p><ul><li>stepSize &#x3D; constant - （key % constant）；</li><li>其中 constant 是质数，且小于数组的容量；</li><li>例如：stepSize &#x3D; 5 - （key % 5），满足需求，并且结果不可能为 0；</li></ul><p>哈希化的效率</p><p>哈希表中执行插入和搜索操作效率是非常高的。</p><ul><li>如果没有发生冲突，那么效率就会更高；</li><li>如果发生冲突，存取时间就依赖后来的探测长度；</li><li>平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度会越来越长。</li></ul><h4 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h4><ul><li>装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值；</li><li>装填因子 &#x3D; 总数据项 &#x2F; 哈希表长度；</li><li>开放地址法的装填因子最大为 1，因为只有空白的单元才能放入元素；</li><li>链地址法的装填因子可以大于 1，因为只要愿意，拉链法可以无限延伸下去；</li></ul><h4 id="不同探测方式性能的比较"><a href="#不同探测方式性能的比较" class="headerlink" title="不同探测方式性能的比较"></a>不同探测方式性能的比较</h4><ul><li><p>线性探测</p><p>可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.2pcxv1f720o0.png"                        alt="image"                 ></p></li><li><p>二次探测和再哈希化的性能</p><p>二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.f06tizypf6g.png"                        alt="image"                 ></p></li><li><p>链地址法的性能</p><p>可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如 Java 中的 HashMap 中使用的就是链地址法。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.45s3ntwwjia0.png"                        alt="image"                 ></p></li></ul><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中尽量减少乘法和除法。</p><p>性能高的哈希函数应具备以下两个优点：</p><ul><li>快速的计算；</li><li>均匀的分布；</li></ul><h4 id="快速计算"><a href="#快速计算" class="headerlink" title="快速计算"></a>快速计算</h4><p>霍纳法则：在中国霍纳法则也叫做秦久韶算法，具体算法为：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4kz61djvvau0.png"                        alt="image"                 ></p><p>求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求 n 次多项式 f(x) 的值就转化为求 n 个一次多项式的值。</p><ul><li><p>变换之前：</p><ul><li>乘法次数：n(n+1)&#x2F;2 次；</li><li>加法次数：n 次；</li></ul></li><li><p>变换之后：</p><ul><li>乘法次数：n 次；</li><li>加法次数：n 次；</li></ul></li></ul><p>如果使用大 O 表示时间复杂度的话，直接从变换前的 O(N^2) 降到了 O(N)。</p><h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><p>在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：链地址法或者开放地址法。但是，为了提供效率，最好的情况还是让数据在哈希表中均匀分布。因此，我们需要在使用常量的地方，尽量使用质数。比如：哈希表的长度、N 次幂的底数等。</p><p>Java 中的 HashMap 采用的是链地址法，哈希化采用的是公式为：index &#x3D; HashCode(key) &amp; (Length-1) 即将数据化为二进制进行与运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是 JavaScript 在进行较大数据的与运算时会出现问题，所以我们使用 JavaScript 实现哈希化时采用取余运算。</p><h2 id="封装哈希表"><a href="#封装哈希表" class="headerlink" title="封装哈希表"></a>封装哈希表</h2><h3 id="哈希表常见操作"><a href="#哈希表常见操作" class="headerlink" title="哈希表常见操作"></a>哈希表常见操作</h3><ul><li><code>put(key, value)</code> 插入或修改操作。</li><li><code>get(key)</code> 获取哈希表中特定位置的元素。</li><li><code>remove(key)</code> 删除哈希表中特定位置的元素。</li><li><code>isEmpty()</code> 如果哈希表中不包含任何元素，返回 <code>trun</code>，如果哈希表长度大于 0 则返回 <code>false</code>。</li><li><code>size()</code> 返回哈希表包含的元素个数。</li><li><code>resize(value)</code> 对哈希表进行扩容操作。</li></ul><h3 id="哈希函数的简单实现"><a href="#哈希函数的简单实现" class="headerlink" title="哈希函数的简单实现"></a>哈希函数的简单实现</h3><p>首先使用霍纳法则计算 hashCode 的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">hashFn</span>(<span class="params">string, limit = <span class="number">7</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自己采用的一个质数（无强制要求，质数即可）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">PRIME</span> = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、定义存储 hashCode 的变量</span></span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、使用霍纳法则（秦九韶算法），计算 hashCode 的值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> string) &#123;</span><br><span class="line">    hashCode = <span class="variable constant_">PRIME</span> * hashCode + item.<span class="title function_">charCodeAt</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3、对 hashCode 取余，并返回</span></span><br><span class="line">  <span class="keyword">return</span> hashCode % limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希函数测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hashFn</span>(<span class="string">&quot;123&quot;</span>)); <span class="comment">//--&gt; 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hashFn</span>(<span class="string">&quot;abc&quot;</span>)); <span class="comment">//--&gt; 6</span></span><br></pre></td></tr></table></figure><h3 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h3><h4 id="创建哈希表类"><a href="#创建哈希表类" class="headerlink" title="创建哈希表类"></a>创建哈希表类</h4><p>封装的哈希表的数据结构模型：</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.7h3eahcbrvs0.png"                        alt="image"                 ></p><p>首先创建哈希表类 HashTable，并添加必要的属性和上面实现的哈希函数，再进行其他方法的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = []; <span class="comment">// 哈希表存储数据的变量</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>; <span class="comment">// 当前存放的元素个数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = <span class="number">7</span>; <span class="comment">// 哈希表长度（初始设为质数 7）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put-key-value"><a href="#put-key-value" class="headerlink" title="put(key,value)"></a>put(key,value)</h4><p>哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个 <code>[key, value]</code> 时，如果原来不存在该 key，那么就是插入操作，如果原来已经存在该 key，那么就是修改操作。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.2a81gwdznn8k.png"                        alt="image"                 ></p><p>实现思路：</p><ul><li>首先，根据 key 获取索引值 index，目的为将数据插入到 storage 的对应位置；</li><li>然后，根据索引值取出 bucket，如果 bucket 不存在，先创建 bucket，随后放置在该索引值的位置；</li><li>接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。</li><li>最后，进行新增数据操作。</li></ul><p>代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put(key, value) 往哈希表里添加数据</span></span><br><span class="line"><span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取）</span></span><br><span class="line">  <span class="keyword">const</span> index = <span class="title function_">hashFn</span>(key, <span class="variable language_">this</span>.<span class="property">limit</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、根据 index 取出对应的 bucket</span></span><br><span class="line">  <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3、判断是否存在 bucket</span></span><br><span class="line">  <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    bucket = [];  <span class="comment">// 不存在则创建</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span>[index] = bucket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4、判断是插入数据操作还是修改数据操作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tuple = bucket[i]; <span class="comment">// tuple 的格式：[key, value]</span></span><br><span class="line">    <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123; <span class="comment">// 如果 key 相等，则修改数据</span></span><br><span class="line">      tuple[<span class="number">1</span>] = value;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 修改完 tuple 里数据，return 终止不再往下执行。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5、bucket 新增数据</span></span><br><span class="line">  bucket.<span class="title function_">push</span>([key, value]); <span class="comment">// bucket 存储元组 tuple，格式为 [key, value]</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">limit</span> &gt; <span class="variable language_">this</span>.<span class="property">loadFactor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="title function_">getPrime</span>(<span class="variable language_">this</span>.<span class="property">limit</span> * <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-key"><a href="#get-key" class="headerlink" title="get(key)"></a>get(key)</h4><p>实现思路：</p><ul><li>首先，根据 key 通过哈希函数获取它在 <code>storage</code> 中对应的索引值 <code>index</code>。</li><li>然后，根据索引值获取对应的 <code>bucket</code>。</li><li>接着，判断获取到的 <code>bucket</code> 是否为 <code>null</code>，如果为 <code>null</code>，直接返回 <code>null</code>。</li><li>随后，线性遍历 <code>bucket</code> 中每一个 <code>key</code> 是否等于传入的 <code>key</code>。如果等于，直接返回对应的 <code>value</code>。</li><li>最后，遍历完 <code>bucket</code> 后，仍然没有找到对应的 <code>key</code>，直接 <code>return null</code> 即可。</li></ul><p>代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 get(key) 获取 value</span></span><br><span class="line"><span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> index = <span class="title function_">hashFn</span>(key, <span class="variable language_">this</span>.<span class="property">limit</span>);</span><br><span class="line">  <span class="keyword">const</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> tuple <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">      <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-key"><a href="#remove-key" class="headerlink" title="remove(key)"></a>remove(key)</h4><p>实现思路：</p><ul><li>首先，根据 key 通过哈希函数获取它在 <code>storage</code> 中对应的索引值 <code>index</code>。</li><li>然后，根据索引值获取对应的 <code>bucket</code>。</li><li>接着，判断获取到的 <code>bucket</code> 是否为 <code>null</code>，如果为 <code>null</code>，直接返回 <code>null</code>。</li><li>随后，线性查找 <code>bucket</code>，寻找对应的数据，并且删除。</li><li>最后，依然没有找到，返回 <code>null</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove(key) 删除指定 key 的数据</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> index = <span class="title function_">hashFn</span>(key, <span class="variable language_">this</span>.<span class="property">limit</span>);</span><br><span class="line">  <span class="keyword">const</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 bucket，找到对应位置的 tuple，将其删除</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = bucket.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">    <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">      bucket.<span class="title function_">splice</span>(i, <span class="number">1</span>); <span class="comment">// 删除对应位置的数组项</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据装填因子的大小，判断是否要进行哈希表压缩</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">limit</span> &gt; <span class="number">7</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">limit</span> &lt; <span class="variable language_">this</span>.<span class="property">minLoadFactor</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="title function_">getPrime</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="variable language_">this</span>.<span class="property">limit</span> / <span class="number">2</span>)));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> tuple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表的扩容与压缩"><a href="#哈希表的扩容与压缩" class="headerlink" title="哈希表的扩容与压缩"></a>哈希表的扩容与压缩</h2><p>为什么需要扩容？</p><ul><li><p>前面我们在哈希表中使用的是长度为 7 的数组，由于使用的是链地址法，装填因子 (loadFactor) 可以大于 1，所以这个哈希表可以无限制地插入新数据。</p></li><li><p>但是，随着数据量的增多，storage 中每一个 <code>index</code> 对应的 <code>bucket</code> 数组（链表）就会越来越长，这就会造成哈希表效率的降低。</p></li></ul><p>什么情况下需要扩容？</p><ul><li>常见的情况是 <code>loadFactor &gt; 0.75</code> 的时候进行扩容。</li></ul><p>如何进行扩容？</p><ul><li>简单的扩容可以直接扩大两倍（关于质数，之后讨论）。</li><li>扩容之后所有的数据项都要进行同步修改。</li></ul><p>实现思路：</p><ul><li>首先，定义一个变量，比如 oldStorage 指向原来的 <code>storage</code>。</li><li>然后，创建一个新的容量更大的数组，让 <code>this.storage</code> 指向它。</li><li>最后，将 oldStorage 中的每一个 bucket 中的每一个数据取出来依次添加到 <code>this.storage</code> 指向的新数组中。</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.7xrayvjwh2w.png"                        alt="image"                 ></p><h3 id="resize-的实现"><a href="#resize-的实现" class="headerlink" title="resize() 的实现"></a>resize() 的实现</h3><p>装填因子 &#x3D; 哈希表中数据 &#x2F; 哈希表长度，即 <code>loadFactor = count / HashTable.length</code>。</p><p>resize 方法，既可以实现哈希表的扩容，也可以实现哈希表容量的压缩。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新调整哈希表大小，扩容或压缩</span></span><br><span class="line"><span class="title function_">resize</span>(<span class="params">newLimit</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、保存旧的 storage 数组内容</span></span><br><span class="line">  <span class="keyword">const</span> oldStorage = <span class="variable language_">this</span>.<span class="property">storage</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、重置所有属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">storage</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">limit</span> = newLimit;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> bucket <span class="keyword">of</span> oldStorage) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bucket) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">put</span>(b[<span class="number">0</span>], b[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通常情况下当装填因子 <code>laodFactor &gt; 0.75</code> 时，对哈希表进行扩容。在哈希表中的添加方法（push 方法）中添加如下代码，判断是否需要调用扩容函数进行扩容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">limit</span> &gt; <span class="variable language_">this</span>.<span class="property">loadFactor</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="title function_">getPrime</span>(<span class="variable language_">this</span>.<span class="property">limit</span> * <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当装填因子 <code>laodFactor &lt; 0.25</code> 时，对哈希表容量进行压缩。在哈希表中的删除方法（remove 方法）中添加如下代码，判断是否需要调用扩容函数进行压缩。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据装填因子的大小，判断是否要进行哈希表压缩</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">limit</span> &gt; <span class="number">7</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">limit</span> &lt; <span class="variable language_">this</span>.<span class="property">minLoadFactor</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="title function_">getPrime</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="variable language_">this</span>.<span class="property">limit</span> / <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="选择质数作为哈希表容量"><a href="#选择质数作为哈希表容量" class="headerlink" title="选择质数作为哈希表容量"></a>选择质数作为哈希表容量</h3><h4 id="质数判断"><a href="#质数判断" class="headerlink" title="质数判断"></a>质数判断</h4><blockquote><p>1 不是质数</p></blockquote><ul><li><p>方法一：针对质数的特点：只能被 1 和 number 整除，不能被 2 ~ (number-1) 整除。遍历 2 ~ (num-1) 。</p><p>这种方法虽然能实现质数的判断，但是效率不高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPrime</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; number; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (number % i === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：只需要遍历 2 ~ num 的平方根即可。该方法性能较好。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPrime</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt;= <span class="number">1</span> || number === <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> temp = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(number));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; temp; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (number % i === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现扩容或压缩后的哈希表容量为质数"><a href="#实现扩容或压缩后的哈希表容量为质数" class="headerlink" title="实现扩容或压缩后的哈希表容量为质数"></a>实现扩容或压缩后的哈希表容量为质数</h4><p>实现思路：</p><p>2 倍扩容或压缩之后，通过循环调用 <code>isPrime</code> 判断得到的容量是否为质数，不是则 +1，直到是为止。比如原长度：7，2 倍扩容后长度为 14，14 不是质数，<code>14 + 1 = 15</code> 不是质数，<code>15 + 1 = 16</code> 不是质数，<code>16 + 1 = 17</code> 是质数，停止循环，由此得到质数 17。</p><ul><li><p>第一步：首先需要为 HashTable 类添加判断质数的 <code>isPrime</code> 方法和获取质数的 <code>getPrime</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getPrime(number) 根据传入的 number 获取最临近的质数</span></span><br><span class="line"><span class="title function_">getPrime</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="title function_">isPrime</span>(number)) &#123;</span><br><span class="line">    number++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改添加元素的 <code>put</code> 方法和删除元素的 <code>remove</code> 方法中关于数组扩容的相关操作：</p><p>在 <code>put</code> 方法中添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">limit</span> &gt; <span class="variable language_">this</span>.<span class="property">loadFactor</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="title function_">getPrime</span>(<span class="variable language_">this</span>.<span class="property">limit</span> * <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>remove</code> 方法中添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据装填因子的大小，判断是否要进行哈希表压缩</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">limit</span> &gt; <span class="number">7</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">limit</span> &lt; <span class="variable language_">this</span>.<span class="property">minLoadFactor</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="title function_">getPrime</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="variable language_">this</span>.<span class="property">limit</span> / <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="哈希表完整实现"><a href="#哈希表完整实现" class="headerlink" title="哈希表完整实现"></a>哈希表完整实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = []; <span class="comment">// 哈希表存储数据的变量</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>; <span class="comment">// 当前存放的元素个数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = <span class="number">7</span>; <span class="comment">// 哈希表长度（初始设为质数 7）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装填因子 (已有个数/总个数)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">loadFactor</span> = <span class="number">0.75</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minLoadFactor</span> = <span class="number">0.25</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getPrime(number) 根据传入的 number 获取最临近的质数</span></span><br><span class="line">  <span class="title function_">getPrime</span>(<span class="params">number</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="title function_">isPrime</span>(number)) &#123;</span><br><span class="line">      number++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// put(key, value) 往哈希表里添加数据</span></span><br><span class="line">  <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取）</span></span><br><span class="line">    <span class="keyword">const</span> index = <span class="title function_">hashFn</span>(key, <span class="variable language_">this</span>.<span class="property">limit</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、根据 index 取出对应的 bucket</span></span><br><span class="line">    <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、判断是否存在 bucket</span></span><br><span class="line">    <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      bucket = []; <span class="comment">// 不存在则创建</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">storage</span>[index] = bucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、判断是插入数据操作还是修改数据操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tuple = bucket[i]; <span class="comment">// tuple 的格式：[key, value]</span></span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        <span class="comment">// 如果 key 相等，则修改数据</span></span><br><span class="line">        tuple[<span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 修改完 tuple 里数据，return 终止，不再往下执行。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、bucket 新增数据</span></span><br><span class="line">    bucket.<span class="title function_">push</span>([key, value]); <span class="comment">// bucket 存储元组 tuple，格式为 [key, value]</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">limit</span> &gt; <span class="variable language_">this</span>.<span class="property">loadFactor</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="title function_">getPrime</span>(<span class="variable language_">this</span>.<span class="property">limit</span> * <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 get(key) 获取 value</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title function_">hashFn</span>(key, <span class="variable language_">this</span>.<span class="property">limit</span>);</span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> tuple <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(key) 删除指定 key 的数据</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title function_">hashFn</span>(key, <span class="variable language_">this</span>.<span class="property">limit</span>);</span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 bucket，找到对应位置的 tuple，将其删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = bucket.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        bucket.<span class="title function_">splice</span>(i, <span class="number">1</span>); <span class="comment">// 删除对应位置的数组项</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据装填因子的大小，判断是否要进行哈希表压缩</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">limit</span> &gt; <span class="number">7</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">limit</span> &lt; <span class="variable language_">this</span>.<span class="property">minLoadFactor</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="title function_">getPrime</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="variable language_">this</span>.<span class="property">limit</span> / <span class="number">2</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tuple;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新调整哈希表大小，扩容或压缩</span></span><br><span class="line">  <span class="title function_">resize</span>(<span class="params">newLimit</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、保存旧的 storage 数组内容</span></span><br><span class="line">    <span class="keyword">const</span> oldStorage = <span class="variable language_">this</span>.<span class="property">storage</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、重置所有属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = newLimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bucket <span class="keyword">of</span> oldStorage) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bucket) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">put</span>(b[<span class="number">0</span>], b[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识哈希表&quot;&gt;&lt;a href=&quot;#认识哈希表&quot; class=&quot;headerlink&quot; title=&quot;认识哈希表&quot;&gt;&lt;/a&gt;认识哈希表&lt;/h2&gt;&lt;p&gt;哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构。&lt;/p&gt;
&lt;p&gt;哈希表通常是基于数</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="https://xpoet.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="哈希表" scheme="https://xpoet.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据结构与算法（九）字典</title>
    <link href="https://xpoet.cn/post/c394e4e41c22/"/>
    <id>https://xpoet.cn/post/c394e4e41c22/</id>
    <published>2020-07-28T05:11:00.000Z</published>
    <updated>2024-05-23T08:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典特点"><a href="#字典特点" class="headerlink" title="字典特点"></a>字典特点</h3><ul><li>字典存储的是<strong>键值对</strong>，主要特点是<strong>一一对应</strong>。</li><li>比如保存一个人的信息<ul><li>数组形式：<code>[19，&quot;Tom&quot;, 1.65]</code>，可通过下标值取出信息。</li><li>字典形式：<code>&#123;&quot;age&quot;: 19, &quot;name&quot;: &quot;Tom&quot;, &quot;height&quot;: 165&#125;</code>，可以通过 <code>key</code> 取出 <code>value</code>。</li></ul></li><li>此外，在字典中 key 是不能重复且无序的，而 Value 可以重复。</li></ul><h3 id="字典和映射的关系"><a href="#字典和映射的关系" class="headerlink" title="字典和映射的关系"></a>字典和映射的关系</h3><ul><li>有些编程语言中称这种映射关系为<strong>字典</strong>，如 Swift 中的 <code>Dictonary</code>，Python 中的 <code>dict</code>。</li><li>有些编程语言中称这种映射关系为 <strong>Map</strong>，比如 Java 中的 <code>HashMap</code> 和 <code>TreeMap</code> 等。</li></ul><h3 id="字典常见的操作"><a href="#字典常见的操作" class="headerlink" title="字典常见的操作"></a>字典常见的操作</h3><ul><li><code>set(key,value)</code> 向字典中添加新元素。</li><li><code>remove(key)</code> 通过使用键值来从字典中移除键值对应的数据值。</li><li><code>has(key)</code> 如果某个键值存在于这个字典中，则返回 <code>true</code>，反之则返回 <code>false</code>。</li><li><code>get(key)</code> 通过键值查找特定的数值并返回。</li><li><code>clear()</code> 将这个字典中的所有元素全部删除。</li><li><code>size()</code> 返回字典所包含元素的数量。与数组的 <code>length</code> 属性类似。</li><li><code>keys()</code> 将字典所包含的所有键名以数组形式返回。</li><li><code>values()</code> 将字典所包含的所有数值以数组形式返回。</li></ul><h3 id="字典封装"><a href="#字典封装" class="headerlink" title="字典封装"></a>字典封装</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典结构的封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Map</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// has(key) 判断字典中是否存在某个 key</span></span><br><span class="line">  <span class="title function_">has</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">hasOwnProperty</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set(key, value) 在字典中添加键值对</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(key) 在字典中删除指定的 key</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果集合不存在该 key，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">has</span>(key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get(key) 获取指定 key 的 value，如果没有，返回 undefined</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">has</span>(key) ? <span class="variable language_">this</span>.<span class="property">items</span>[key] : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有的 key</span></span><br><span class="line">  <span class="title function_">keys</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">items</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有的 value</span></span><br><span class="line">  <span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="variable language_">this</span>.<span class="property">items</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取字典中的键值对个数</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">keys</span>().<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear() 清空字典中所有的键值对</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// set() 测试</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;XPoet&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;i@xpoet.cn&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// &#123;items: &#123;name: &quot;XPoet&quot;, age: 18, email: &quot;i@xpoet.cn&quot;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// has() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">//--&gt; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&quot;address&quot;</span>)); <span class="comment">//--&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove() 测试</span></span><br><span class="line">map.<span class="title function_">remove</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// &#123;age: 18, email: &quot;i@xpoet.cn&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&quot;age&quot;</span>)); <span class="comment">//--&gt; 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keys() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">keys</span>()); <span class="comment">//--&gt; [&quot;age&quot;, &quot;email&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">values</span>()); <span class="comment">//--&gt; [18, &quot;i@xpoet.cn&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">size</span>()); <span class="comment">//--&gt; 2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h2&gt;&lt;h3 id=&quot;字典特点&quot;&gt;&lt;a href=&quot;#字典特点&quot; class=&quot;headerlink&quot; title=&quot;字典特点&quot;&gt;&lt;/a&gt;字典特点&lt;/h</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="https://xpoet.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="字典" scheme="https://xpoet.cn/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据结构与算法（八）集合</title>
    <link href="https://xpoet.cn/post/858e14457892/"/>
    <id>https://xpoet.cn/post/858e14457892/</id>
    <published>2020-07-26T07:46:00.000Z</published>
    <updated>2024-05-23T08:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。</p><h3 id="集合特点"><a href="#集合特点" class="headerlink" title="集合特点"></a>集合特点</h3><ul><li><p>集合通常是由一组<strong>无序的</strong>、<strong>不能重复的</strong>元素构成。</p></li><li><p>数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。</p></li><li><p>集合是特殊的数组。</p><ul><li>特殊之处在于里面的元素没有顺序，也不能重复。</li><li>没有顺序意味着不能通过下标值进行访问，不能重复意味着相同的对象在集合中只会存在一份。</li></ul></li></ul><h3 id="封装集合"><a href="#封装集合" class="headerlink" title="封装集合"></a>封装集合</h3><p>ES6 中的 <code>Set</code> 就是一个集合类，这里我们重新封装一个 <code>Set</code> 类，了解集合的底层实现。</p><h4 id="集合常见的操作"><a href="#集合常见的操作" class="headerlink" title="集合常见的操作"></a>集合常见的操作</h4><ul><li><code>add(value)</code> 向集合添加一个新的项。</li><li><code>remove(value)</code> 从集合移除一个值。</li><li><code>has(value)</code> 如果值在集合中，返回 <code>true</code>，否则返回<code> false</code>。</li><li><code>clear()</code> 移除集合中的所有项。</li><li><code>size()</code> 返回集合所包含元素的数量。与数组的 <code>length</code> 属性类似。</li><li><code>values()</code> 返回一个包含集合中所有值的数组。</li><li>还有其他的方法，用的不多，这里不做封装。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合结构的封装</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false</span></span><br><span class="line">  <span class="title function_">has</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">hasOwnProperty</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add(value) 往集合中添加 value</span></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[value] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(value) 删除集合中指定的 value</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果集合不存在该 value，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">has</span>(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[value];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear() 清空集合中所有 value</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取集合中的 value 个数</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">items</span>).<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// values() 获取集合中所有的 value</span></span><br><span class="line">  <span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">items</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// add() 测试</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="string">&quot;zxc&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">//--&gt; &#123;items: &#123;123: &quot;123&quot;, abc: &quot;abc&quot;, zxc: &quot;zxc&quot;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// has() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="string">&quot;123&quot;</span>)); <span class="comment">//--&gt; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="string">&quot;456&quot;</span>)); <span class="comment">//--&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove() 测试</span></span><br><span class="line">set.<span class="title function_">remove</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">//--&gt; &#123;items: &#123;123: &quot;123&quot;, zxc: &quot;zxc&quot;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">size</span>()); <span class="comment">//--&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">values</span>()); <span class="comment">//--&gt; [&quot;123&quot;, &quot;zxc&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear() 测试</span></span><br><span class="line">set.<span class="title function_">clear</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">values</span>()); <span class="comment">//--&gt; []</span></span><br></pre></td></tr></table></figure><h3 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h3><ul><li>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</li><li>交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</li><li>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</li><li>子集：验证一个给定集合是否是另一个集合的子集。</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4utjffapm1w0.png"                        alt="image"                 ></p><h4 id="并集的实现"><a href="#并集的实现" class="headerlink" title="并集的实现"></a>并集的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union() 求两个集合的并集</span></span><br><span class="line"><span class="title function_">union</span>(<span class="params">otherSet</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将当前集合（this）的所有 value，添加到新集合（unionSet）中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">        unionSet.<span class="title function_">add</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将 otherSet 集合的所有 value，添加到新集合（unionSet）中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> otherSet.<span class="title function_">values</span>()) &#123;</span><br><span class="line">        unionSet.<span class="title function_">add</span>(value); <span class="comment">// add() 已经有重复判断</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="交集的实现"><a href="#交集的实现" class="headerlink" title="交集的实现"></a>交集的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intersection() 求两个集合的交集</span></span><br><span class="line"><span class="title function_">intersection</span>(<span class="params">otherSet</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (otherSet.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">            intersectionSet.<span class="title function_">add</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="差集的实现"><a href="#差集的实现" class="headerlink" title="差集的实现"></a>差集的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// difference() 差集</span></span><br><span class="line"><span class="title function_">difference</span>(<span class="params">otherSet</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，不存在的即为差集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!otherSet.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">            differenceSet.<span class="title function_">add</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子集的实现"><a href="#子集的实现" class="headerlink" title="子集的实现"></a>子集的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subset() 子集</span></span><br><span class="line"><span class="title function_">subset</span>(<span class="params">otherSet</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，有不存在的返回 false</span></span><br><span class="line">    <span class="comment">// 遍历完所有的，返回 true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!otherSet.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合的完整实现"><a href="#集合的完整实现" class="headerlink" title="集合的完整实现"></a>集合的完整实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合结构的封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false</span></span><br><span class="line">  <span class="title function_">has</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">hasOwnProperty</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add(value) 往集合中添加 value</span></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[value] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(value) 删除集合中指定的 value</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果集合不存在该 value，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">has</span>(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[value];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear() 清空集合中所有 value</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取集合中的 value 个数</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">items</span>).<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// values() 获取集合中所有的 value</span></span><br><span class="line">  <span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">items</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------- 集合间的操作 ------- //</span></span><br><span class="line">  <span class="comment">// union() 求两个集合的并集</span></span><br><span class="line">  <span class="title function_">union</span>(<span class="params">otherSet</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将当前集合（this）的所有 value，添加到新集合（unionSet）中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">      unionSet.<span class="title function_">add</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将 otherSet 集合的所有 value，添加到新集合（unionSet）中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> otherSet.<span class="title function_">values</span>()) &#123;</span><br><span class="line">      unionSet.<span class="title function_">add</span>(value); <span class="comment">// add() 已经有重复判断</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// intersection() 求两个集合的交集</span></span><br><span class="line">  <span class="title function_">intersection</span>(<span class="params">otherSet</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (otherSet.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">        intersectionSet.<span class="title function_">add</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// difference() 差集</span></span><br><span class="line">  <span class="title function_">difference</span>(<span class="params">otherSet</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，不存在的即为差集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!otherSet.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">        differenceSet.<span class="title function_">add</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// subset() 子集</span></span><br><span class="line">  <span class="title function_">subset</span>(<span class="params">otherSet</span>) &#123;</span><br><span class="line">    <span class="comment">// 从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，有不存在的返回 false</span></span><br><span class="line">    <span class="comment">// 遍历完所有的，返回 true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!otherSet.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h2&gt;&lt;p&gt;几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="https://xpoet.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="集合" scheme="https://xpoet.cn/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据结构与算法（七）双向链表</title>
    <link href="https://xpoet.cn/post/5485c8ad25cf/"/>
    <id>https://xpoet.cn/post/5485c8ad25cf/</id>
    <published>2020-07-25T08:22:56.000Z</published>
    <updated>2024-05-23T08:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单向链表和双向链表"><a href="#单向链表和双向链表" class="headerlink" title="单向链表和双向链表"></a>单向链表和双向链表</h2><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><ul><li>只能从头遍历到尾或者从尾遍历到头（一般从头到尾）。</li><li>链表相连的过程是单向的，实现原理是上一个节点中有指向下一个节点的引用。</li><li>单向链表有一个比较明显的缺点：可以轻松到达下一个节点，但回到前一个节点很难，在实际开发中，经常会遇到需要回到上一个节点的情况。</li></ul><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul><li>既可以从头遍历到尾，也可以从尾遍历到头。</li><li>链表相连的过程是双向的。实现原理是一个节点既有向前连接的引用，也有一个向后连接的引用。</li><li>双向链表可以有效的解决单向链表存在的问题。</li><li>双向链表缺点：<ul><li>每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些。</li><li>相对于单向链表，所占内存空间更大一些。</li><li>但是，相对于双向链表的便利性而言，这些缺点微不足道。</li></ul></li></ul><h2 id="双向链表结构"><a href="#双向链表结构" class="headerlink" title="双向链表结构"></a>双向链表结构</h2><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.3xy769h90v20.png"                        alt="image"                 ></p><ul><li>双向链表不仅有 head 指针指向第一个节点，而且有 tail 指针指向最后一个节点。</li><li>每一个节点由三部分组成：item 储存数据、prev 指向前一个节点、next 指向后一个节点。</li><li>双向链表的第一个节点的 prev 指向 null。</li><li>双向链表的最后一个节点的 next 指向 null。</li></ul><h2 id="双向链表常见的操作"><a href="#双向链表常见的操作" class="headerlink" title="双向链表常见的操作"></a>双向链表常见的操作</h2><ul><li><code>append(element)</code> 向链表尾部追加一个新元素。</li><li><code>insert(position, element)</code> 向链表的指定位置插入一个新元素。</li><li><code>getElement(position)</code> 获取指定位置的元素。</li><li><code>indexOf(element)</code> 返回元素在链表中的索引。如果链表中没有该元素就返回 -1。</li><li><code>update(position, element)</code> 修改指定位置上的元素。</li><li><code>removeAt(position)</code> 从链表中的删除指定位置的元素。</li><li><code>remove(element)</code> 从链表删除指定的元素。</li><li><code>isEmpty()</code> 如果链表中不包含任何元素，返回 <code>trun</code>，如果链表长度大于 0 则返回 <code>false</code>。</li><li><code>size()</code> 返回链表包含的元素个数，与数组的 <code>length</code> 属性类似。</li><li><code>toString()</code> 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 <code>toString</code> 方法，让其只输出元素的值。</li><li><code>forwardString()</code> 返回正向遍历节点字符串形式。</li><li><code>backwordString()</code> 返回反向遍历的节点的字符串形式。</li></ul><h2 id="双向链表的封装"><a href="#双向链表的封装" class="headerlink" title="双向链表的封装"></a>双向链表的封装</h2><h3 id="创建双向链表类-DoublyLinkedList"><a href="#创建双向链表类-DoublyLinkedList" class="headerlink" title="创建双向链表类 DoublyLinkedList"></a>创建双向链表类 DoublyLinkedList</h3><ul><li>DoublyNode 类继承单向链表的 Node 类，新添加 <code>this.prev</code> 属性，该属性用于指向上一个节点。</li><li>DoublyLinkedList 类继承 LinkedList 类，新添加 <code>this.tail</code> 属性，该属性指向末尾的节点。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表的节点类（继承单向链表的节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyNode</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(element);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表类继承单向链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">LinkedList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="append-element"><a href="#append-element" class="headerlink" title="append(element)"></a>append(element)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append(element) 往双向链表尾部追加一个新的元素</span></span><br><span class="line"><span class="comment">// 重写 append()</span></span><br><span class="line"><span class="title function_">append</span>(<span class="params">element</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建双向链表节点</span></span><br><span class="line"><span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、追加元素</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ！！跟单向链表不同，不用通过循环找到最后一个节点</span></span><br><span class="line">  <span class="comment">// 巧妙之处</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = newNode;</span><br><span class="line">  newNode.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert-position-element"><a href="#insert-position-element" class="headerlink" title="insert(position, element)"></a>insert(position, element)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert(position, data) 插入元素</span></span><br><span class="line"><span class="comment">// 重写 insert()</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">position, element</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建新的双向链表节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、判断多种插入情况</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">// 在第 0 个位置插入</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==//</span></span><br><span class="line">        newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">perv</span> = newNode;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span>) &#123; <span class="comment">// 在最后一个位置插入</span></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = newNode;</span><br><span class="line">      newNode.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 在 0 ~ this.length 位置中间插入</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到要插入位置的节点</span></span><br><span class="line">      <span class="keyword">while</span> (targetIndex++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 交换节点信息</span></span><br><span class="line">      previousNode.<span class="property">next</span> = newNode;</span><br><span class="line">      newNode.<span class="property">prev</span> = previousNode;</span><br><span class="line"></span><br><span class="line">      newNode.<span class="property">next</span> = currentNode;</span><br><span class="line">      currentNode.<span class="property">prev</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="insert-position-element-1"><a href="#insert-position-element-1" class="headerlink" title="insert(position, element)"></a>insert(position, element)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert(position, data) 插入元素</span></span><br><span class="line"><span class="comment">// 重写 insert()</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">position, element</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建新的双向链表节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、判断多种插入情况</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">// 在第 0 个位置插入</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==//</span></span><br><span class="line">        newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">perv</span> = newNode;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span>) &#123; <span class="comment">// 在最后一个位置插入</span></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = newNode;</span><br><span class="line">      newNode.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 在 0 ~ this.length 位置中间插入</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到要插入位置的节点</span></span><br><span class="line">      <span class="keyword">while</span> (targetIndex++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 交换节点信息</span></span><br><span class="line">      previousNode.<span class="property">next</span> = newNode;</span><br><span class="line">      newNode.<span class="property">prev</span> = previousNode;</span><br><span class="line"></span><br><span class="line">      newNode.<span class="property">next</span> = currentNode;</span><br><span class="line">      currentNode.<span class="property">prev</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="removeAt-position"><a href="#removeAt-position" class="headerlink" title="removeAt(position)"></a>removeAt(position)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removeAt() 删除指定位置的节点</span></span><br><span class="line"><span class="comment">// 重写 removeAt()</span></span><br><span class="line"><span class="title function_">removeAt</span>(<span class="params">position</span>) &#123;</span><br><span class="line">  <span class="comment">// 1、position 越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、根据不同情况删除元素</span></span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">// 删除第一个节点的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123; <span class="comment">// 链表内只有一个节点的情况</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 链表内有多个节点的情况</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) &#123; <span class="comment">// 删除最后一个节点的情况</span></span><br><span class="line"></span><br><span class="line">    currentNode = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除 0 ~ this.length - 1 里面节点的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (targetIndex++ &lt; position) &#123;</span><br><span class="line">      previousNode = currentNode;</span><br><span class="line">      currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    previousNode.<span class="property">next</span> = currentNode.<span class="property">next</span>;</span><br><span class="line">    currentNode.<span class="property">next</span>.<span class="property">perv</span> = previousNode;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line">  <span class="keyword">return</span> currentNode.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update-position-data"><a href="#update-position-data" class="headerlink" title="update(position, data)"></a>update(position, data)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update(position, data) 修改指定位置的节点</span></span><br><span class="line"><span class="comment">// 重写 update()</span></span><br><span class="line"><span class="title function_">update</span>(<span class="params">position, data</span>) &#123;</span><br><span class="line">  <span class="comment">// 1、删除 position 位置的节点</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(position);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、在 position 位置插入元素</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">insert</span>(position, data);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forwardToString"><a href="#forwardToString" class="headerlink" title="forwardToString()"></a>forwardToString()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forwardToString() 链表数据从前往后以字符串形式返回</span></span><br><span class="line">  <span class="title function_">forwardToString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      result += currentNode.<span class="property">data</span> + <span class="string">&#x27;--&#x27;</span>;</span><br><span class="line">      currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="backwardString"><a href="#backwardString" class="headerlink" title="backwardString()"></a>backwardString()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// backwardString() 链表数据从后往前以字符串形式返回</span></span><br><span class="line">  <span class="title function_">backwardString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      result += currentNode.<span class="property">data</span> + <span class="string">&#x27;--&#x27;</span>;</span><br><span class="line">      currentNode = currentNode.<span class="property">prev</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="其他方法的实现"><a href="#其他方法的实现" class="headerlink" title="其他方法的实现"></a>其他方法的实现</h3><p>双向链表的其他方法通过继承单向链表来实现。</p><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">LinkedList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------ 链表的常见操作 ------------ //</span></span><br><span class="line">  <span class="comment">// append(element) 往双向链表尾部追加一个新的元素</span></span><br><span class="line">  <span class="comment">// 重写 append()</span></span><br><span class="line">  <span class="title function_">append</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、创建双向链表节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、追加元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ！！跟单向链表不同，不用通过循环找到最后一个节点</span></span><br><span class="line">      <span class="comment">// 巧妙之处</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = newNode;</span><br><span class="line">      newNode.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// insert(position, data) 插入元素</span></span><br><span class="line">  <span class="comment">// 重写 insert()</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">position, element</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建新的双向链表节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、判断多种插入情况</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在第 0 个位置插入</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==//</span></span><br><span class="line">        newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">perv</span> = newNode;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 在最后一个位置插入</span></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = newNode;</span><br><span class="line">      newNode.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在 0 ~ this.length 位置中间插入</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到要插入位置的节点</span></span><br><span class="line">      <span class="keyword">while</span> (targetIndex++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 交换节点信息</span></span><br><span class="line">      previousNode.<span class="property">next</span> = newNode;</span><br><span class="line">      newNode.<span class="property">prev</span> = previousNode;</span><br><span class="line"></span><br><span class="line">      newNode.<span class="property">next</span> = currentNode;</span><br><span class="line">      currentNode.<span class="property">prev</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getData() 继承单向链表</span></span><br><span class="line">  <span class="title function_">getData</span>(<span class="params">position</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">getData</span>(position);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// indexOf() 继承单向链表</span></span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">indexOf</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeAt() 删除指定位置的节点</span></span><br><span class="line">  <span class="comment">// 重写 removeAt()</span></span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="params">position</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、根据不同情况删除元素</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 删除第一个节点的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 链表内只有一个节点的情况</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 链表内有多个节点的情况</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 删除最后一个节点的情况</span></span><br><span class="line"></span><br><span class="line">      currentNode = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 删除 0 ~ this.length - 1 里面节点的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (targetIndex++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      previousNode.<span class="property">next</span> = currentNode.<span class="property">next</span>;</span><br><span class="line">      currentNode.<span class="property">next</span>.<span class="property">perv</span> = previousNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line">    <span class="keyword">return</span> currentNode.<span class="property">data</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update(position, data) 修改指定位置的节点</span></span><br><span class="line">  <span class="comment">// 重写 update()</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params">position, data</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、删除 position 位置的节点</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、在 position 位置插入元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">insert</span>(position, data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(data) 删除指定 data 所在的节点（继承单向链表）</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">remove</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty() 判断链表是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">isEmpty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取链表的长度</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// forwardToString() 链表数据从前往后以字符串形式返回</span></span><br><span class="line">  <span class="title function_">forwardToString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      result += currentNode.<span class="property">data</span> + <span class="string">&quot;--&quot;</span>;</span><br><span class="line">      currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// backwardString() 链表数据从后往前以字符串形式返回</span></span><br><span class="line">  <span class="title function_">backwardString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      result += currentNode.<span class="property">data</span> + <span class="string">&quot;--&quot;</span>;</span><br><span class="line">      currentNode = currentNode.<span class="property">prev</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doublyLinkedList = <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// append() 测试</span></span><br><span class="line">doublyLinkedList.<span class="title function_">append</span>(<span class="string">&quot;ZZ&quot;</span>);</span><br><span class="line">doublyLinkedList.<span class="title function_">append</span>(<span class="string">&quot;XX&quot;</span>);</span><br><span class="line">doublyLinkedList.<span class="title function_">append</span>(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert() 测试</span></span><br><span class="line">doublyLinkedList.<span class="title function_">insert</span>(<span class="number">0</span>, <span class="string">&quot;00&quot;</span>);</span><br><span class="line">doublyLinkedList.<span class="title function_">insert</span>(<span class="number">2</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getData() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList.<span class="title function_">getData</span>(<span class="number">1</span>)); <span class="comment">//--&gt; ZZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexOf() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList.<span class="title function_">indexOf</span>(<span class="string">&quot;XX&quot;</span>)); <span class="comment">//--&gt; 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// removeAt() 测试</span></span><br><span class="line">doublyLinkedList.<span class="title function_">removeAt</span>(<span class="number">0</span>);</span><br><span class="line">doublyLinkedList.<span class="title function_">removeAt</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update() 测试</span></span><br><span class="line">doublyLinkedList.<span class="title function_">update</span>(<span class="number">0</span>, <span class="string">&quot;111111&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList.<span class="title function_">remove</span>(<span class="string">&quot;111111&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList.<span class="title function_">remove</span>(<span class="string">&quot;22222&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// forwardToString() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList.<span class="title function_">forwardToString</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// backwardString() 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doublyLinkedList.<span class="title function_">backwardString</span>());</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单向链表和双向链表&quot;&gt;&lt;a href=&quot;#单向链表和双向链表&quot; class=&quot;headerlink&quot; title=&quot;单向链表和双向链表&quot;&gt;&lt;/a&gt;单向链表和双向链表&lt;/h2&gt;&lt;h3 id=&quot;单向链表&quot;&gt;&lt;a href=&quot;#单向链表&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="https://xpoet.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="双向链表" scheme="https://xpoet.cn/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据结构与算法（六）单向链表</title>
    <link href="https://xpoet.cn/post/bc2f3770da06/"/>
    <id>https://xpoet.cn/post/bc2f3770da06/</id>
    <published>2020-07-23T08:46:14.000Z</published>
    <updated>2024-05-23T08:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识链表"><a href="#认识链表" class="headerlink" title="认识链表"></a>认识链表</h2><h3 id="链表和数组"><a href="#链表和数组" class="headerlink" title="链表和数组"></a>链表和数组</h3><p>链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><p>存储多个元素，数组（或列表）可能是最常用的数据结构。</p></li><li><p>几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 <code>[]</code> 语法来访问数组元素。</p></li><li><p>数组缺点：</p><p>数组的创建需要申请一段连续的内存空间 (一整块内存)，并且大小是固定的，当前数组不能满足容量需求时，需要扩容。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去)</p><p>在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。</p></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p>存储多个元素，另外一个选择就是使用链表。</p></li><li><p>不同于数组，链表中的元素在内存中不必是连续的空间。</p></li><li><p>链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用 (有些语言称为指针) 组成。</p></li><li><p>链表优点：</p><p>内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理。</p><p>链表不必在创建时就确定大小，并且大小可以无限延伸下去。</p><p>链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多。</p></li><li><p>链表缺点：</p><p>访问任何一个位置的元素时，需要从头开始访问。(无法跳过第一个元素访问任何一个元素)</p><p>无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。</p><p>虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的。</p></li></ul><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>单向链表类似于火车，有一个火车头，火车头会连接一个节点，节点上有乘客，并且这个节点会连接下一个节点，以此类推。</p><ul><li><p>链表的火车结构</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.27xtn3c52zwg.png"                        alt="链表的火车结构"                 ></p></li><li><p>链表的数据结构</p><p>head 属性指向链表的第一个节点。<br>链表中的最后一个节点指向 <code>null</code>。<br>当链表中一个节点也没有的时候，head 直接指向 <code>null</code>。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.37j1by46a120.png"                        alt="链表的数据结构"                 ></p></li><li><p>给火车加上数据后的结构</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.664djiie2t80.png"                        alt="给火车加上数据后的结构"                 ></p></li></ul><h3 id="链表中的常见操作"><a href="#链表中的常见操作" class="headerlink" title="链表中的常见操作"></a>链表中的常见操作</h3><ul><li><code>append(element)</code> 向链表尾部添加一个新的项。</li><li><code>insert(position, element)</code> 向链表的特定位置插入一个新的项。</li><li><code>get(position)</code> 获取对应位置的元素。</li><li><code>indexOf(element)</code> 返回元素在链表中的索引。如果链表中没有该元素就返回 -1。</li><li><code>update(position, element)</code> 修改某个位置的元素。</li><li><code>removeAt(position)</code> 从链表的特定位置移除一项。</li><li><code>remove(element)</code> 从链表中移除一项。</li><li><code>isEmpty()</code> 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。</li><li><code>size()</code> 返回链表包含的元素个数，与数组的 length 属性类似。</li><li><code>toString()</code> 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。</li></ul><h3 id="单向链表的封装"><a href="#单向链表的封装" class="headerlink" title="单向链表的封装"></a>单向链表的封装</h3><h4 id="创建单向链表类"><a href="#创建单向链表类" class="headerlink" title="创建单向链表类"></a>创建单向链表类</h4><p>先创建单向链表类 LinkedList，添加基本属性，再逐步实现单向链表的常用方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">  <span class="comment">// 初始链表长度为 0</span></span><br><span class="line">  length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始 head 为 null，head 指向链表的第一个节点</span></span><br><span class="line">  head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部类（链表里的节点 Node）</span></span><br><span class="line">  <span class="title class_">Node</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">    data;</span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现-append-方法"><a href="#实现-append-方法" class="headerlink" title="实现 append() 方法"></a>实现 append() 方法</h4><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append() 往链表尾部追加数据</span></span><br><span class="line"><span class="title function_">append</span>(<span class="params">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="variable language_">this</span>.<span class="title class_">Node</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、追加新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表长度为 0 时，即只有 head 的时候</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 链表长度大于 0 时，在最后面添加新节点</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 currentNode.next 不为空时，</span></span><br><span class="line">    <span class="comment">// 循序依次找最后一个节点，即节点的 next 为 null 时</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode.<span class="property">next</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个节点的 next 指向新节点</span></span><br><span class="line">    currentNode.<span class="property">next</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、追加完新节点后，链表长度 + 1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="过程图解"><a href="#过程图解" class="headerlink" title="过程图解"></a>过程图解</h5><ul><li><p>首先让 <code>currentNode</code> 指向第一个节点。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.5iskrdf4nu40.png"                        alt="image"                 ></p></li><li><p>通过 <code>while</code> 循环使 <code>currentNode</code> 指向最后一个节点，最后通过 <code>currentNode.next = newNode</code>，让最后一个节点指向新节点 <code>newNode</code>。</p><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.4mw3bx5g80m0.png"                        alt="image"                 ></p></li></ul><h5 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="comment">// 测试 append 方法</span></span><br><span class="line">linkedList.<span class="title function_">append</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">linkedList.<span class="title function_">append</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">linkedList.<span class="title function_">append</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList);</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://cdn.statically.io/gh/XPoet/image-hosting@master/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.6kx4qbq8e5c.png"                        alt="image"                 ></p><h4 id="实现-toString-方法"><a href="#实现-toString-方法" class="headerlink" title="实现 toString() 方法"></a>实现 toString() 方法</h4><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">    result += currentNode.<span class="property">data</span> + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码测试-1"><a href="#代码测试-1" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 toString 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">toString</span>()); <span class="comment">//--&gt; AA BB CC</span></span><br></pre></td></tr></table></figure><h4 id="实现-insert-方法"><a href="#实现-insert-方法" class="headerlink" title="实现 insert() 方法"></a>实现 insert() 方法</h4><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert() 在指定位置（position）插入节点</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">position, data</span>) &#123;</span><br><span class="line">    <span class="comment">// position 新插入节点的位置</span></span><br><span class="line">    <span class="comment">// position = 0 表示新插入后是第一个节点</span></span><br><span class="line">    <span class="comment">// position = 1 表示新插入后是第二个节点，以此类推</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、对 position 进行越界判断，不能小于 0 或大于链表长度</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="variable language_">this</span>.<span class="title class_">Node</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、插入节点</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">// position = 0 的情况</span></span><br><span class="line">    <span class="comment">// 让新节点的 next 指向 原来的第一个节点，即 head</span></span><br><span class="line">    newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// head 赋值为 newNode</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 0 &lt; position &lt;= length 的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一些变量</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>; <span class="comment">// 当前节点初始化为 head</span></span><br><span class="line">    <span class="keyword">let</span> previousNode = <span class="literal">null</span>; <span class="comment">// head 的 上一节点为 null</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// head 的 index 为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode</span></span><br><span class="line">    <span class="comment">// 直到找到要插入的位置</span></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向</span></span><br><span class="line">    newNode.<span class="property">next</span> = currentNode;</span><br><span class="line">    previousNode.<span class="property">next</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码测试-2"><a href="#代码测试-2" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 insert 方法</span></span><br><span class="line">linkedList.<span class="title function_">insert</span>(<span class="number">0</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">linkedList.<span class="title function_">insert</span>(<span class="number">2</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">toString</span>()); <span class="comment">//--&gt; 123 AA 456 BB CC</span></span><br></pre></td></tr></table></figure><h4 id="实现-getData-方法"><a href="#实现-getData-方法" class="headerlink" title="实现 getData() 方法"></a>实现 getData() 方法</h4><p>获取指定位置（position）的 data。</p><h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getData</span>(<span class="params">position</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、获取指定 position 节点的 data</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">    currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、返回 data</span></span><br><span class="line">    <span class="keyword">return</span> currentNode.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码测试-3"><a href="#代码测试-3" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 getData 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">getData</span>(<span class="number">0</span>)); <span class="comment">//--&gt; 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">getData</span>(<span class="number">1</span>)); <span class="comment">//--&gt; AA</span></span><br></pre></td></tr></table></figure><h4 id="实现-indexOf-方法"><a href="#实现-indexOf-方法" class="headerlink" title="实现 indexOf() 方法"></a>实现 indexOf() 方法</h4><p>indexOf(data) 返回指定 data 的 index，如果没有，返回 -1。</p><h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">indexOf</span>(<span class="params">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentNode.<span class="property">data</span> === data) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码测试-4"><a href="#代码测试-4" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 indexOf 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">indexOf</span>(<span class="string">&quot;AA&quot;</span>)); <span class="comment">//--&gt; 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">indexOf</span>(<span class="string">&quot;ABC&quot;</span>)); <span class="comment">//--&gt; -1</span></span><br></pre></td></tr></table></figure><h4 id="实现-update-方法"><a href="#实现-update-方法" class="headerlink" title="实现 update() 方法"></a>实现 update() 方法</h4><p>update(position, data) 修改指定位置节点的 data。</p><h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">update</span>(<span class="params">position, data</span>) &#123;</span><br><span class="line">    <span class="comment">// 涉及到 position 都要进行越界判断</span></span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、痛过循环遍历，找到指定 position 的节点</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">    currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、修改节点 data</span></span><br><span class="line">    currentNode.<span class="property">data</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码测试-5"><a href="#代码测试-5" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 update 方法</span></span><br><span class="line">linkedList.<span class="title function_">update</span>(<span class="number">0</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">toString</span>()); <span class="comment">//--&gt; 12345 AA 456 BB CC</span></span><br><span class="line">linkedList.<span class="title function_">update</span>(<span class="number">1</span>, <span class="string">&quot;54321&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">toString</span>()); <span class="comment">//--&gt; 12345 54321 456 BB CC</span></span><br></pre></td></tr></table></figure><h4 id="实现-removeAt-方法"><a href="#实现-removeAt-方法" class="headerlink" title="实现 removeAt() 方法"></a>实现 removeAt() 方法</h4><p>removeAt(position) 删除指定位置的节点。</p><h5 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">removeAt</span>(<span class="params">position</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、删除指定 position 节点</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// position = 0 的情况</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// position &gt; 0 的情况</span></span><br><span class="line">    <span class="comment">// 通过循环遍历，找到指定 position 的节点，赋值到 currentNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。</span></span><br><span class="line">    previousNode.<span class="property">next</span> = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、更新链表长度 -1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码测试-6"><a href="#代码测试-6" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 removeAt 方法</span></span><br><span class="line">linkedList.<span class="title function_">removeAt</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">toString</span>()); <span class="comment">//--&gt; 12345 54321 456 CC</span></span><br></pre></td></tr></table></figure><h4 id="实现-remove-方法"><a href="#实现-remove-方法" class="headerlink" title="实现 remove() 方法"></a>实现 remove() 方法</h4><p>remove(data) 删除指定 data 所在的节点。</p><h5 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">remove</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(<span class="variable language_">this</span>.<span class="title function_">indexOf</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码测试-7"><a href="#代码测试-7" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 remove 方法</span></span><br><span class="line">linkedList.<span class="title function_">remove</span>(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">toString</span>()); <span class="comment">//--&gt; 12345 54321 456</span></span><br></pre></td></tr></table></figure><h4 id="实现-isEmpty-方法"><a href="#实现-isEmpty-方法" class="headerlink" title="实现 isEmpty() 方法"></a>实现 isEmpty() 方法</h4><p>isEmpty() 判断链表是否为空。</p><h5 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码测试-8"><a href="#代码测试-8" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 isEmpty 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">isEmpty</span>()); <span class="comment">//--&gt; false</span></span><br></pre></td></tr></table></figure><h4 id="实现-size-方法"><a href="#实现-size-方法" class="headerlink" title="实现 size() 方法"></a>实现 size() 方法</h4><p>size() 获取链表的长度。</p><h5 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码测试-9"><a href="#代码测试-9" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 size 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="title function_">size</span>()); <span class="comment">//--&gt; 3</span></span><br></pre></td></tr></table></figure><h4 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">  <span class="comment">// 初始链表长度为 0</span></span><br><span class="line">  length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始 head 为 null，head 指向链表的第一个节点</span></span><br><span class="line">  head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部类（链表里的节点 Node）</span></span><br><span class="line">  <span class="title class_">Node</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">    data;</span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------ 链表的常见操作 ------------ //</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// append() 往链表尾部追加数据</span></span><br><span class="line">  <span class="title function_">append</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="variable language_">this</span>.<span class="title class_">Node</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、追加新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 链表长度为 0 时，即只有 head 的时候</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 链表长度大于 0 时，在最后面添加新节点</span></span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当 currentNode.next 不为空时，</span></span><br><span class="line">      <span class="comment">// 循序依次找最后一个节点，即节点的 next 为 null 时</span></span><br><span class="line">      <span class="keyword">while</span> (currentNode.<span class="property">next</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后一个节点的 next 指向新节点</span></span><br><span class="line">      currentNode.<span class="property">next</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、追加完新节点后，链表长度 + 1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// insert() 在指定位置（position）插入节点</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">position, data</span>) &#123;</span><br><span class="line">    <span class="comment">// position 新插入节点的位置</span></span><br><span class="line">    <span class="comment">// position = 0 表示新插入后是第一个节点</span></span><br><span class="line">    <span class="comment">// position = 1 表示新插入后是第二个节点，以此类推</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、对 position 进行越界判断，不能小于 0 或大于链表长度</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="variable language_">this</span>.<span class="title class_">Node</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、插入节点</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// position = 0 的情况</span></span><br><span class="line">      <span class="comment">// 让新节点的 next 指向 原来的第一个节点，即 head</span></span><br><span class="line">      newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// head 赋值为 newNode</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 0 &lt; position &lt;= length 的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化一些变量</span></span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>; <span class="comment">// 当前节点初始化为 head</span></span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>; <span class="comment">// head 的 上一节点为 null</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// head 的 index 为 0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode</span></span><br><span class="line">      <span class="comment">// 直到找到要插入的位置</span></span><br><span class="line">      <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向</span></span><br><span class="line">      newNode.<span class="property">next</span> = currentNode;</span><br><span class="line">      previousNode.<span class="property">next</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getData() 获取指定位置的 data</span></span><br><span class="line">  <span class="title function_">getData</span>(<span class="params">position</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、获取指定 position 节点的 data</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">      currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、返回 data</span></span><br><span class="line">    <span class="keyword">return</span> currentNode.<span class="property">data</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// indexOf() 返回指定 data 的 index，如果没有，返回 -1。</span></span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.<span class="property">data</span> === data) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update() 修改指定位置节点的 data</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params">position, data</span>) &#123;</span><br><span class="line">    <span class="comment">// 涉及到 position 都要进行越界判断</span></span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、痛过循环遍历，找到指定 position 的节点</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">      currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、修改节点 data</span></span><br><span class="line">    currentNode.<span class="property">data</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeAt() 删除指定位置的节点</span></span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="params">position</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、删除指定 position 节点</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// position = 0 的情况</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// position &gt; 0 的情况</span></span><br><span class="line">      <span class="comment">// 通过循环遍历，找到指定 position 的节点，赋值到 currentNode</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。</span></span><br><span class="line">      previousNode.<span class="property">next</span> = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、更新链表长度 -1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove() 删除指定 data 的节点</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(<span class="variable language_">this</span>.<span class="title function_">indexOf</span>(data));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty() 判断链表是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取链表的长度</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// toString() 链表数据以字符串形式返回</span></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      result += currentNode.<span class="property">data</span> + <span class="string">&quot; &quot;</span>;</span><br><span class="line">      currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识链表&quot;&gt;&lt;a href=&quot;#认识链表&quot; class=&quot;headerlink&quot; title=&quot;认识链表&quot;&gt;&lt;/a&gt;认识链表&lt;/h2&gt;&lt;h3 id=&quot;链表和数组&quot;&gt;&lt;a href=&quot;#链表和数组&quot; class=&quot;headerlink&quot; title=&quot;链表和数组&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://xpoet.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://xpoet.cn/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="https://xpoet.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="单向链表" scheme="https://xpoet.cn/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
