[{"title":"不朽的失眠","url":"/post/1c5145940588/","content":"\n记得第一次见这篇文章出现在初中的语文书上，确确实实引起了我的共鸣，自此念念不忘，忽然感觉此刻很应景，收录此文。\n\n他落榜了！一千二百年前。榜纸那么大那么长，然而，就是没有他的名字。啊！竟单单容不下他的名字“张继”那两个字。  \n考中的人，姓名一笔一划写在榜单上，天下皆知。奇怪的是，在他的感觉里，考不上，才更是天下皆知，这件事，令他羞惭沮丧。\n离开京城吧！议好了价，他踏上小舟。本来预期的情节不是这样的，本来也许有插花游街、马蹄轻疾的风流，有衣锦还乡、袍笏加身的荣耀。然而，寒窗十年，虽有他的悬梁刺股，琼林宴上，却并没有他的一角席次。\n船行似风。\n江枫如火，在岸上举着冷冷的爝焰，这天黄昏，船，来到了苏州。但，这美丽的古城，对张继而言，也无非是另一个触动愁情的地方。\n如果说白天有什么该做的事，对一个读书人而言，就是读书吧！夜晚呢？夜晚该睡觉以便养足精神第二天再读。然而，今夜是一个忧伤的夜晚。今夜，在异乡，在江畔，在秋冷雁高的季节，容许一个落魄的士子放肆他的忧伤。江水，可以无限度地收纳古往今来一切不顺遂之人的泪水。\n这样的夜晚，残酷地坐着，亲自听自己的心正被什么东西啮食而一分一分消失的声音。并且眼睁睁地看自己的生命如劲风中的残灯，所有的力气都花在抗拒，油快尽了，微火每一刹那都可能熄灭。然而，可恨的是，终其一生，它都不曾华美灿烂过啊！\n江水睡了，船睡了，船家睡了，岸上的人也睡了。惟有他，张继，睡不着。夜愈深，愈清醒，清醒如败叶落余的枯树，似梁燕飞去的空巢。\n起先，是睡眠排拒的他。(也罢，这半生，不是处处都遭排拒吗？)而后，是他在赌气，好，无眠就无眠，长夜独醒，就干脆彻底来为自已验伤，有何不可？\n月亮西斜了，一副意兴阑珊的样子。有乌啼，粗嗄嘶哑，是乌鸦。那月亮被它一声声叫得更黯淡了。江岸上，想已霜结千草。夜空里，星子亦如清霜，一粒粒零落凄绝。\n在须角在眉梢，他感觉，似乎也森然生凉，那阴阴不怀好意的凉气啊，正等待凝成早秋的霜花，来贴缀他惨淡少年的容颜。\n江上渔火二三，他们在干什么？在捕鱼吧？或者，虾？他们也会有撒空网的时候吗？世路艰辛啊！即使潇洒的捕鱼的，也不免投身在风波里吧？然而，能辛苦工作，也是一种幸福吧！今夜，月自光其光，霜自冷其冷，安心的人在安眠，工作的人去工作。只有我张继，是天不管地不收的一个，是既没有权利去工作，也没福气去睡眠的一个……\n钟声响了，这奇怪的深夜的寒山寺钟声。一般寺庙，都是暮鼓晨钟，寒山寺庙敲“夜半钟”，用以惊世。钟声贴着水面传来，在别人，那声音只是睡梦中模糊的衬底音乐。在他，却一记一记都撞击在心坎上，正中要害。钟声那么美丽，但钟声自己到底是痛还是不痛呢？既然失眠，他推枕而起，摸黑写下“枫桥夜泊”四字。然后，就把其余二十八字照抄下来。我说“照抄”，是因为那二十八个字在他心底已像白墙上的黑字一样分明凸显：\n月落乌啼霜满天，江枫渔火对愁眠。\n姑苏城外寒山寺，夜半钟声到客船。\n感谢上苍，如果没有落第的张继，诗的历史上便少了一首好诗，我们的某一种心情，就没有人来为我们一语道破。\n一千二百年过去了，那张长长的榜单上（就是张继挤不进去的那纸金榜）曾经出现过的状元是谁？哈！管他是谁。真正被记得的名字是“落第者张继”。有人会记得那一届状元披红游街的盛景吗？不！我们只记得秋夜的客船上那个失意的人，以及他那场不朽的失眠。\n","categories":["文章收录"],"tags":["枫桥夜泊"]},{"title":"再见，也许就是再也不见","url":"/post/eb2dc071f5cb/","content":"\n你默默地转向一边，面向夜晚。夜的深处，是密密的灯盏，它们总在一起，我们总要再见。再见，为了再见。\n\n这是我非常喜欢的一首诗，名为《再见》，作者顾城。顾城属朦胧诗派，朦胧诗以晦涩为主。\n诗的大意是讲两个人由于某些原因必须要分开一段时间，时间定在了夜晚，他们的前程是未知的，谁都不知道明天会怎么样。其中某个人默默转身，渐渐消失在黑暗中，另一个人朝着黑暗四周望去，仿佛许多住户就在不远的地方，他们每家每户都点上了灯火，这些密密的灯盏代表了相聚，与自己离别的情形成对比，是一种心情的极大反差，油然而生一种依依不舍但必须离别的失落感。最后两句“再见，为了再见”虽然都在写再见，但意义不同，第一个再见是普遍意义上的再见，是一句告别用语。第二句再见是再次见面的意思，说明这一次两个人不得已天各一方，暂时的再见是为了以后更好的在一起。 \n………\n","categories":["散文集"],"tags":["再见"]},{"title":"微信公众号又双叒叕改名了","url":"/post/1c732a9f7dca/","content":"实在惭愧，这篇本应在两个月前就该写好的文章，由于我太懒，重度拖延，时至今日才姗姗来迟。\n\n\n微信公众号又双叒叕改名了，特意查看详情记录，自 2020 年 3 月 6 日注册以来，文章没写几篇，改名次数倒是不少，上一个名称《前端鼓励师》应该是使用最长时间的一个，大概持续了 3 年，貌似每一次的改名都与当时自己的职业规划、副业设想以及迫不及待想成为行业大牛的冲动息息相关，这一次的改名自然也不例外。\n一转眼，大学毕业后工作即将满 7 年，打了这么多年工，当了这么多年的社畜，眼看着自己的雄心壮志被一点一点吞噬掉，身上的棱角被一点一点磨平，深深感受到作为社会人的生活是多么不容易，真心觉得学生时代是最幸福的时光。\n我和大多数人一样，都是讨厌工作的，但为了生存又不得不工作。程序员这种职业，工作通常占据了生活中很大一部分时间，比起其他行业，更难于拥有属于自己真正的自由时间。\n如果能找到一份自己喜欢、挣得多、离家近，并且能从中收获非常多成就感和快乐的工作，当然是最好的，可惜大部分人都没有这样的幸运。\n在成为程序员之前，我热衷于写代码，跟大多数程序员一样，曾经梦想用代码改变世界，单纯地写代码就能够带给我带来很大的满足感，就在刚工作的那几年，我也极其享受写代码的感觉。\n然而，最近很长一段时间以来，我的情绪越来越不稳定，总是莫名其妙地发脾气，总感觉越来越疲惫，越来越焦虑，工作中纯粹写代码的时间越来越少，或许是因为当前的工作收入不太稳定，或许是这几年在跳槽和被裁员中患得患失，又或许是受到社会经济持续低迷的影响，我想更多可能是因为结婚后有了两个娃，在娃现在还比较小的时候自己却不能天天陪伴着，有了家庭的责任和牵绊，变得跟学生时代一样常常期盼着周末和假期，内心渴望更多自由时间。\n如果可以不仅仅依赖工作赚钱，或者说如果不止于主动工作这一份的收入来源，可能就会拥有更多的自由时间，可以去做自己喜欢的事情。\n工作之前的梦想比天还高，工作之后却不得不在现实面前低头，愈发愈觉得理想和现实之间的巨大鸿沟不是仅仅靠努力和坚持就能跨越的，绝大多数人终其一生也不能达到自己想要的高度，或许追求拥有健康、自由且平凡的生活才是最实在和可靠的。\n此次将公众号改名为《自由程序猿》，正是自己饱受职场摧残后做出的转变，也是自己对当前及未来的职业生涯做出的规划。我无比热爱代码，程序员是我终身的标签；我无比渴望自由，为了拥有真正的自由，自此开始，无论是工作中还是工作外，探索程序员的自由之路将是我长期坚持的事情，甚至是未来五年、十年、二十年、三十年。\n这个公众号自注册以来约 1000 人关注，深感惭愧，之前未能够给各位小伙伴持续分享有用的内容，今后也许还会一样，作者几乎不可能高产更文，依然是不定期分享我在探索程序员实现自由之路的各种尝试和实践，包括但不限于分享前端技术、后端技术、数据结构与算法、AIGC、面试经验、职场感悟、副业创业等等。各位小伙伴如若认可，请继续关注；若不喜欢，随时取关，随心就好。\n如果你和我一样有着类似的经历和想法，也渴望成为一个自由的人，也想去探索实现时间自由、空间自由，甚至财富自由，那么希望咱们能交个朋友（添加作者微信时请注明来意，作者从不推销，也极少发朋友圈），多个朋友多条路，但有想法随时交流。\n此刻思绪万千，脑海中点滴记忆如碎片一般混杂纷纭。\n\n","categories":["公众号"],"tags":["公众号","自由程序猿"]},{"title":"独立开发者的福音：Amazon DynamoDB 数据库","url":"/post/1d1c89725ee6/","content":"对于很多独立开发者朋友来说，往往总是需要一个稳定的云数据库来存储自己的个人数据。从零开始搭建一个云数据库，需要花费大量时间、精力，并且需要自己管理数据库的维护，在巨大的成本面前，显然这并不是明智之选。作者在偶然的机会下发现到亚马逊云科技 Amazon DynamoDB 数据库，可以永久免费提供 25GB 的存储量以及每月最多 2 亿次读&#x2F;写请求，一番体验下来，太良心了，简直就是独立开发者和个人网站站长的福音。\n什么是 Amazon DynamoDB 数据库？\nAmazon DynamoDB 数据库是亚马逊云科技提供的一款无服务器、NoSQL、完全托管的数据库，在任何规模下均具有个位数毫秒级的性能，你可以通过它来开发任何规模的现代应用程序。\n作为无服务器数据库，Amazon Free Tier 永久免费提供 25GB 的存储量以及每月最多 2 亿次读&#x2F;写请求，超出部分，只需按使用量为其付费，Amazon DynamoDB 可以扩展到零，没有冷启动，没有版本升级，没有维护窗口，没有修补，也没有停机维护。Amazon DynamoDB 提供一系列广泛的安全控制措施和合规性标准。对于全球分布式应用程序，Amazon DynamoDB 全局表是一个多区域、多活动数据库，具有 99.999% 的可用性 SLA 和更高的弹性。托管备份、时间点恢复等功能有助于确保 Amazon DynamoDB 的可靠性。借助 Amazon DynamoDB 流，你可以构建无服务器的事件驱动型应用程序。\nAmazon DynamoDB 的优势\n简单易用：Amazon DynamoDB 使用简单的 API 和数据模型，易于使用和学习。\n规模性能：提供具有稳定、高性能和几乎无限吞吐量和存储空间的应用程序。\n快速响应：支持读写操作的低延迟，读取操作的平均响应时间可以在几毫秒内完成。\n高可扩展性：可以根据需要自动增加或减少容量，从而满足不同的负载需求。\n高可用性：提供了多种数据备份和复原功能，使其在遇到任何故障或灾难时都能够快速恢复。\n高灵活性：Amazon DynamoDB 支持多种数据类型和数据模型，并支持多种查询和索引方式。\n\nAmazon DynamoDB 的适用场景Amazon DynamoDB 数据库的适用场景非常广泛，例如金融服务应用程序、游戏应用程序、日志挖掘、分析社交计算、外部数据聚合、前端订单处理系统、企业内容管理等等。对我们这些独立开发者或者个人网站站长而言，用 Amazon DynamoDB 数据库提供的免费套餐的来存储我们评论系统的数据、博客文章的数据，或者其他一些简单的数据，再合适不过了，无需额外的成本开销。\nAmazon DynamoDB 的免费套餐提供 25GB 的存储空间，以及 25 个预置的写入容量单位和 25 个预置的读取容量单位 (WCU、RCU)，足以处理每月 2 亿个请求，对个人用户来讲，完全是够用的。\n写入和读取容量单位可以通过表的其他设置选项卡中进行查看，注意不要超过免费额度，不然会产生费用。\n\nAmazon DynamoDB 快速上手使用示例注册亚马逊云科技账户\n访问亚马逊云科技官网。\n创建一个亚马逊云科技账户。\n按照指示填写个人信息，包括姓名、邮箱、密码等。\n完成验证后，设置支付方式（在账单登记页可以使用国内的信用卡）。\n完成注册流程。\n\n\n开始使用 Amazon DynamoDB登录亚马逊云科技管理控制台使用我们前面注册的亚马逊云科技账号和密码登录到亚马逊云科技管理控制台。\n选择 Amazon DynamoDB在亚马逊云科技管理控制台页面的服务搜索栏中输入“DynamoDB”，然后选择使用 Amazon DynamoDB。\n创建 Amazon DynamoDB 表此处为了方便演示，直接采用控制台的可视化方式进行创建，我们当然也可以使用 Amazon 提供的 SDK 等方式。进入 DynamoDB 的控制台页面，点击创建表，按照页面提示输入信息即可。\n\n输入表的名称，因为 DynamoDB 是一个无模式数据库，在创建表时只需要表名和主键即可，主键代表数据的唯一性，记住这两个配置项目，后面的程序代码中需要使用到。其他的配置暂时按照默认推荐的参数即可。\nAmazon DynamoDB 表的增删改查我们使用 Node.js 演示如何连接到 Amazon DynamoDB 数据库，以及对 Amazon DynamoDB 表进行增删改查等操作。\n安装 Amazon SDK我们在项目目录中初始化一个 Node.js 项目：\nmkdir dynamodb-examplecd dynamodb-examplenpm init -y\n\n安装 Amazon SDK：\nnpm install aws-sdk\n\n配置 Amazon SDK 凭证在与 Amazon DynamoDB 交互前，需要配置 Amazon SDK 凭证。我们可以通过以下方式配置：\n在 ~/.aws/credentials 文件中添加以下内容：\n[default]aws_access_key_id = YOUR_ACCESS_KEY_IDaws_secret_access_key = YOUR_SECRET_ACCESS_KEY\n\n创建 DynamoDB 客户端在项目中创建一个文件 index.js，并初始化 DynamoDB 客户端：\nconst AWS = require(&#x27;aws-sdk&#x27;);// 配置区域AWS.config.update(&#123;  region: &#x27;us-west-2&#x27; // 替换为你的区域&#125;);// 初始化 DynamoDB 客户端const dynamodb = new AWS.DynamoDB();const docClient = new AWS.DynamoDB.DocumentClient(); // 使用文档客户端更方便操作数据\n\n向表中插入数据在 Amazon DynamoDB 数据库的控制台页面也提供了给 Amazon DynamoDB 表增加数据的可视化操作，但是在实际应用中，一般都是由应用程序自动产生需要增加的数据，并推送到数据库进行数据的存储。\n使用 DocumentClient 插入数据：\nconst params = &#123;    TableName: &quot;demo&quot;,    Item: &#123;        &quot;id&quot;: &quot;1000&quot;    &#125;&#125;;docClient.put(params, function(err, data) &#123;    if (err) &#123;        console.error(err);    &#125; else &#123;        console.log(JSON.stringify(data, null, 2));    &#125;&#125;);\n\n从表中查询数据使用 DocumentClient 通过主键查询数据：\nconst params = &#123;    TableName: &quot;demo&quot;,    Key: &#123;        &quot;id&quot;: &quot;1000&quot;,        &quot;name&quot;: &quot;AA&quot;    &#125;&#125;;docClient.get(params, function(err, data) &#123;    if (err) &#123;        console.error(err);    &#125; else &#123;        console.log(JSON.stringify(data));    &#125;&#125;);\n\n删除表中的数据const params = &#123;    TableName: &quot;demo&quot;,    Key: &#123;        &quot;id&quot;: &quot;1000&quot;    &#125;&#125;;docClient.delete(params, function(err, data) &#123;    if (err) &#123;        console.error(err);    &#125; else &#123;        console.log(data);    &#125;&#125;);\n\n最后以上对 Amazon DynamoDB 数据库做了一个大概的介绍，演示了 Amazon DynamoDB 的基本操作以及结合 Node.js 的入门使用，Amazon DynamoDB 永久免费提供 25GB 的存储量以及每月最多 2 亿次读&#x2F;写请求，足以满足个人开发者需求，小伙伴可以体验一下，相信是一个非常不错的 NoSQL 数据库的替代。\n除 Amazon DynamoDB 数据库外，亚马逊云科技还提供众多永久免费的云产品，例如：无服务器计算服务 Amazon Lambda、消息传送的完全托管的 Pub&#x2F;Sub 服务 Amazon SNS、内容分发网络 (CDN) 服务 Amazon CloudFront 等等几十款免费的云产品服务，感兴趣小伙伴可以访问：亚马逊云科技。\n\n另外，亚马逊云科技还有个福利活动，在 2024 年 8 月 20 日 0 时至 2024 年 9 月 30 日 24 时期间的新注册用户，可以获得亚马逊云科技赠送的礼品 (无线耳机或无线键盘)，详情请查看亚马逊云科技官网活动页面。\n\n","categories":["数据库"],"tags":["DynamoDB","数据库"]},{"title":"触动心灵的六句古诗词","url":"/post/09066409f978/","content":"\n人生若只如初见，何事秋风悲画扇。 ——纳兰性德 《木兰词·拟古决绝词柬友》\n\n很多时候，初见，惊艳。蓦然回首，却已是物是人非，曾经沧海，只怕早已换了桑田。短短的一句话，道尽人生多少悲凉，道尽人生多少无奈。如果所有往事都能化为红尘一笑，只留下初见时的倾情、惊艳，忘却也许有过的背叛、伤怀，这是何等美妙的人生境界。若只是初见，一切美好都不会遗失。  \n\n曾经沧海难为水，除却巫山不是云。 ——元稹 《离思（其四）》\n\n曾读此诗难为诗，因为这句诗把人对某种生死之恋的刻骨铭心写绝了。在记忆之海里继续沉浸，在往事里打捞沉落的星辰月光，直至那昔年的沧海也将自己渐渐淹没。难道真的是沧海巫山之后，便再无水和云了？所以，不要太早遇见心上的他&#x2F;她，万一你捉不住他&#x2F;她，将一辈子都活在这句诗句里。  \n\n人面不知何处去，桃花依旧笑春风。 ——崔护 《题都城南庄》\n\n心爱的人不知道去哪了？只留下桃花却依然微笑，在春风中绽放。以笑映悲，道尽心中悲楚，令人不禁感慨万千。若干年后，我们是否也会有如此遭遇呢？  \n\n众里寻她千百度，蓦然回首，那人却在，灯火阑珊处。 ——辛弃疾 《青玉案·元夕》\n\n我千百次寻找，等待的那个人还没有出现。我的心充满疲惫和失落，不经意一回首，却发现她就在那灯火寥落的地方静静地站着。很多时候，我们总是在往阴暗处去寻找我们心中的她，却总不见其影踪，蓦然回首，才发现她其实一直就在我们的身边，离我们只有一个转身的距离。  \n\n衣带渐宽终不悔，为伊消得人憔悴。 ——柳永 《蝶恋花》\n\n无可替代的思念，无怨无悔的执着，脸庞的瘦削，颧骨的高突，身上的青衫也变得宽松了，但从没有后悔这一切皆因对她无边的思念而起，心甘情愿为爱饱受煎熬。这无尽的思念、无尽的爱，人世间又有谁能承受的起呢？   \n\n纵使相逢应不识，尘满面，鬓如霜。 ——苏轼 《江城子·乙卯正月二十日夜记梦》\n\n即使相逢也料想不会认识，因为我四处奔波，灰尘满面，鬓发如霜。这恐怕是每个一人最害怕的结果，若是不见也就罢了，若是相见，却互不认识，就这样在岁月里蹉跎地擦肩而过，那该是多么令人心碎的一幕。  \n沧海桑田，浩瀚的历史长河中，触动我心灵的古诗词又怎么可能只有这六句呢？\n","categories":["诗词人生"],"tags":["古诗词"]},{"title":"赞赏作者 Admire Author 💕","url":"/post/0054d541d734/","content":"开源项目，维护不易，感谢您的认可和支持。\n您可以使用微信扫描下图，对作者进行一定金额的赞赏支持。\n同时，您也可以添加作者微信，获得相应的技术支持。\n\n\n\n赞赏码\n作者微信二维码\n\n\n\n\n\n\n\n\n添加微信时请注明来意，如需进群，请直接写明想进哪个群。目前有：前端技术交流群、Keep 主题交流群、自由程序猿交流群。\n\n"},{"title":"醉眼天涯 花香满衣","url":"/post/37df64791f27/","content":"在忽然惊醒的夜凉里，挨着秋天的衣袖，独坐如莲。灯半笼，更阑。\n夜雾已经烹煮成一壶茶，不饮。相思已经倾斜成箫，不吹。只在梦的边缘，等你叩门的绝响。\n我的思念，是你前世遗忘采撷而无法成熟的青果。不舍那未了的情缘，我才执意轮回世间。单薄的形骸幻化成一树瘦梅，等你在必经的路旁。依旧是前世那一袭清绝的白衣，期待成为你不期而至的风景。拥有你一刻完整凝眸，即便错失整个花季，我也欣然坠落，腐化为泥。是什么将我的回眸捂上？烟色的记忆里，总不见你寻路而来，陪我，垂钓月光。\n洪荒的纪事已远，恍若隔世的约定风一般不着形迹，最放心不下的，还是你。为你点燃的浣花诗灯一盏一盏次第而亮，为你酝酿的柔情千顷一寸一寸绿满天涯。\n三界内，所有的花树静静的迎候岁月，唯我轻衫飘飘、暗香盈盈，等你在岁月的对岸。你不来，我不敢老去。静夜里如此的思念，真的会把你惊醒?\n今夜，你终于顺着长长的夜路，踏响我长满青苔的小径。苔痕斑驳的门扉，洞箫细碎的长廊,有谁的心事穿袜行走，莲步轻移。\n握着你的一唇冰凉，隔世的故事碎玉满地。心疼你单衣试酒的落寞孤寒，为你一弦独操，陪你独立霜降的寒凉。用素帕细细为你抹去肩头发上的霜，拢你的一袖寒凉……\n剪烛西窗。一卷心情，一壶淡酒，一阙宫商。单薄的素衣，不耐乍暖还寒的雨季。此刻，你停泊在哪一隅的夜凉里？\n谁替你烘干夜露沾湿的薄衫，笑你花香满衣。谁如我前世一般卷帘相问：可看见月的香馨？何处是港湾？青山麓，碧水旁，黄昏沙滩？寂寞沙洲寒。\n空相对，远山，远水……残红，无寐……  \n","categories":["诗词人生"]},{"title":"中文文案排版指北","url":"/post/88a9e0060c9c/","content":"统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。\n空格\n「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。\n与大家共勉之。」——vinta&#x2F;paranoid-auto-spacing\n\n中英文之间需要增加空格正确：\n\n在 LeanCloud 上，数据存储是围绕 AVObject 进行的。\n\n错误：\n\n在LeanCloud上，数据存储是围绕AVObject进行的。\n在 LeanCloud上，数据存储是围绕AVObject 进行的。\n\n完整的正确用法：\n\n在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。\n\n例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。\n中文与数字之间需要增加空格正确：\n\n今天出去买菜花了 5000 元。\n\n错误：\n\n今天出去买菜花了 5000元。\n今天出去买菜花了5000元。\n\n数字与单位之间需要增加空格正确：\n\n我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB\n\n错误：\n\n我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB\n\n例外：度数／百分比与数字之间不需要增加空格：\n正确：\n\n角度为 90° 的角，就是直角。\n新 MacBook Pro 有 15% 的 CPU 性能提升。\n\n错误：\n\n角度为 90 ° 的角，就是直角。\n新 MacBook Pro 有 15 % 的 CPU 性能提升。\n\n全角标点与其他字符之间不加空格正确：\n\n刚刚买了一部 iPhone，好开心！\n\n错误：\n\n刚刚买了一部 iPhone ，好开心！\n刚刚买了一部 iPhone， 好开心！\n\n用 text-spacing 来挽救？CSS Text Module Level 4 的 text-spacing 和 Microsoft 的 -ms-text-autospace 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。\n标点符号不重复使用标点符号虽然中国大陆的标点符号用法允许重复使用标点符号，但是这么做会破坏句子的美观性。\n正确：\n\n德国队竟然战胜了巴西队！\n她竟然对你说「喵」？！\n\n错误：\n\n德国队竟然战胜了巴西队！！\n德国队竟然战胜了巴西队！！！！！！！！\n她竟然对你说「喵」？？！！\n她竟然对你说「喵」？！？！？？！！\n\n全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科条目『全角和半角』。\n使用全角中文标点正确：\n\n嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！\n核磁共振成像（NMRI）是什么原理都不知道？JFGI！\n\n错误：\n\n嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！\n嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎！\n核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!\n核磁共振成像(NMRI)是什么原理都不知道?JFGI!\n\n例外：中文句子内夹有英文书籍名、报刊名时，不应借用中文书名号，应以英文斜体表示。\n数字使用半角字符正确：\n\n这个蛋糕只卖 1000 元。\n\n错误：\n\n这个蛋糕只卖 １０００ 元。\n\n例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。\n遇到完整的英文整句、特殊名词，其内容使用半角标点正确：\n\n乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」\n推荐你阅读 Hackers &amp; Painters: Big Ideas from the Computer Age，非常地有趣。\n\n错误：\n\n乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」\n推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。\n\n名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。\n正确：\n\n使用 GitHub 登录\n我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。\n\n错误：\n\n使用 github 登录\n使用 GITHUB 登录\n使用 Github 登录\n使用 gitHub 登录\n使用 gｲんĤЦ8 登录\n我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。\n我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。\n我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。\n我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。\n我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。\n\n注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。\n不要使用不地道的缩写正确：\n\n我们需要一位熟悉 TypeScript、HTML5，至少理解一种框架（如 React、Next.js）的前端开发者。\n\n错误：\n\n我们需要一位熟悉 Ts、h5，至少理解一种框架（如 RJS、nextjs）的 FED。\n\n争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。\n链接之间增加空格用法：\n\n请 提交一个 issue 并分配给相关同事。\n访问我们网站的最新动态，请 点击这里 进行订阅！\n\n对比用法：\n\n请提交一个 issue并分配给相关同事。\n访问我们网站的最新动态，请点击这里进行订阅！\n\n简体中文使用直角引号用法：\n\n「老师，『有条不紊』的『紊』是什么意思？」\n\n对比用法：\n\n“老师，‘有条不紊’的‘紊’是什么意思？”\n\n工具\n\n\n仓库\n系列\n语言\n\n\n\npangu.js\npangu\nJavaScript\n\n\npangu-go\npangu\nGo\n\n\npangu.java\npangu\nJava\n\n\npangu.py\npangu\nPython\n\n\npangu.rb\npangu\nRuby\n\n\npangu.php\npangu\nPHP\n\n\npangu.vim\npangu\nVim\n\n\nvue-pangu\npangu\nVue.js (Web Converter)\n\n\nintellij-pangu\npangu\nIntellij Platform Plugin\n\n\nautocorrect\nautocorrect\nRust, WASM, CLI tool\n\n\nautocorrect-node\nautocorrect\nNode.js\n\n\nautocorrect-py\nautocorrect\nPython\n\n\nautocorrect-rb\nautocorrect\nRuby\n\n\nautocorrect-java\nautocorrect\nJava\n\n\nautocorrect-go\nautocorrect\nGo\n\n\nautocorrect-php\nautocorrect\nPHP\n\n\nautocorrect-vscode\nautocorrect\nVS Code Extension\n\n\nautocorrect-idea-plugin\nautocorrect\nIntellij Platform Plugin\n\n\njxlwqq&#x2F;chinese-typesetting\nother\nPHP\n\n\nsparanoid&#x2F;space-lover\nother\nPHP (WordPress)\n\n\nsparanoid&#x2F;grunt-auto-spacing\nother\nNode.js (Grunt)\n\n\nhjiang&#x2F;scripts&#x2F;add-space-between-latin-and-cjk\nother\nPython\n\n\nhustcc&#x2F;hint\nother\nPython\n\n\nn0vad3v&#x2F;Tekorrect\nother\nPython\n\n\n谁在这样做？\n\n\n网站\n文案\nUGC\n\n\n\nApple 中国\n是\nN&#x2F;A\n\n\nApple 香港\n是\nN&#x2F;A\n\n\nApple 台湾\n是\nN&#x2F;A\n\n\nMicrosoft 中国\n是\nN&#x2F;A\n\n\nMicrosoft 香港\n是\nN&#x2F;A\n\n\nMicrosoft 台湾\n是\nN&#x2F;A\n\n\nLeanCloud\n是\nN&#x2F;A\n\n\nV2EX\n是\n是\n\n\nApple4us\n是\nN&#x2F;A\n\n\nRuby China\n是\n是\n\n\n少数派\n是\nN&#x2F;A\n\n\n参考文献\nGuidelines for Using Capital Letters - ThoughtCo.\nLetter case - Wikipedia\nPunctuation - Oxford Dictionaries\nPunctuation - The Purdue OWL\nHow to Use English Punctuation Correctly - wikiHow\n格式 - openSUSE\n全形和半形 - 维基百科\n引号 - 维基百科\n疑问惊叹号 - 维基百科\n\n\n本文转载 https://github.com/sparanoid/chinese-copywriting-guidelines\n\n","categories":["通用教程"],"tags":["文案排版"]},{"title":"常用的 Git 命令清单","url":"/post/c97ff7882509/","content":"本文收录在日常开发中经常使用到的 Git 命令，持续更新…\n\n\nWorkspace：工作区\nIndex &#x2F; Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n\n新建代码仓库# 在当前目录新建一个 Git 代码仓库$ git init# 新建一个目录，将其初始化为 Git 代码仓库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]\n\n配置Git 的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n# 显示当前的 Git 配置$ git config --list# 编辑 Git 配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;\n\n增加&#x2F;删除文件# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 例如：删除前端项目中的 node_modules $ git rm -r --cached node_modules# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]\n\n代码提交# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次 commit 之后的变化，直接到仓库区$ git commit -a# 提交时显示所有 diff 信息$ git commit -v# 使用一次新的 commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息$ git commit --amend -m [message]# 重做上一次 commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...\n\n分支# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定 commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个 commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]\n\n标签# 列出所有 tag$ git tag# 新建一个 tag 在当前 commit$ git tag [tag]# 新建一个 tag 在指定 commit$ git tag [tag] [commit]# 删除本地 tag$ git tag -d [tag]# 删除远程 tag$ git push origin :refs/tags/[tagName]# 查看 tag 信息$ git show [tag]# 提交指定 tag$ git push [remote] [tag]# 提交所有 tag$ git push [remote] --tags# 新建一个分支，指向某个 tag$ git checkout -b [branch] [tag]\n\n查看信息# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示 commit 历史，以及每次 commit 发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个 commit 之后的所有变动，每个 commit 占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个 commit 之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次 diff$ git log -p [file]# 显示过去 5 次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个 commit 的差异$ git diff --cached [file]# 显示工作区与当前分支最新 commit 之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog\n\n远程同步# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all\n\n撤销# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个 commit 的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次 commit 保持一致$ git reset --hard# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致$ git reset --hard [commit]# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个 commit，用来撤销指定 commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop\n\n其他# 生成一个可供发布的压缩包$ git archive","categories":["通用教程"],"tags":["Git"]},{"title":"快速掌握 Markdown 基础语法","url":"/post/2cbea699dd77/","content":"什么是 MarkdownMarkdown 是一种「 轻量级标记语言 」，用途广泛，使用简洁的语法代替常见排版格式，从而能使我们专心于写作，在最大程度上提高效率。Markdown 的语法十分简单，常用的标记符号也不超过十个，学习成本极低，一旦熟悉这种语法规则，将会有一劳永逸的效果。  \n\nWe believe that writing is about content, about what you want to say – not about fancy formatting.我们坚信写作写的是内容，所思所想，而不是花样格式。\n\n使用 Markdown 的优点\n专注你的文字内容而不是排版样式。\n纯文本内容，兼容所有的文本编辑器。\n可读、直观、通用性高、学习成本低。  \n轻松导出 HTML、PDF 等格式的文件。  \n随时可修改 .md 文件，不会因版本问题导致格式混乱。\n\nMarkdown 语法规则标题标记符：# \n标题是文章最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只需在这段文字前加 #  标记符。\n例如：\n\n# 一级标题\n## 二级标题\n## 三级标题\n……\n\n以此类推，共六级标题，对应 HTML 的 H1 ~ H6。\n注意：# 和文字之间需加一个空格。\n \n字体加粗标记符：** 或 __\n在需要表示为粗体的文字内容，用两个 ** 或 __ 标记符包裹。\n例如：**字体加粗** 或 __字体加粗__\n \n斜体标记符：* 或 _\n在需要表示为斜体的文字内容，用两个 * 或 _ 标记符包裹。\n例如：*斜体* 或 _斜体_\n \n引用标记符：&gt;\n只需在引用的文字内容前面加上 &gt; 标记符，就可以出现引用的效果。\n例如：&gt; 我是引用的句子哦\n\n列表无序列表标记符：- 或 + 或 *\n在需要表示为无序列表的文字前加 - 或 + 或 * 标记符。\n\n有序列表标记符：1. 或 2. 或 3. ……\n在需要表示为有序列表的文字前面添加加 1. 或 2. 或 3. …… 标记符。\n  \n链接标记符：[]()\n在 Markdown 中，插入链接，例如：[XPoet Blog](https://xtpoet.cn)\n\n图片标记符：![]()\n图片示例：![aliyun](https://img.alicdn.com/tfs/TB1Ly5oS3HqK1RjSZFPXXcwapXa-238-54.png)\n\n代码单行代码标记符：`  `\n需要引用代码时，如果引用的代码只有一行，可以用两个 ` 标记符将代码包裹起来。例如：\n\n多行代码标记符：```  ```\n多行代码，用两个 ``` 标记符将代码块包裹起来。例如：\n\n分割线标记符：*** 或 --- 或 ___\n插入分割线，在一行中用三个以上的 * 或 - 或 _ 标记符来建立一个分隔线，行内不能有其他内容，分隔符独占一行。\n\n删除线标记符：~~\n在需要添加删除线的文字内容，用两个 ~~ 标记符包裹。\n例如：~~ABC~~ ABC\n换行标记符： 两个空格符 加 回车\n在 Markdown 中进行换行，需在文字后面键入 两个空格符 加 回车。\n表格在 Markdown 中插入表格的标记符比较复杂，大家直接看效果，需要用到时过来复制代码。\n默认表格样式参考代码：\nColName1 | ColName2 | ColName3---------|----------|---------ColValue | ColValue | ColValueColValue | ColValue | ColValueColValue | ColValue | ColValueColValue | ColValue | ColValue\n\n效果如下：\n\n\n\nColName1\nColName2\nColName3\n\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\n表格列调整表格的列位置调整（默认左对齐，:------: 居中，------: 右对齐）\n参考代码：\n|ColName1 | ColName2 | ColName3||---------|:--------:|--------:||ColValue | ColValue | ColValue||ColValue | ColValue | ColValue||ColValue | ColValue | ColValue||ColValue | ColValue | ColValue|\n\n效果如下：\n\n\n\nColName1\nColName2\nColName3\n\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\n由于不同平台的 Markdown CSS 存在差异，实际显示效果跟本文也会有所不同。\n","categories":["通用教程"],"tags":["Markdown"]},{"title":"JavaScript 数据结构与算法（一）前言","url":"/post/7acfdbc2b6f1/","content":"什么是数据结构？数据结构的定义\n官方定义\n无\n\n民间定义\n\n“数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。” — 《数据结构、算法与应用》\n“数据结构是 ADT（抽象数据类型 Abstract Data Type）的物理实现。” — 《数据结构与算法分析》\n“数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。” —中文维基百科\n\n\n从自己角度认识\n在计算机中，存储和组织数据的方式。\n\n\n数据结构在生活中应用我们知道，计算机中数据量非常庞大，如何以高效的方式组织和存储呢？\n例如：一个庞大的图书馆中存放了大量的书籍，我们不仅仅要把书放进入，还应该在合适的时候能够取出来。\n图书摆放要使得两个相关操作方便实现：\n\n操作 1：新书怎么插入？\n操作 2：怎么找到某本指定的书？\n\n图书各种摆放方式：\n\n方法 1：随便放\n\n操作 1：哪里有空位放哪里。\n操作 2：找某本书，累死。\n\n\n方法 2：按照书名的拼音字母顺序排放\n\n操作 1：新进一本《阿 Q 正传》，按照字母顺序找到位置，插入。\n操作 2：二分查找法。\n\n\n方法 3：把书架划分成几块区域，按照类别存放，类别中按照字母顺序\n\n操作 1：先定类别，二分查找确定位置，移出空位。\n操作 2：先定类别，再二分查找。\n\n\n\n结论：\n\n解决问题方法的效率，根据数据的组织方式有关。\n计算机中存储的数据量相对于图书馆的书籍来说数据量更大，数据更加多。\n以什么样的方式，来存储和组织我们的数据才能在使用数据时更加方便呢？\n这就是数据结构需要考虑的问题。\n\n常见的数据结构\n数组（Aarray）\n栈（Stack）\n链表（Linked List）\n图（Graph）\n散列表（Hash）\n队列（Queue）\n树（Tree）\n堆（Heap）\n\n\n注意：数据结构与算法与语言无关，常见的编程语言都有直接或间接的使用上述常见的数据结构。\n\n什么是算法？算法（Algorithm）的定义\n一个有限指令集，每条指令的描述不依赖于语言。\n接收一些输入（有些情况下不需要输入）。\n产生输出。\n一定在有限步骤之后终止。\n\n算法通俗理解\nAlgorithm 这个单词本意就是解决问题的办法&#x2F;步骤逻辑。\n数据结构的实现，离不开算法。\n\n算法案例假如上海和杭州之间有一条高架线，高架线长度是 1,000,000 米，有一天高架线中有其中一米出现了故障，请你想出一种算法，可以快速定位到处问题的地方。\n\n线性查找\n\n从上海的起点开始一米一米的排查，最终一定能找到出问题的线段。\n但是如果线段在另一头，我们需要排查 1,000,000 次，这是最坏的情况，平均需要 500,000 次。\n\n\n二分查找\n\n从中间位置开始排查，看一下问题出在上海到中间位置，还是中间到杭州的位置。\n查找对应的问题后，再从中间位置分开，重新锁定一般的路程。\n最坏的情况，需要多少次可以排查完呢？最坏的情况是 20 次就可以找到出问题的地方。\n怎么计算出来的呢？log(1000000, 2)，以 2 位底，1000000 的对数 ≈ 20。\n\n\n\n结论：你会发现，解决问题的办法有很多，但是好的算法对比于差的算法，效率天壤之别。\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","算法"]},{"title":"JavaScript 数据结构与算法（七）双向链表","url":"/post/5485c8ad25cf/","content":"单向链表和双向链表单向链表\n只能从头遍历到尾或者从尾遍历到头（一般从头到尾）。\n链表相连的过程是单向的，实现原理是上一个节点中有指向下一个节点的引用。\n单向链表有一个比较明显的缺点：可以轻松到达下一个节点，但回到前一个节点很难，在实际开发中，经常会遇到需要回到上一个节点的情况。\n\n双向链表\n既可以从头遍历到尾，也可以从尾遍历到头。\n链表相连的过程是双向的。实现原理是一个节点既有向前连接的引用，也有一个向后连接的引用。\n双向链表可以有效的解决单向链表存在的问题。\n双向链表缺点：\n每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些。\n相对于单向链表，所占内存空间更大一些。\n但是，相对于双向链表的便利性而言，这些缺点微不足道。\n\n\n\n双向链表结构\n\n双向链表不仅有 head 指针指向第一个节点，而且有 tail 指针指向最后一个节点。\n每一个节点由三部分组成：item 储存数据、prev 指向前一个节点、next 指向后一个节点。\n双向链表的第一个节点的 prev 指向 null。\n双向链表的最后一个节点的 next 指向 null。\n\n双向链表常见的操作\nappend(element) 向链表尾部追加一个新元素。\ninsert(position, element) 向链表的指定位置插入一个新元素。\ngetElement(position) 获取指定位置的元素。\nindexOf(element) 返回元素在链表中的索引。如果链表中没有该元素就返回 -1。\nupdate(position, element) 修改指定位置上的元素。\nremoveAt(position) 从链表中的删除指定位置的元素。\nremove(element) 从链表删除指定的元素。\nisEmpty() 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。\nsize() 返回链表包含的元素个数，与数组的 length 属性类似。\ntoString() 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。\nforwardString() 返回正向遍历节点字符串形式。\nbackwordString() 返回反向遍历的节点的字符串形式。\n\n双向链表的封装创建双向链表类 DoublyLinkedList\nDoublyNode 类继承单向链表的 Node 类，新添加 this.prev 属性，该属性用于指向上一个节点。\nDoublyLinkedList 类继承 LinkedList 类，新添加 this.tail 属性，该属性指向末尾的节点。\n\n// 双向链表的节点类（继承单向链表的节点类）class DoublyNode extends Node &#123;  constructor(element) &#123;    super(element);    this.prev = null;  &#125;&#125;// 双向链表类继承单向链表类class DoublyLinkedList extends LinkedList &#123;  constructor() &#123;    super();    this.tail = null;  &#125;&#125;\n\nappend(element)// append(element) 往双向链表尾部追加一个新的元素// 重写 append()append(element) &#123;// 1、创建双向链表节点const newNode = new DoublyNode(element);// 2、追加元素if (this.head === null) &#123;  this.head = newNode;  this.tail = newNode;&#125; else &#123;  // ！！跟单向链表不同，不用通过循环找到最后一个节点  // 巧妙之处  this.tail.next = newNode;  newNode.prev = this.tail;  this.tail = newNode;&#125;this.length++;&#125;\n\ninsert(position, element)// insert(position, data) 插入元素// 重写 insert()insert(position, element) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt; this.length) return false;    // 2、创建新的双向链表节点    const newNode = new DoublyNode(element);    // 3、判断多种插入情况    if (position === 0) &#123; // 在第 0 个位置插入      if (this.head === null) &#123;        this.head = newNode;        this.tail = newNode;      &#125; else &#123;        //== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==//        newNode.next = this.head;        this.head.perv = newNode;        this.head = newNode;      &#125;    &#125; else if (position === this.length) &#123; // 在最后一个位置插入      this.tail.next = newNode;      newNode.prev = this.tail;      this.tail = newNode;    &#125; else &#123; // 在 0 ~ this.length 位置中间插入      let targetIndex = 0;      let currentNode = this.head;      let previousNode = null;      // 找到要插入位置的节点      while (targetIndex++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;      &#125;      // 交换节点信息      previousNode.next = newNode;      newNode.prev = previousNode;      newNode.next = currentNode;      currentNode.prev = newNode;    &#125;    this.length++;    return true;  &#125;\n\ninsert(position, element)// insert(position, data) 插入元素// 重写 insert()  insert(position, element) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt; this.length) return false;    // 2、创建新的双向链表节点    const newNode = new DoublyNode(element);    // 3、判断多种插入情况    if (position === 0) &#123; // 在第 0 个位置插入      if (this.head === null) &#123;        this.head = newNode;        this.tail = newNode;      &#125; else &#123;        //== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==//        newNode.next = this.head;        this.head.perv = newNode;        this.head = newNode;      &#125;    &#125; else if (position === this.length) &#123; // 在最后一个位置插入      this.tail.next = newNode;      newNode.prev = this.tail;      this.tail = newNode;    &#125; else &#123; // 在 0 ~ this.length 位置中间插入      let targetIndex = 0;      let currentNode = this.head;      let previousNode = null;      // 找到要插入位置的节点      while (targetIndex++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;      &#125;      // 交换节点信息      previousNode.next = newNode;      newNode.prev = previousNode;      newNode.next = currentNode;      currentNode.prev = newNode;    &#125;    this.length++;    return true;  &#125;\n\nremoveAt(position)// removeAt() 删除指定位置的节点// 重写 removeAt()removeAt(position) &#123;  // 1、position 越界判断  if (position &lt; 0 || position &gt; this.length - 1) return null;  // 2、根据不同情况删除元素  let currentNode = this.head;  if (position === 0) &#123; // 删除第一个节点的情况    if (this.length === 1) &#123; // 链表内只有一个节点的情况      this.head = null;      this.tail = null;    &#125; else &#123; // 链表内有多个节点的情况      this.head = this.head.next;      this.head.prev = null;    &#125;  &#125; else if (position === this.length - 1) &#123; // 删除最后一个节点的情况    currentNode = this.tail;    this.tail.prev.next = null;    this.tail = this.tail.prev;  &#125; else &#123; // 删除 0 ~ this.length - 1 里面节点的情况    let targetIndex = 0;    let previousNode = null;    while (targetIndex++ &lt; position) &#123;      previousNode = currentNode;      currentNode = currentNode.next;    &#125;    previousNode.next = currentNode.next;    currentNode.next.perv = previousNode;  &#125;  this.length--;  return currentNode.data;&#125;\n\nupdate(position, data)// update(position, data) 修改指定位置的节点// 重写 update()update(position, data) &#123;  // 1、删除 position 位置的节点  const result = this.removeAt(position);  // 2、在 position 位置插入元素  this.insert(position, data);  return result;&#125;\n\nforwardToString()// forwardToString() 链表数据从前往后以字符串形式返回  forwardToString() &#123;    let currentNode = this.head;    let result = &#x27;&#x27;;    // 遍历所有的节点，拼接为字符串，直到节点为 null    while (currentNode) &#123;      result += currentNode.data + &#x27;--&#x27;;      currentNode = currentNode.next;    &#125;    return result;  &#125;\n\nbackwardString()// backwardString() 链表数据从后往前以字符串形式返回  backwardString() &#123;    let currentNode = this.tail;    let result = &#x27;&#x27;;    // 遍历所有的节点，拼接为字符串，直到节点为 null    while (currentNode) &#123;      result += currentNode.data + &#x27;--&#x27;;      currentNode = currentNode.prev;    &#125;    return result;  &#125;\n\n其他方法的实现双向链表的其他方法通过继承单向链表来实现。\n完整实现class DoublyLinkedList extends LinkedList &#123;  constructor() &#123;    super();    this.tail = null;  &#125;  // ------------ 链表的常见操作 ------------ //  // append(element) 往双向链表尾部追加一个新的元素  // 重写 append()  append(element) &#123;    // 1、创建双向链表节点    const newNode = new DoublyNode(element);    // 2、追加元素    if (this.head === null) &#123;      this.head = newNode;      this.tail = newNode;    &#125; else &#123;      // ！！跟单向链表不同，不用通过循环找到最后一个节点      // 巧妙之处      this.tail.next = newNode;      newNode.prev = this.tail;      this.tail = newNode;    &#125;    this.length++;  &#125;  // insert(position, data) 插入元素  // 重写 insert()  insert(position, element) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt; this.length) return false;    // 2、创建新的双向链表节点    const newNode = new DoublyNode(element);    // 3、判断多种插入情况    if (position === 0) &#123;      // 在第 0 个位置插入      if (this.head === null) &#123;        this.head = newNode;        this.tail = newNode;      &#125; else &#123;        //== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==//        newNode.next = this.head;        this.head.perv = newNode;        this.head = newNode;      &#125;    &#125; else if (position === this.length) &#123;      // 在最后一个位置插入      this.tail.next = newNode;      newNode.prev = this.tail;      this.tail = newNode;    &#125; else &#123;      // 在 0 ~ this.length 位置中间插入      let targetIndex = 0;      let currentNode = this.head;      let previousNode = null;      // 找到要插入位置的节点      while (targetIndex++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;      &#125;      // 交换节点信息      previousNode.next = newNode;      newNode.prev = previousNode;      newNode.next = currentNode;      currentNode.prev = newNode;    &#125;    this.length++;    return true;  &#125;  // getData() 继承单向链表  getData(position) &#123;    return super.getData(position);  &#125;  // indexOf() 继承单向链表  indexOf(data) &#123;    return super.indexOf(data);  &#125;  // removeAt() 删除指定位置的节点  // 重写 removeAt()  removeAt(position) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt; this.length - 1) return null;    // 2、根据不同情况删除元素    let currentNode = this.head;    if (position === 0) &#123;      // 删除第一个节点的情况      if (this.length === 1) &#123;        // 链表内只有一个节点的情况        this.head = null;        this.tail = null;      &#125; else &#123;        // 链表内有多个节点的情况        this.head = this.head.next;        this.head.prev = null;      &#125;    &#125; else if (position === this.length - 1) &#123;      // 删除最后一个节点的情况      currentNode = this.tail;      this.tail.prev.next = null;      this.tail = this.tail.prev;    &#125; else &#123;      // 删除 0 ~ this.length - 1 里面节点的情况      let targetIndex = 0;      let previousNode = null;      while (targetIndex++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;      &#125;      previousNode.next = currentNode.next;      currentNode.next.perv = previousNode;    &#125;    this.length--;    return currentNode.data;  &#125;  // update(position, data) 修改指定位置的节点  // 重写 update()  update(position, data) &#123;    // 1、删除 position 位置的节点    const result = this.removeAt(position);    // 2、在 position 位置插入元素    this.insert(position, data);    return result;  &#125;  // remove(data) 删除指定 data 所在的节点（继承单向链表）  remove(data) &#123;    return super.remove(data);  &#125;  // isEmpty() 判断链表是否为空  isEmpty() &#123;    return super.isEmpty();  &#125;  // size() 获取链表的长度  size() &#123;    return super.size();  &#125;  // forwardToString() 链表数据从前往后以字符串形式返回  forwardToString() &#123;    let currentNode = this.head;    let result = &quot;&quot;;    // 遍历所有的节点，拼接为字符串，直到节点为 null    while (currentNode) &#123;      result += currentNode.data + &quot;--&quot;;      currentNode = currentNode.next;    &#125;    return result;  &#125;  // backwardString() 链表数据从后往前以字符串形式返回  backwardString() &#123;    let currentNode = this.tail;    let result = &quot;&quot;;    // 遍历所有的节点，拼接为字符串，直到节点为 null    while (currentNode) &#123;      result += currentNode.data + &quot;--&quot;;      currentNode = currentNode.prev;    &#125;    return result;  &#125;&#125;\n\n代码测试const doublyLinkedList = new DoublyLinkedList();// append() 测试doublyLinkedList.append(&quot;ZZ&quot;);doublyLinkedList.append(&quot;XX&quot;);doublyLinkedList.append(&quot;CC&quot;);console.log(doublyLinkedList);// insert() 测试doublyLinkedList.insert(0, &quot;00&quot;);doublyLinkedList.insert(2, &quot;22&quot;);console.log(doublyLinkedList);// getData() 测试console.log(doublyLinkedList.getData(1)); //--&gt; ZZ// indexOf() 测试console.log(doublyLinkedList.indexOf(&quot;XX&quot;)); //--&gt; 3console.log(doublyLinkedList);// removeAt() 测试doublyLinkedList.removeAt(0);doublyLinkedList.removeAt(1);console.log(doublyLinkedList);// update() 测试doublyLinkedList.update(0, &quot;111111&quot;);console.log(doublyLinkedList);// remove() 测试console.log(doublyLinkedList.remove(&quot;111111&quot;));console.log(doublyLinkedList.remove(&quot;22222&quot;));console.log(doublyLinkedList);// forwardToString() 测试console.log(doublyLinkedList.forwardToString());// backwardString() 测试console.log(doublyLinkedList.backwardString());\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","双向链表"]},{"title":"JavaScript 数据结构与算法（三）栈","url":"/post/12e3ee5e6f4f/","content":"数组是一个线性结构，并且可以在数组的任意位置插入和删除元素。但是有时候，我们为了实现某些功能，必须对这种任意性加以限制。栈和队列就是比较常见受限的线性结构。\n什么是栈栈（stack）是一种运算受限的线性表：\n\nLIFO（last in first out）表示就是后进入的元素，第一个弹出栈空间。类似于自动餐托盘，最后放上的托盘，往往先把拿出去使用。\n其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。\n向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；\n从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\n\n如下图所示：\n栈的特点：先进后出，后进先出。\n程序中的栈结构\n函数调用栈：A(B(C(D())))：即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;\n\n递归：为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Queue Overfloat）。\n\n\n练习题目：有 6 个元素 6，5，4，3，2，1 按顺序进栈，问下列哪一个不是合法的出栈顺序？\n\nA: 5 4 3 6 1 2 (√)\nB: 4 5 3 2 1 6 (√)\nC: 3 4 6 5 2 1 (×)\nD: 2 3 4 1 5 6 (√)\n\n题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。\n解析：\n\nA 答案：65 进栈，5 出栈，4 进栈出栈，3 进栈出栈，6 出栈，21 进栈，1 出栈，2 出栈（整体入栈顺序符合 654321）。\nB 答案：654 进栈，4 出栈，5 出栈，3 进栈出栈，2 进栈出栈，1 进栈出栈，6 出栈（整体的入栈顺序符合 654321）。\nC 答案：6543 进栈，3 出栈，4 出栈，之后应该 5 出栈而不是 6，所以错误。\nD 答案：65432 进栈，2 出栈，3 出栈，4 出栈，1 进栈出栈，5 出栈，6 出栈。符合入栈顺序。\n\n栈结构实现栈常见的操作\npush() 添加一个新元素到栈顶位置。\npop() 移除栈顶的元素，同时返回被移除的元素。\npeek() 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。\nisEmpty() 如果栈里没有任何元素就返回 true，否则返回 false。\nsize() 返回栈里的元素个数。这个方法和数组的 length 属性类似。\ntoString() 将栈结构的内容以字符串的形式返回。\n\nJavaScript 代码实现栈结构// 栈结构的封装class Map &#123;  constructor() &#123;    this.items = [];  &#125;  // push(item) 压栈操作，往栈里面添加元素  push(item) &#123;    this.items.push(item);  &#125;  // pop() 出栈操作，从栈中取出元素，并返回取出的那个元素  pop() &#123;    return this.items.pop();  &#125;  // peek() 查看栈顶元素  peek() &#123;    return this.items[this.items.length - 1];  &#125;  // isEmpty() 判断栈是否为空  isEmpty() &#123;    return this.items.length === 0;  &#125;  // size() 获取栈中元素个数  size() &#123;    return this.items.length;  &#125;  // toString() 返回以字符串形式的栈内元素数据  toString() &#123;    let result = &quot;&quot;;    for (let item of this.items) &#123;      result += item + &quot; &quot;;    &#125;    return result;  &#125;&#125;\n\n测试封装的栈结构// push() 测试stack.push(1);stack.push(2);stack.push(3);console.log(stack.items); //--&gt; [1, 2, 3]// pop() 测试console.log(stack.pop()); //--&gt; 3// peek() 测试console.log(stack.peek()); //--&gt; 2// isEmpty() 测试console.log(stack.isEmpty()); //--&gt; false// size() 测试console.log(stack.size()); //--&gt; 2// toString() 测试console.log(stack.toString()); //--&gt; 1 2\n\n栈结构的简单应用利用栈结构的特点封装实现十进制转换为二进制的方法。\n代码实现function dec2bin(dec) &#123;  // new 一个 Map，保存余数  const stack = new Map();  // 当不确定循环次数时，使用 while 循环  while (dec &gt; 0) &#123;    // 除二取余法    stack.push(dec % 2); // 获取余数，放入栈中    dec = Math.floor(dec / 2); // 除数除以二，向下取整  &#125;  let binaryString = &quot;&quot;;  // 不断地从栈中取出元素（0 或 1），并拼接到一起。  while (!stack.isEmpty()) &#123;    binaryString += stack.pop();  &#125;  return binaryString;&#125;\n\n测试// dec2bin() 测试console.log(dec2bin(100)); //--&gt; 1100100console.log(dec2bin(88)); //--&gt; 1011000\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","栈"]},{"title":"JavaScript 数据结构与算法（九）字典","url":"/post/c394e4e41c22/","content":"字典字典特点\n字典存储的是键值对，主要特点是一一对应。\n比如保存一个人的信息\n数组形式：[19，&quot;Tom&quot;, 1.65]，可通过下标值取出信息。\n字典形式：&#123;&quot;age&quot;: 19, &quot;name&quot;: &quot;Tom&quot;, &quot;height&quot;: 165&#125;，可以通过 key 取出 value。\n\n\n此外，在字典中 key 是不能重复且无序的，而 Value 可以重复。\n\n字典和映射的关系\n有些编程语言中称这种映射关系为字典，如 Swift 中的 Dictonary，Python 中的 dict。\n有些编程语言中称这种映射关系为 Map，比如 Java 中的 HashMap 和 TreeMap 等。\n\n字典常见的操作\nset(key,value) 向字典中添加新元素。\nremove(key) 通过使用键值来从字典中移除键值对应的数据值。\nhas(key) 如果某个键值存在于这个字典中，则返回 true，反之则返回 false。\nget(key) 通过键值查找特定的数值并返回。\nclear() 将这个字典中的所有元素全部删除。\nsize() 返回字典所包含元素的数量。与数组的 length 属性类似。\nkeys() 将字典所包含的所有键名以数组形式返回。\nvalues() 将字典所包含的所有数值以数组形式返回。\n\n字典封装代码实现// 字典结构的封装export default class Map &#123;  constructor() &#123;    this.items = &#123;&#125;;  &#125;  // has(key) 判断字典中是否存在某个 key  has(key) &#123;    return this.items.hasOwnProperty(key);  &#125;  // set(key, value) 在字典中添加键值对  set(key, value) &#123;    this.items[key] = value;  &#125;  // remove(key) 在字典中删除指定的 key  remove(key) &#123;    // 如果集合不存在该 key，返回 false    if (!this.has(key)) return false;    delete this.items[key];  &#125;  // get(key) 获取指定 key 的 value，如果没有，返回 undefined  get(key) &#123;    return this.has(key) ? this.items[key] : undefined;  &#125;  // 获取所有的 key  keys() &#123;    return Object.keys(this.items);  &#125;  // 获取所有的 value  values() &#123;    return Object.values(this.items);  &#125;  // size() 获取字典中的键值对个数  size() &#123;    return this.keys().length;  &#125;  // clear() 清空字典中所有的键值对  clear() &#123;    this.items = &#123;&#125;;  &#125;&#125;\n\n代码测试const map = new Map();// set() 测试map.set(&quot;name&quot;, &quot;XPoet&quot;);map.set(&quot;age&quot;, 18);map.set(&quot;email&quot;, &quot;i@xpoet.cn&quot;);console.log(map); // &#123;items: &#123;name: &quot;XPoet&quot;, age: 18, email: &quot;i@xpoet.cn&quot;&#125;&#125;// has() 测试console.log(map.has(&quot;name&quot;)); //--&gt; trueconsole.log(map.has(&quot;address&quot;)); //--&gt; false// remove() 测试map.remove(&quot;name&quot;);console.log(map); // &#123;age: 18, email: &quot;i@xpoet.cn&quot;&#125;// get() 测试console.log(map.get(&quot;age&quot;)); //--&gt; 18// keys() 测试console.log(map.keys()); //--&gt; [&quot;age&quot;, &quot;email&quot;]// values() 测试console.log(map.values()); //--&gt; [18, &quot;i@xpoet.cn&quot;]// size() 测试console.log(map.size()); //--&gt; 2\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","字典"]},{"title":"JavaScript 数据结构与算法（二）数组","url":"/post/b7e592fc6bd0/","content":"几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。数组通常情况下用于存储一系列同一种数据类型的值。但在 JavaScript 里，数组中可以保存不同类型的值。但我们还是要遵守最佳实践，别这么做（大多数语言都没这个能力）。\n创建和初始化数组\nnew Array()\nconst daysOfWeek = new Array(  &quot;Sunday&quot;,  &quot;Monday&quot;,  &quot;Tuesday&quot;,  &quot;Wednesday&quot;,  &quot;Thursday&quot;,  &quot;Friday&quot;,  &quot;Saturday&quot;);\n\n[]\nconst daysOfWeek = [  &quot;Sunday&quot;,  &quot;Monday&quot;,  &quot;Tuesday&quot;,  &quot;Wednesday&quot;,  &quot;Thursday&quot;,  &quot;Friday&quot;,  &quot;Saturday&quot;,];\n\n数组常见操作添加元素\n添加一个元素到数组的最后位置 array.push(item)\n在数组首位插入一个元素 array.unshift(item)\n在指定索引位置插入元素 array.splice(index, 0, item)\nsplice() 第二个参数为 0 时，表示插入数据。\n\nlet myArray = [1, 2, 3];// 在 索引 0 的位置，插入 AmyArray.splice(0, 0, &quot;A&quot;);console.log(myArray); //--&gt; [&#x27;A&#x27;, 1, 2, 3]\n\n删除元素\n删除数组最后的元素 array.pop(item)\n删除数组首位的元素 array.shift(item)\n删除指定索引位置的元素 array.splice(start, number)例如：let myArray2 = [1, 2, 3, 4, 5];// 删除索引 4 位置起，2 个元素myArray2.splice(4, 2);console.log(myArray2); //--&gt; [1, 2, 3]\n\n修改元素\n修改指定索引位置的元素 array.splice(index, 1, item)let myArray3 = [1, 2, 3, 4, 5, 6];// 修改 索引 1 的位置的元素为 AAmyArray2.splice(1, 1, &quot;AA&quot;);console.log(myArray3); //--&gt; [1, &quot;AA&quot;, 3, 4, 5, 6]\n修改指定索引位置的几个元素 array.splice(index, number, item)let myArray4 = [1, 2, 3, 4, 5, 6, 7];// 在 索引 2 的位置起，修改两个元素为 AA BBmyArray2.splice(2, 2, &quot;AA&quot;, &quot;BB&quot;);console.log(myArray3); //--&gt; [1, 2, &quot;AA&quot;, &quot;BB&quot;, 5, 6, 7]\n\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","数组"]},{"title":"JavaScript 数据结构与算法（五）优先队列","url":"/post/0b3b28647c69/","content":"场景生活中类似优先队列的场景：\n\n优先排队的人，优先处理。 (买票、结账、WC)。\n排队中，有紧急情况（特殊情况）的人可优先处理。\n\n优先队列优先级队列主要考虑的问题：\n\n每个元素不再只是一个数据，还包含优先级。\n在添加元素过程中，根据优先级放入到正确位置。\n\n优先队列的实现代码实现// 优先队列内部的元素类class QueueElement &#123;  constructor(element, priority) &#123;    this.element = element;    this.priority = priority;  &#125;&#125;// 优先队列类（继承 Queue 类）export class PriorityQueue extends Queue &#123;  constructor() &#123;    super();  &#125;  // enqueue(element, priority) 入队，将元素按优先级加入到队列中  // 重写 enqueue()  enqueue(element, priority) &#123;    // 根据传入的元素，创建 QueueElement 对象    const queueElement = new QueueElement(element, priority);    // 判断队列是否为空    if (this.isEmpty()) &#123;      // 如果为空，不用判断优先级，直接添加      this.items.push(queueElement);    &#125; else &#123;      // 定义一个变量记录是否成功添加了新元素      let added = false;      for (let i = 0; i &lt; this.items.length; i++) &#123;        // 让新插入的元素进行优先级比较，priority 值越小，优先级越大        if (queueElement.priority &lt; this.items[i].priority) &#123;          // 在指定的位置插入元素          this.items.splice(i, 0, queueElement);          added = true;          break;        &#125;      &#125;      // 如果遍历完所有元素，优先级都大于新插入的元素，就将新插入的元素插入到最后      if (!added) &#123;        this.items.push(queueElement);      &#125;    &#125;  &#125;  // dequeue() 出队，从队列中删除前端元素，返回删除的元素  // 继承 Queue 类的 dequeue()  dequeue() &#123;    return super.dequeue();  &#125;  // front() 查看队列的前端元素  // 继承 Queue 类的 front()  front() &#123;    return super.front();  &#125;  // isEmpty() 查看队列是否为空  // 继承 Queue 类的 isEmpty()  isEmpty() &#123;    return super.isEmpty();  &#125;  // size() 查看队列中元素的个数  // 继承 Queue 类的 size()  size() &#123;    return super.size();  &#125;  // toString() 将队列中元素以字符串形式返回  // 重写 toString()  toString() &#123;    let result = &quot;&quot;;    for (let item of this.items) &#123;      result += item.element + &quot;-&quot; + item.priority + &quot; &quot;;    &#125;    return result;  &#125;&#125;\n\n测试代码const priorityQueue = new PriorityQueue();// 入队 enqueue() 测试priorityQueue.enqueue(&quot;A&quot;, 10);priorityQueue.enqueue(&quot;B&quot;, 15);priorityQueue.enqueue(&quot;C&quot;, 11);priorityQueue.enqueue(&quot;D&quot;, 20);priorityQueue.enqueue(&quot;E&quot;, 18);console.log(priorityQueue.items);//--&gt; output:// QueueElement &#123;element: &quot;A&quot;, priority: 10&#125;// QueueElement &#123;element: &quot;C&quot;, priority: 11&#125;// QueueElement &#123;element: &quot;B&quot;, priority: 15&#125;// QueueElement &#123;element: &quot;E&quot;, priority: 18&#125;// QueueElement &#123;element: &quot;D&quot;, priority: 20&#125;// 出队 dequeue() 测试priorityQueue.dequeue();priorityQueue.dequeue();console.log(priorityQueue.items);//--&gt; output:// QueueElement &#123;element: &quot;B&quot;, priority: 15&#125;// QueueElement &#123;element: &quot;E&quot;, priority: 18&#125;// QueueElement &#123;element: &quot;D&quot;, priority: 20&#125;// isEmpty() 测试console.log(priorityQueue.isEmpty()); //--&gt; false// size() 测试console.log(priorityQueue.size()); //--&gt; 3// toString() 测试console.log(priorityQueue.toString()); //--&gt; B-15 E-18 D-20\n\n数组、栈和队列图解\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","优先队列"]},{"title":"JavaScript 数据结构与算法（八）集合","url":"/post/858e14457892/","content":"集合几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。\n集合特点\n集合通常是由一组无序的、不能重复的元素构成。\n\n数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。\n\n集合是特殊的数组。\n\n特殊之处在于里面的元素没有顺序，也不能重复。\n没有顺序意味着不能通过下标值进行访问，不能重复意味着相同的对象在集合中只会存在一份。\n\n\n\n封装集合ES6 中的 Set 就是一个集合类，这里我们重新封装一个 Set 类，了解集合的底层实现。\n集合常见的操作\nadd(value) 向集合添加一个新的项。\nremove(value) 从集合移除一个值。\nhas(value) 如果值在集合中，返回 true，否则返回 false。\nclear() 移除集合中的所有项。\nsize() 返回集合所包含元素的数量。与数组的 length 属性类似。\nvalues() 返回一个包含集合中所有值的数组。\n还有其他的方法，用的不多，这里不做封装。\n\n代码实现// 集合结构的封装class Set &#123;  constructor() &#123;    this.items = &#123;&#125;;  &#125;  // has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false  has(value) &#123;    return this.items.hasOwnProperty(value);  &#125;  // add(value) 往集合中添加 value  add(value) &#123;    if (this.has(value)) return false;    this.items[value] = value;    return true;  &#125;  // remove(value) 删除集合中指定的 value  remove(value) &#123;    // 如果集合不存在该 value，返回 false    if (!this.has(value)) return false;    delete this.items[value];  &#125;  // clear() 清空集合中所有 value  clear() &#123;    this.items = &#123;&#125;;  &#125;  // size() 获取集合中的 value 个数  size() &#123;    return Object.keys(this.items).length;  &#125;  // values() 获取集合中所有的 value  values() &#123;    return Object.keys(this.items);  &#125;&#125;\n\n代码测试const set = new Set();// add() 测试set.add(&quot;abc&quot;);set.add(&quot;abc&quot;);set.add(&quot;123&quot;);set.add(&quot;zxc&quot;);console.log(set); //--&gt; &#123;items: &#123;123: &quot;123&quot;, abc: &quot;abc&quot;, zxc: &quot;zxc&quot;&#125;&#125;// has() 测试console.log(set.has(&quot;123&quot;)); //--&gt; trueconsole.log(set.has(&quot;456&quot;)); //--&gt; false// remove() 测试set.remove(&quot;abc&quot;);console.log(set); //--&gt; &#123;items: &#123;123: &quot;123&quot;, zxc: &quot;zxc&quot;&#125;&#125;// size() 测试console.log(set.size()); //--&gt; 2// values() 测试console.log(set.values()); //--&gt; [&quot;123&quot;, &quot;zxc&quot;]// clear() 测试set.clear();console.log(set.values()); //--&gt; []\n\n集合间的操作\n并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。\n交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。\n差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。\n子集：验证一个给定集合是否是另一个集合的子集。\n\n\n并集的实现// union() 求两个集合的并集union(otherSet) &#123;    // 1、创建一个新集合    let unionSet = new Set();    // 2、将当前集合（this）的所有 value，添加到新集合（unionSet）中    for (let value of this.values()) &#123;        unionSet.add(value);    &#125;    // 3、将 otherSet 集合的所有 value，添加到新集合（unionSet）中    for (let value of otherSet.values()) &#123;        unionSet.add(value); // add() 已经有重复判断    &#125;    return unionSet;&#125;\n\n交集的实现// intersection() 求两个集合的交集intersection(otherSet) &#123;    // 1、创建一个新集合    let intersectionSet = new Set();    // 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在    for (let value of this.values()) &#123;        if (otherSet.has(value)) &#123;            intersectionSet.add(value);        &#125;    &#125;    return intersectionSet;&#125;\n\n差集的实现// difference() 差集difference(otherSet) &#123;    // 1、创建一个新集合    let differenceSet = new Set();    // 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，不存在的即为差集    for (let value of this.values()) &#123;        if (!otherSet.has(value)) &#123;            differenceSet.add(value);        &#125;    &#125;    return differenceSet;&#125;\n\n子集的实现// subset() 子集subset(otherSet) &#123;    // 从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，有不存在的返回 false    // 遍历完所有的，返回 true    for (let value of this.values()) &#123;        if (!otherSet.has(value)) &#123;            return false;        &#125;    &#125;    return true;&#125;\n\n集合的完整实现// 集合结构的封装export default class Set &#123;  constructor() &#123;    this.items = &#123;&#125;;  &#125;  // has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false  has(value) &#123;    return this.items.hasOwnProperty(value);  &#125;  // add(value) 往集合中添加 value  add(value) &#123;    if (this.has(value)) return false;    this.items[value] = value;    return true;  &#125;  // remove(value) 删除集合中指定的 value  remove(value) &#123;    // 如果集合不存在该 value，返回 false    if (!this.has(value)) return false;    delete this.items[value];  &#125;  // clear() 清空集合中所有 value  clear() &#123;    this.items = &#123;&#125;;  &#125;  // size() 获取集合中的 value 个数  size() &#123;    return Object.keys(this.items).length;  &#125;  // values() 获取集合中所有的 value  values() &#123;    return Object.keys(this.items);  &#125;  // ------- 集合间的操作 ------- //  // union() 求两个集合的并集  union(otherSet) &#123;    // 1、创建一个新集合    let unionSet = new Set();    // 2、将当前集合（this）的所有 value，添加到新集合（unionSet）中    for (let value of this.values()) &#123;      unionSet.add(value);    &#125;    // 3、将 otherSet 集合的所有 value，添加到新集合（unionSet）中    for (let value of otherSet.values()) &#123;      unionSet.add(value); // add() 已经有重复判断    &#125;    return unionSet;  &#125;  // intersection() 求两个集合的交集  intersection(otherSet) &#123;    // 1、创建一个新集合    let intersectionSet = new Set();    // 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在    for (let value of this.values()) &#123;      if (otherSet.has(value)) &#123;        intersectionSet.add(value);      &#125;    &#125;    return intersectionSet;  &#125;  // difference() 差集  difference(otherSet) &#123;    // 1、创建一个新集合    let differenceSet = new Set();    // 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，不存在的即为差集    for (let value of this.values()) &#123;      if (!otherSet.has(value)) &#123;        differenceSet.add(value);      &#125;    &#125;    return differenceSet;  &#125;  // subset() 子集  subset(otherSet) &#123;    // 从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，有不存在的返回 false    // 遍历完所有的，返回 true    for (let value of this.values()) &#123;      if (!otherSet.has(value)) &#123;        return false;      &#125;    &#125;    return true;  &#125;&#125;\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","集合"]},{"title":"JavaScript 数据结构与算法（六）单向链表","url":"/post/bc2f3770da06/","content":"认识链表链表和数组链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同。\n数组\n存储多个元素，数组（或列表）可能是最常用的数据结构。\n\n几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 [] 语法来访问数组元素。\n\n数组缺点：\n数组的创建需要申请一段连续的内存空间 (一整块内存)，并且大小是固定的，当前数组不能满足容量需求时，需要扩容。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去)\n在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。\n\n\n链表\n存储多个元素，另外一个选择就是使用链表。\n\n不同于数组，链表中的元素在内存中不必是连续的空间。\n\n链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用 (有些语言称为指针) 组成。\n\n链表优点：\n内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理。\n链表不必在创建时就确定大小，并且大小可以无限延伸下去。\n链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多。\n\n链表缺点：\n访问任何一个位置的元素时，需要从头开始访问。(无法跳过第一个元素访问任何一个元素)\n无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。\n虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的。\n\n\n单向链表单向链表类似于火车，有一个火车头，火车头会连接一个节点，节点上有乘客，并且这个节点会连接下一个节点，以此类推。\n\n链表的火车结构\n\n\n链表的数据结构\nhead 属性指向链表的第一个节点。链表中的最后一个节点指向 null。当链表中一个节点也没有的时候，head 直接指向 null。\n\n\n给火车加上数据后的结构\n\n\n\n链表中的常见操作\nappend(element) 向链表尾部添加一个新的项。\ninsert(position, element) 向链表的特定位置插入一个新的项。\nget(position) 获取对应位置的元素。\nindexOf(element) 返回元素在链表中的索引。如果链表中没有该元素就返回 -1。\nupdate(position, element) 修改某个位置的元素。\nremoveAt(position) 从链表的特定位置移除一项。\nremove(element) 从链表中移除一项。\nisEmpty() 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。\nsize() 返回链表包含的元素个数，与数组的 length 属性类似。\ntoString() 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。\n\n单向链表的封装创建单向链表类先创建单向链表类 LinkedList，添加基本属性，再逐步实现单向链表的常用方法。\nclass LinkedList &#123;  // 初始链表长度为 0  length = 0;  // 初始 head 为 null，head 指向链表的第一个节点  head = null;  // 内部类（链表里的节点 Node）  Node = class &#123;    data;    next = null;    constructor(data) &#123;      this.data = data;    &#125;  &#125;;&#125;\n\n实现 append() 方法代码实现// append() 往链表尾部追加数据append(data) &#123;    // 1、创建新节点    const newNode = new this.Node(data);    // 2、追加新节点    if (this.length === 0) &#123;    // 链表长度为 0 时，即只有 head 的时候    this.head = newNode;    &#125; else &#123;    // 链表长度大于 0 时，在最后面添加新节点    let currentNode = this.head;    // 当 currentNode.next 不为空时，    // 循序依次找最后一个节点，即节点的 next 为 null 时    while (currentNode.next !== null) &#123;        currentNode = currentNode.next;    &#125;    // 最后一个节点的 next 指向新节点    currentNode.next = newNode;    &#125;    // 3、追加完新节点后，链表长度 + 1    this.length++;&#125;\n\n过程图解\n首先让 currentNode 指向第一个节点。\n\n\n通过 while 循环使 currentNode 指向最后一个节点，最后通过 currentNode.next = newNode，让最后一个节点指向新节点 newNode。\n\n\n\n代码测试const linkedList = new LinkedList();// 测试 append 方法linkedList.append(&quot;A&quot;);linkedList.append(&quot;B&quot;);linkedList.append(&quot;C&quot;);console.log(linkedList);\n\n\n实现 toString() 方法代码实现toString() &#123;    let currentNode = this.head;    let result = &#x27;&#x27;;    // 遍历所有的节点，拼接为字符串，直到节点为 null    while (currentNode) &#123;    result += currentNode.data + &#x27; &#x27;;    currentNode = currentNode.next;    &#125;    return result;&#125;\n\n代码测试// 测试 toString 方法console.log(linkedList.toString()); //--&gt; AA BB CC\n\n实现 insert() 方法代码实现// insert() 在指定位置（position）插入节点insert(position, data) &#123;    // position 新插入节点的位置    // position = 0 表示新插入后是第一个节点    // position = 1 表示新插入后是第二个节点，以此类推    // 1、对 position 进行越界判断，不能小于 0 或大于链表长度    if (position &lt; 0 || position &gt; this.length) return false;    // 2、创建新节点    const newNode = new this.Node(data);    // 3、插入节点    if (position === 0) &#123; // position = 0 的情况    // 让新节点的 next 指向 原来的第一个节点，即 head    newNode.next = this.head;    // head 赋值为 newNode    this.head = newNode;    &#125; else &#123; // 0 &lt; position &lt;= length 的情况    // 初始化一些变量    let currentNode = this.head; // 当前节点初始化为 head    let previousNode = null; // head 的 上一节点为 null    let index = 0; // head 的 index 为 0    // 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode    // 直到找到要插入的位置    while (index++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;    &#125;    // 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向    newNode.next = currentNode;    previousNode.next = newNode;    &#125;    // 更新链表长度    this.length++;    return newNode;&#125;\n\n代码测试// 测试 insert 方法linkedList.insert(0, &quot;123&quot;);linkedList.insert(2, &quot;456&quot;);console.log(linkedList.toString()); //--&gt; 123 AA 456 BB CC\n\n实现 getData() 方法获取指定位置（position）的 data。\n代码实现getData(position) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return null;    // 2、获取指定 position 节点的 data    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;    currentNode = currentNode.next;    &#125;    // 3、返回 data    return currentNode.data;&#125;\n\n代码测试// 测试 getData 方法console.log(linkedList.getData(0)); //--&gt; 123console.log(linkedList.getData(1)); //--&gt; AA\n\n实现 indexOf() 方法indexOf(data) 返回指定 data 的 index，如果没有，返回 -1。\n代码实现indexOf(data) &#123;    let currentNode = this.head;    let index = 0;    while (currentNode) &#123;    if (currentNode.data === data) &#123;        return index;    &#125;    currentNode = currentNode.next;    index++;    &#125;    return -1;&#125;\n\n代码测试// 测试 indexOf 方法console.log(linkedList.indexOf(&quot;AA&quot;)); //--&gt; 1console.log(linkedList.indexOf(&quot;ABC&quot;)); //--&gt; -1\n\n实现 update() 方法update(position, data) 修改指定位置节点的 data。\n代码实现update(position, data) &#123;    // 涉及到 position 都要进行越界判断    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return false;    // 2、痛过循环遍历，找到指定 position 的节点    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;    currentNode = currentNode.next;    &#125;    // 3、修改节点 data    currentNode.data = data;    return currentNode;&#125;\n\n代码测试// 测试 update 方法linkedList.update(0, &quot;12345&quot;);console.log(linkedList.toString()); //--&gt; 12345 AA 456 BB CClinkedList.update(1, &quot;54321&quot;);console.log(linkedList.toString()); //--&gt; 12345 54321 456 BB CC\n\n实现 removeAt() 方法removeAt(position) 删除指定位置的节点。\n代码实现removeAt(position) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return null;    // 2、删除指定 position 节点    let currentNode = this.head;    if (position === 0) &#123;    // position = 0 的情况    this.head = this.head.next;    &#125; else &#123;    // position &gt; 0 的情况    // 通过循环遍历，找到指定 position 的节点，赋值到 currentNode    let previousNode = null;    let index = 0;    while (index++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;    &#125;    // 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。    previousNode.next = currentNode.next;    &#125;    // 3、更新链表长度 -1    this.length--;    return currentNode;&#125;\n\n代码测试// 测试 removeAt 方法linkedList.removeAt(3);console.log(linkedList.toString()); //--&gt; 12345 54321 456 CC\n\n实现 remove() 方法remove(data) 删除指定 data 所在的节点。\n代码实现remove(data) &#123;    this.removeAt(this.indexOf(data));&#125;\n\n代码测试// 测试 remove 方法linkedList.remove(&quot;CC&quot;);console.log(linkedList.toString()); //--&gt; 12345 54321 456\n\n实现 isEmpty() 方法isEmpty() 判断链表是否为空。\n代码实现isEmpty() &#123;    return this.length === 0;&#125;\n\n代码测试// 测试 isEmpty 方法console.log(linkedList.isEmpty()); //--&gt; false\n\n实现 size() 方法size() 获取链表的长度。\n代码实现size() &#123;    return this.length;&#125;\n\n代码测试// 测试 size 方法console.log(linkedList.size()); //--&gt; 3\n\n完整实现class LinkedList &#123;  // 初始链表长度为 0  length = 0;  // 初始 head 为 null，head 指向链表的第一个节点  head = null;  // 内部类（链表里的节点 Node）  Node = class &#123;    data;    next = null;    constructor(data) &#123;      this.data = data;    &#125;  &#125;;  // ------------ 链表的常见操作 ------------ //  // append() 往链表尾部追加数据  append(data) &#123;    // 1、创建新节点    const newNode = new this.Node(data);    // 2、追加新节点    if (this.length === 0) &#123;      // 链表长度为 0 时，即只有 head 的时候      this.head = newNode;    &#125; else &#123;      // 链表长度大于 0 时，在最后面添加新节点      let currentNode = this.head;      // 当 currentNode.next 不为空时，      // 循序依次找最后一个节点，即节点的 next 为 null 时      while (currentNode.next !== null) &#123;        currentNode = currentNode.next;      &#125;      // 最后一个节点的 next 指向新节点      currentNode.next = newNode;    &#125;    // 3、追加完新节点后，链表长度 + 1    this.length++;  &#125;  // insert() 在指定位置（position）插入节点  insert(position, data) &#123;    // position 新插入节点的位置    // position = 0 表示新插入后是第一个节点    // position = 1 表示新插入后是第二个节点，以此类推    // 1、对 position 进行越界判断，不能小于 0 或大于链表长度    if (position &lt; 0 || position &gt; this.length) return false;    // 2、创建新节点    const newNode = new this.Node(data);    // 3、插入节点    if (position === 0) &#123;      // position = 0 的情况      // 让新节点的 next 指向 原来的第一个节点，即 head      newNode.next = this.head;      // head 赋值为 newNode      this.head = newNode;    &#125; else &#123;      // 0 &lt; position &lt;= length 的情况      // 初始化一些变量      let currentNode = this.head; // 当前节点初始化为 head      let previousNode = null; // head 的 上一节点为 null      let index = 0; // head 的 index 为 0      // 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode      // 直到找到要插入的位置      while (index++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;      &#125;      // 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向      newNode.next = currentNode;      previousNode.next = newNode;    &#125;    // 更新链表长度    this.length++;    return newNode;  &#125;  // getData() 获取指定位置的 data  getData(position) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return null;    // 2、获取指定 position 节点的 data    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;      currentNode = currentNode.next;    &#125;    // 3、返回 data    return currentNode.data;  &#125;  // indexOf() 返回指定 data 的 index，如果没有，返回 -1。  indexOf(data) &#123;    let currentNode = this.head;    let index = 0;    while (currentNode) &#123;      if (currentNode.data === data) &#123;        return index;      &#125;      currentNode = currentNode.next;      index++;    &#125;    return -1;  &#125;  // update() 修改指定位置节点的 data  update(position, data) &#123;    // 涉及到 position 都要进行越界判断    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return false;    // 2、痛过循环遍历，找到指定 position 的节点    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;      currentNode = currentNode.next;    &#125;    // 3、修改节点 data    currentNode.data = data;    return currentNode;  &#125;  // removeAt() 删除指定位置的节点  removeAt(position) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return null;    // 2、删除指定 position 节点    let currentNode = this.head;    if (position === 0) &#123;      // position = 0 的情况      this.head = this.head.next;    &#125; else &#123;      // position &gt; 0 的情况      // 通过循环遍历，找到指定 position 的节点，赋值到 currentNode      let previousNode = null;      let index = 0;      while (index++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;      &#125;      // 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。      previousNode.next = currentNode.next;    &#125;    // 3、更新链表长度 -1    this.length--;    return currentNode;  &#125;  // remove() 删除指定 data 的节点  remove(data) &#123;    this.removeAt(this.indexOf(data));  &#125;  // isEmpty() 判断链表是否为空  isEmpty() &#123;    return this.length === 0;  &#125;  // size() 获取链表的长度  size() &#123;    return this.length;  &#125;  // toString() 链表数据以字符串形式返回  toString() &#123;    let currentNode = this.head;    let result = &quot;&quot;;    // 遍历所有的节点，拼接为字符串，直到节点为 null    while (currentNode) &#123;      result += currentNode.data + &quot; &quot;;      currentNode = currentNode.next;    &#125;    return result;  &#125;&#125;\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","单向链表"]},{"title":"JavaScript 数据结构与算法（十一）树","url":"/post/2fb3cffe3d06/","content":"什么是树？真实的树：\n树的特点：\n树一般都有一个根，连接着根的是树干；\n树干会发生分叉，形成许多树枝，树枝会继续分化成更小的树枝；\n树枝的最后是叶子；\n\n现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转 180° 的树。\n\n树结构对比于数组&#x2F;链表&#x2F;哈希表有哪些优势呢？数组：\n\n优点：可以通过下标值访问，效率高；\n缺点：查找数据时需要先对数据进行排序，生成有序数组，才能提高查找效率；并且在插入和删除元素时，需要大量的位移操作；\n\n链表：\n\n优点：数据的插入和删除操作效率都很高；\n缺点：查找效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。\n\n哈希表：\n\n优点：哈希表的插入&#x2F;查询&#x2F;删除效率都非常高；\n缺点：空间利用率不高，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是无序的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中最大值或最小值这些特殊值。\n\n树结构：\n\n优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。\n\n总的来说：每种数据结构都有自己特定的应用场景。\n树结构：\n\n树（Tree）：由 n（n ≥ 0）个节点构成的有限集合。当 n &#x3D; 0 时，称为空树。\n\n对于任意一棵非空树（n &gt; 0），它具备以下性质：\n\n数中有一个称为根（Root）的特殊节点，用 r 表示；\n其余节点可分为 m（m &gt; 0）个互不相交的有限集合 T1，T2，…，Tm，其中每个集合本身又是一棵树，称为原来树的子树（SubTree）。\n\n\n\n树的常用术语：\n\n节点的度（Degree）：节点的子树个数，比如节点 B 的度为 2；\n树的度：树的所有节点中最大的度数，如上图树的度为 2；\n叶节点（Leaf）：度为 0 的节点（也称为叶子节点），如上图的 H，I 等；\n父节点（Parent）：度不为 0 的节点称为父节点，如上图节点 B 是节点 D 和 E 的父节点；\n子节点（Child）：若 B 是 D 的父节点，那么 D 就是 B 的子节点；\n兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点，比如上图的 B 和 C，D 和 E 互为兄弟节点；\n路径和路径长度：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如 A-&gt;H 的路径长度为 3；\n节点的层次（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1。如 B 和 C 节点的层次为 2；\n树的深度（Depth）：树种所有节点中的最大层次是这棵树的深度，如上图树的深度为 4；\n\n树结构的表示方式最普通的表示方法：\n如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点 A 需要 3 个引用，分别指向子节点 B，C，D；B 节点需要 2 个引用，分别指向子节点 E 和 F；K 节点由于没有子节点，所以不需要引用。\n这种方法缺点在于我们无法确定某一结点的引用数。\n儿子 - 兄弟表示法：\n这种表示方法可以完整地记录每个节点的数据，比如：\n//节点 ANode&#123;  //存储数据  this.data = data  //统一只记录左边的子节点  this.leftChild = B  //统一只记录右边的第一个兄弟节点  this.rightSibling = null&#125;//节点 BNode&#123;  this.data = data  this.leftChild = E  this.rightSibling = C&#125;//节点 FNode&#123;  this.data = data  this.leftChild = null  this.rightSibling = null&#125;\n\n这种表示法的优点在于每一个节点中引用的数量都是确定的。\n儿子 - 兄弟表示法旋转以下为儿子 - 兄弟表示法组成的树结构：\n\n将其顺时针旋转 45° 之后：\n\n这样就成为了一棵二叉树，由此我们可以得出结论：任何树都可以通过二叉树进行模拟。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","树"]},{"title":"JavaScript 数据结构与算法（十三）二叉搜索树","url":"/post/e35d97c028eb/","content":"二叉搜索树二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。\n二叉搜索树是一棵二叉树，可以为空。\n如果不为空，则满足以下性质：\n\n条件 1：非空左子树的所有键值小于其根节点的键值。比如三中节点 6 的所有非空左子树的键值都小于 6；\n条件 2：非空右子树的所有键值大于其根节点的键值；比如三中节点 6 的所有非空右子树的键值都大于 6；\n条件 3：左、右子树本身也都是二叉搜索树；\n\n\n如上图所示，树二和树三符合 3 个条件属于二叉树，树一不满足条件 3 所以不是二叉树。\n总结：二叉搜索树的特点主要是较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中“搜索”的来源。\n二叉搜索树应用举例下面是一个二叉搜索树：\n\n若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。\n\n第 1 次：将 10 与根节点 9 进行比较，由于 10 &gt; 9，所以 10 下一步与根节点 9 的右子节点 13 比较；\n第 2 次：由于 10 &lt; 13，所以 10 下一步与父节点 13 的左子节点 11 比较；\n第 3 次：由于 10 &lt; 11，所以 10 下一步与父节点 11 的左子节点 10 比较；\n第 4 次：由于 10 &#x3D; 10，最终查找到数据 10。\n\n\n同样是 15 个数据，在排序好的数组中查询数据 10，需要查询 10 次：\n\n其实：如果是排序好的数组，可以通过二分查找：第一次找 9，第二次找 13，第三次找 15…。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树。这就是数组二分法查找效率之所以高的原因。\n二叉搜索树的封装二叉搜索树有四个最基本的属性：指向节点的根（root），节点中的键（key）、左指针（right）、右指针（right）。\n\n所以，二叉搜索树中除了定义 root 属性外，还应定义一个节点内部类，里面包含每个节点中的 left、right 和 key 三个属性。\n// 节点类class Node &#123;  constructor(key) &#123;    this.key = key;    this.left = null;    this.right = null;  &#125;&#125;\n\n二叉搜索树的常见操作：\ninsert(key) 向树中插入一个新的键。\nsearch(key) 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 false。\npreOrderTraverse 通过先序遍历方式遍历所有节点。\ninOrderTraverse 通过中序遍历方式遍历所有节点。\npostOrderTraverse 通过后序遍历方式遍历所有节点。\nmin 返回树中最小的值&#x2F;键。\nmax 返回树中最大的值&#x2F;键。\nremove(key) 从树中移除某个键。\n\n插入数据实现思路：\n\n首先根据传入的 key 创建节点对象。\n然后判断根节点是否存在，不存在时通过：this.root &#x3D; newNode，直接把新节点作为二叉搜索树的根节点。\n若存在根节点则重新定义一个内部方法 insertNode() 用于查找插入点。\n\ninsert(key) 代码实现\n// insert(key) 插入数据insert(key) &#123;  const newNode = new Node(key);  if (this.root === null) &#123;    this.root = newNode;  &#125; else &#123;    this.insertNode(this.root, newNode);  &#125;&#125;\n\ninsertNode() 的实现思路：\n根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。\n\n当 newNode.key &lt; node.key 向左查找：\n\n情况 1：当 node 无左子节点时，直接插入：\n\n情况 2：当 node 有左子节点时，递归调用 insertNode()，直到遇到无左子节点成功插入 newNode 后，不再符合该情况，也就不再调用 insertNode()，递归停止。\n\n\n\n当 newNode.key &gt;&#x3D; node.key 向右查找，与向左查找类似：\n\n情况 1：当 node 无右子节点时，直接插入：\n\n情况 2：当 node 有右子节点时，依然递归调用 insertNode()，直到遇到传入 insertNode 方法 的 node 无右子节点成功插入 newNode 为止。\n\n\n\n\ninsertNode(root, node) 代码实现\ninsertNode(root, node) &#123;  if (node.key &lt; root.key) &#123; // 往左边查找插入    if (root.left === null) &#123;      root.left = node;    &#125; else &#123;      this.insertNode(root.left, node);    &#125;  &#125; else &#123; // 往右边查找插入    if (root.right === null) &#123;      root.right = node;    &#125; else &#123;      this.insertNode(root.right, node);    &#125;  &#125;&#125;\n\n遍历数据这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：\n\n先序遍历；\n中序遍历；\n后序遍历；\n\n还有层序遍历，使用较少。\n先序遍历先序遍历的过程为：\n首先，遍历根节点；然后，遍历其左子树；最后，遍历其右子树；\n\n如上图所示，二叉树的节点遍历顺序为：A -&gt; B -&gt; D -&gt; H -&gt; I -&gt; E -&gt; C -&gt; F -&gt; G。\n代码实现：\n// 先序遍历（根左右 DLR）preorderTraversal() &#123;  const result = [];  this.preorderTraversalNode(this.root, result);  return result;&#125;preorderTraversalNode(node, result) &#123;  if (node === null) return result;  result.push(node.key);  this.preorderTraversalNode(node.left, result);  this.preorderTraversalNode(node.right, result);&#125;\n\n中序遍历实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。\n首先，遍历其左子树；然后，遍历根（父）节点；最后，遍历其右子树；\n过程图解：\n\n输出节点的顺序应为：3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 14 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 25。\n代码实现：\n// 中序遍历（左根右 LDR）inorderTraversal() &#123;  const result = [];  this.inorderTraversalNode(this.root, result);  return result;&#125;inorderTraversalNode(node, result) &#123;  if (node === null) return result;  this.inorderTraversalNode(node.left, result);  result.push(node.key);  this.inorderTraversalNode(node.right, result);&#125;\n\n后序遍历实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。\n首先，遍历其左子树；然后，遍历其右子树；最后，遍历根（父）节点；\n过程图解：\n\n输出节点的顺序应为：3 -&gt; 6 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 9 -&gt; 7 -&gt; 12 -&gt; 14 -&gt; 13 -&gt; 18 -&gt; 25 -&gt; 20 -&gt; 15 -&gt; 11。\n代码实现：\n// 后序遍历（左右根 LRD）postorderTraversal() &#123;  const result = [];  this.postorderTraversalNode(this.root, result);  return result;&#125;postorderTraversalNode(node, result) &#123;  if (node === null) return result;  this.postorderTraversalNode(node.left, result);  this.postorderTraversalNode(node.right, result);  result.push(node.key);&#125;\n\n总结以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。\n查找数据查找最大值或最小值在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左&#x2F;右查找就能得到最值，如下图所示：\n\n代码实现：\n// min() 获取二叉搜索树最小值min() &#123;  if (!this.root) return null;  let node = this.root;  while (node.left !== null) &#123;    node = node.left;  &#125;  return node.key;&#125;// max() 获取二叉搜索树最大值max() &#123;  if (!this.root) return null;  let node = this.root;  while (node.right !== null) &#123;    node = node.right;  &#125;  return node.key;&#125;\n\n查找特定值查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的 key 值与之比较，若 node.key &lt; root 则向左查找，若 node.key &gt; root 就向右查找，直到找到或查找到 null 为止。这里可以使用递归实现，也可以采用循环来实现。\n代码实现：\n// search(key) 查找二叉搜索树中是否有相同的 key，存在返回 true，否则返回 falsesearch(key) &#123;  return this.searchNode(this.root, key);&#125;// 通过递归实现searchNode(node, key) &#123;  if (node === null) return false;  if (key &lt; node.key) &#123;    return this.searchNode(node.left, key);  &#125; else if (key &gt; node.key) &#123;    return this.searchNode(node.right, key);  &#125; else &#123;    return true;  &#125;&#125;// 通过 while 循环实现search2(key) &#123;  let node = this.root;  while (node !== null) &#123;    if (key &lt; node.key) &#123;      node = node.left;    &#125; else if (key &gt; node.key) &#123;      node = node.right;    &#125; else &#123;      return true;    &#125;  &#125;  return false;&#125;\n\n删除数据实现思路：\n第一步：先找到需要删除的节点，若没找到，则不需要删除；\n首先定义变量 current 用于保存需要删除的节点、变量 parent 用于保存它的父节点、变量 isLeftChild 保存 current 是否为 parent 的左节点，这样方便之后删除节点时改变相关节点的指向。\nlet currentNode = this.root;let parentNode = null;let isLeftChild = true;// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChildwhile (currentNode.key !== key) &#123;  parentNode = currentNode;  // 小于，往左查找  if (key &lt; currentNode.key) &#123;    isLeftChild = true;    currentNode = currentNode.left;  &#125; else &#123;    // 否则往右查找    isLeftChild = false;    currentNode = currentNode.right;  &#125;  // 找到最后都没找到相等的节点，返回 false  if (currentNode === null) &#123;    return false;  &#125;&#125;\n\n第二步：删除找到的指定节点，后分 3 种情况：\n\n删除的是叶子节点；\n删除的是只有一个子节点的节点；\n删除的是有两个子节点的节点；\n\n删除的是叶子节点删除的是叶子节点分两种情况：\n\n叶子节点也是根节点\n当该叶子节点为根节点时，如下图所示，此时 current &#x3D;&#x3D; this.root，直接通过：this.root &#x3D; null，删除根节点。\n\n\n叶子节点不为根节点\n当该叶子节点不为根节点时也有两种情况，如下图所示\n\n若 current &#x3D; 8，可以通过：parent.left &#x3D; null，删除节点 8；\n若 current &#x3D; 10，可以通过：parent.right &#x3D; null，删除节点 10；\n代码实现：\n// 1、删除的是叶子节点的情况if (currentNode.left === null &amp;&amp; currentNode.right === null) &#123;  if (currentNode === this.root) &#123;    this.root = null;  &#125; else if (isLeftChild) &#123;    parentNode.left = null;  &#125; else &#123;    parentNode.right = null;  &#125;  // 2、删除的是只有一个子节点的节点&#125;\n\n删除的是只有一个子节点的节点有六种情况：\n当 current 存在左子节点时（current.right &#x3D;&#x3D; null）：\n\n情况 1：current 为根节点（current &#x3D;&#x3D; this.root），如节点 11，此时通过：this.root &#x3D; current.left，删除根节点 11；\n\n情况 2：current 为父节点 parent 的左子节点（isLeftChild &#x3D;&#x3D; true），如节点 5，此时通过：parent.left &#x3D; current.left，删除节点 5；\n\n情况 3：current 为父节点 parent 的右子节点（isLeftChild &#x3D;&#x3D; false），如节点 9，此时通过：parent.right &#x3D; current.left，删除节点 9；\n\n\n\n当 current 存在右子节点时（current.left &#x3D; null）：\n\n情况 4：current 为根节点（current &#x3D;&#x3D; this.root），如节点 11，此时通过：this.root &#x3D; current.right，删除根节点 11。\n\n情况 5：current 为父节点 parent 的左子节点（isLeftChild &#x3D;&#x3D; true），如节点 5，此时通过：parent.left &#x3D; current.right，删除节点 5；\n\n情况 6：current 为父节点 parent 的右子节点（isLeftChild &#x3D;&#x3D; false），如节点 9，此时通过：parent.right &#x3D; current.right，删除节点 9；\n\n\n\n代码实现：\n// 2、删除的是只有一个子节点的节点&#125; else if (currentNode.right === null) &#123; // currentNode 只存在左节点  //-- 2.1、currentNode 只存在&lt;左节点&gt;的情况  //---- 2.1.1、currentNode 等于 root  //---- 2.1.2、parentNode.left 等于 currentNode  //---- 2.1.3、parentNode.right 等于 currentNode  if (currentNode === this.root) &#123;    this.root = currentNode.left;  &#125; else if (isLeftChild) &#123;    parentNode.left = currentNode.left;  &#125; else &#123;    parentNode.right = currentNode.left;  &#125;&#125; else if (currentNode.left === null) &#123; // currentNode 只存在右节点  //-- 2.2、currentNode 只存在&lt;右节点&gt;的情况  //---- 2.1.1 currentNode 等于 root  //---- 2.1.1 parentNode.left 等于 currentNode  //---- 2.1.1 parentNode.right 等于 currentNode  if (currentNode === this.root) &#123;    this.root = currentNode.right;  &#125; else if (isLeftChild) &#123;    parentNode.left = currentNode.right;  &#125; else &#123;    parentNode.right = currentNode.right;  &#125;\n\n删除的是有两个子节点的节点这种情况十分复杂，首先依据以下二叉搜索树，讨论这样的问题：\n\n删除节点 9\n在保证删除节点 9 后原二叉树仍为二叉搜索树的前提下，有两种方式：\n\n方式 1：从节点 9 的左子树中选择一合适的节点替代节点 9，可知节点 8 符合要求；\n方式 2：从节点 9 的右子树中选择一合适的节点替代节点 9，可知节点 10 符合要求；\n\n\n删除节点 7\n在保证删除节点 7 后原二叉树仍为二叉搜索树的前提下，也有两种方式：\n\n方式 1：从节点 7 的左子树中选择一合适的节点替代节点 7，可知节点 5 符合要求；\n方式 2：从节点 7 的右子树中选择一合适的节点替代节点 7，可知节点 8 符合要求；\n\n\n删除节点 15\n在保证删除节点 15 后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：\n\n方式 1：从节点 15 的左子树中选择一合适的节点替代节点 15，可知节点 14 符合要求；\n方式 2：从节点 15 的右子树中选择一合适的节点替代节点 15，可知节点 18 符合要求；\n\n\n相信你已经发现其中的规律了！\n规律总结：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点下面的子节点中找到一个合适的节点，来替换当前的节点。\n若用 current 表示需要删除的节点，则合适的节点指的是：\n\ncurrent 左子树中比 current 小一点点的节点，即 current 左子树中的最大值；\ncurrent 右子树中比 current 大一点点的节点，即 current 右子树中的最小值；\n\n前驱&amp;后继在二叉搜索树中，这两个特殊的节点有特殊的名字：\n\n比 current 小一点点的节点，称为 current 节点的前驱。比如下图中的节点 5 就是节点 7 的前驱；\n比 current 大一点点的节点，称为 current 节点的后继。比如下图中的节点 8 就是节点 7 的后继；\n\n\n查找需要被删除的节点 current 的后继时，需要在 current 的右子树中查找最小值，即在 current 的右子树中一直向左遍历查找；\n查找前驱时，则需要在 current 的左子树中查找最大值，即在 current 的左子树中一直向右遍历查找。\n下面只讨论查找 current 后继的情况，查找前驱的原理相同，这里暂不讨论。\n代码实现：\n  // 3、删除的是有两个子节点的节点  &#125; else &#123;    // 1、找到后续节点    let successor = this.getSuccessor(currentNode);    // 2、判断是否为根节点    if (currentNode === this.root) &#123;      this.root = successor;    &#125; else if (isLeftChild) &#123;      parentNode.left = successor;    &#125; else &#123;      parentNode.right = successor;    &#125;    // 3、将后续的左节点改为被删除的左节点    successor.left = currentNode.left;  &#125;&#125;// 获取后续节点，即从要删除的节点的右边开始查找最小的值getSuccessor(delNode) &#123;  // 定义变量，保存要找到的后续  let successor = delNode;  let current = delNode.right;  let successorParent = delNode;  // 循环查找 current 的右子树节点  while (current !== null) &#123;    successorParent = successor;    successor = current;    current = current.left;  &#125;  // 判断寻找到的后续节点是否直接就是要删除节点的 right  if (successor !== delNode.right) &#123;    successorParent.left = successor.right;    successor.right = delNode.right;  &#125;  return successor;&#125;\n\n完整实现// 删除节点remove(key) &#123;  let currentNode = this.root;  let parentNode = null;  let isLeftChild = true;  // 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild  while (currentNode.key !== key) &#123;    parentNode = currentNode;    // 小于，往左查找    if (key &lt; currentNode.key) &#123;      isLeftChild = true;      currentNode = currentNode.left;    &#125; else &#123;  // 否则往右查找      isLeftChild = false;      currentNode = currentNode.right;    &#125;    // 找到最后都没找到相等的节点，返回 false    if (currentNode === null) &#123;      return false;    &#125;  &#125;  // 1、删除的是叶子节点的情况  if (currentNode.left === null &amp;&amp; currentNode.right === null) &#123;    if (currentNode === this.root) &#123;      this.root = null;    &#125; else if (isLeftChild) &#123;      parentNode.left = null;    &#125; else &#123;      parentNode.right = null;    &#125;    // 2、删除的是只有一个子节点的节点  &#125; else if (currentNode.right === null) &#123; // currentNode 只存在左节点    //-- 2.1、currentNode 只存在&lt;左节点&gt;的情况    //---- 2.1.1、currentNode 等于 root    //---- 2.1.2、parentNode.left 等于 currentNode    //---- 2.1.3、parentNode.right 等于 currentNode    if (currentNode === this.root) &#123;      this.root = currentNode.left;    &#125; else if (isLeftChild) &#123;      parentNode.left = currentNode.left;    &#125; else &#123;      parentNode.right = currentNode.left;    &#125;  &#125; else if (currentNode.left === null) &#123; // currentNode 只存在右节点    //-- 2.2、currentNode 只存在&lt;右节点&gt;的情况    //---- 2.1.1 currentNode 等于 root    //---- 2.1.1 parentNode.left 等于 currentNode    //---- 2.1.1 parentNode.right 等于 currentNode    if (currentNode === this.root) &#123;      this.root = currentNode.right;    &#125; else if (isLeftChild) &#123;      parentNode.left = currentNode.right;    &#125; else &#123;      parentNode.right = currentNode.right;    &#125;    // 3、删除的是有两个子节点的节点  &#125; else &#123;    // 1、找到后续节点    let successor = this.getSuccessor(currentNode);    // 2、判断是否为根节点    if (currentNode === this.root) &#123;      this.root = successor;    &#125; else if (isLeftChild) &#123;      parentNode.left = successor;    &#125; else &#123;      parentNode.right = successor;    &#125;    // 3、将后续的左节点改为被删除的左节点    successor.left = currentNode.left;  &#125;&#125;// 获取后续节点，即从要删除的节点的右边开始查找最小的值getSuccessor(delNode) &#123;  // 定义变量，保存要找到的后续  let successor = delNode;  let current = delNode.right;  let successorParent = delNode;  // 循环查找 current 的右子树节点  while (current !== null) &#123;    successorParent = successor;    successor = current;    current = current.left;  &#125;  // 判断寻找到的后续节点是否直接就是要删除节点的 right  if (successor !== delNode.right) &#123;    successorParent.left = successor.right;    successor.right = delNode.right;  &#125;  return successor;&#125;\n\n平衡树二叉搜索树的缺陷：当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树由 11 7 15 组成，如下图所示：\n\n当插入一组有序数据：6 5 4 3 2 就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。\n\n非平衡树\n\n比较好的二叉搜索树，它的数据应该是左右均匀分布的。\n但是插入连续数据后，二叉搜索树中的数据分布就变得不均匀了，我们称这种树为非平衡树。\n对于一棵平衡二叉树来说，插入&#x2F;查找等操作的效率是 O(log n)。\n而对于一棵非平衡二叉树来说，相当于编写了一个链表，查找效率变成了 O(n)。\n\n树的平衡性\n为了能以较快的时间 O(log n) 来操作一棵树，我们需要保证树总是平衡的：\n\n起码大部分是平衡的，此时的时间复杂度也是接近 O(log n) 的；\n这就要求树中每个节点左边的子孙节点的个数，应该尽可能地等于右边的子孙节点的个数；\n\n常见的平衡树\n\nAVL 树：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于 AVL 树是平衡树，所以它的时间复杂度也是 O(log n)。但是它的整体效率不如红黑树，开发中比较少用。\n红黑树：同样通过一些特性来保持树的平衡，时间复杂度也是 O(log n)。进行插入&#x2F;删除等操作时，性能优于 AVL 树，所以平衡树的应用基本都是红黑树。\n\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","二叉搜索树"]},{"title":"JavaScript 数据结构与算法（十二）二叉树","url":"/post/070b16d562fc/","content":"二叉树如果树中的每一个节点最多只能由两个子节点，这样的树就称为二叉树；\n二叉树的组成\n二叉树可以为空，也就是没有节点；\n若二叉树不为空，则它由根节点和称为其左子树 TL 和右子树 TR 的两个不相交的二叉树组成；\n\n二叉树的五种形态\n上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树 TL 的二叉树、只有右子树 TR 的二叉树和有左右两个子树的二叉树。\n二叉树的特性\n一个二叉树的第 i 层的最大节点树为：2^(i-1)^，i &gt;&#x3D; 1；\n深度为 k 的二叉树的最大节点总数为：2^k^ - 1，k &gt;&#x3D; 1；\n对任何非空二叉树，若 n0 表示叶子节点的个数，n2表示度为 2 的非叶子节点个数，那么两者满足关系：n0 &#x3D; n2 + 1；如下图所示：H，E，I，J，G 为叶子节点，总数为 5；A，B，C，F 为度为 2 的非叶子节点，总数为 4；满足 n0 &#x3D; n2 + 1 的规律。\n\n\n特殊的二叉树完美二叉树完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有 2 个子节点，这就构成了完美二叉树。\n\n完全二叉树完全二叉树（Complete Binary Tree）:\n\n除了二叉树最后一层外，其他各层的节点数都达到了最大值；\n并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；\n完美二叉树是特殊的完全二叉树；\n\n\n在上图中，由于 H 缺失了右子节点，所以它不是完全二叉树。\n二叉树的数据存储常见的二叉树存储方式为数组和链表：\n使用数组\n完全二叉树：按从上到下，从左到右的方式存储数据。\n\n\n\n\n\n节点\nA\nB\nC\nD\nE\nF\nG\nH\nI\n\n\n\n序号\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 _ 2，右子节点的序号等于父节点序号 _ 2 + 1。\n\n非完全二叉树：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。\n\n\n\n\n\n节点\nA\nB\nC\n^\n^\nF\n^\n^\n^\n^\n^\n^\nM\n\n\n\n序号\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n使用链表二叉树最常见的存储方式为链表：每一个节点封装成一个 Node，Node 中包含存储的数据、左节点的引用和右节点的引用。\n\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","二叉树"]},{"title":"JavaScript 数据结构与算法（十四）图","url":"/post/b47bb8401ee1/","content":"图的概念在计算机程序设计中，图也是一种非常常见的数据结构，图论其实是一个非常大的话题，在数学上起源于哥尼斯堡七桥问题。\n什么是图？\n图是一种与树有些相似的数据结构。\n\n实际上，在数学的概念上，树是图的一种。\n我们知道树可以用来模拟很多现实的数据结构，比如：家谱&#x2F;公司组织架构等等。\n\n\n那么图长什么样子呢？或者什么样的数据使用图来模拟更合适呢？\n\n人与人之间的关系网\n\n互联网中的网络关系\n\n广州地铁图\n\n\n\n那么，什么是图呢？\n\n我们会发现，上面的结点（其实图中叫顶点 Vertex）之间的关系，是不能使用树来表示（几叉树都不可以）。\n这个时候，我们就可以使用图来模拟它们。\n\n\n图通常有什么特点呢？\n\n一组顶点：通常用 V (Vertex) 表示顶点的集合\n一组边：通常用 E (Edge) 表示边的集合\n边是顶点和顶点之间的连线\n边可以是有向的，也可以是无向的。（比如 A — B，通常表示无向。A –&gt; B，通常表示有向）\n\n\n\n图的术语术语\n我们在学习树的时候，树有很多的其他术语，了解这些术语有助于我们更深层次的理解图。\n\n但是图的术语其实非常多，如果你找一本专门讲图的各个方面的书籍，会发现只是术语就可以占据一个章节。\n\n这里，这里介绍几个比较常见的术语，某些术语后面用到的时候，再了解，没有用到的，不做赘述。\n\n下面这是个抽象出来的图\n\n顶点\n\n顶点刚才我们已经介绍过了，表示图中的一个结点。\n比如地铁站中某个站&#x2F;多个村庄中的某个村庄&#x2F;互联网中的某台主机&#x2F;人际关系中的人。\n\n\n边\n\n边表示顶点和顶点之间的连线。\n比如地铁站中两个站点之间的直接连线，就是一个边。\n注意：这里的边不要叫做路径，路径有其他的概念，后面会区分。\n\n\n相邻顶点\n\n由一条边连接在一起的顶点称为相邻顶点。\n比如 0 - 1 是相邻的，0 - 3 是相邻的。0 - 2 是不相邻的。\n\n\n度\n\n一个顶点的度是相邻顶点的数量\n比如 0 顶点和其他两个顶点相连，0 顶点的度是 2\n比如 1 顶点和其他四个顶点相连，1 顶点的度是 4\n\n\n路径\n\n路径是顶点 v1，v2…，vn 的一个连续序列，比如上图中 0 1 5 9 就是一条路径。\n简单路径：简单路径要求不包含重复的顶点。比如 0 1 5 9 是一条简单路径。\n回路：第一个顶点和最后一个顶点相同的路径称为回路。比如 0 1 5 6 3 0。\n\n\n无向图\n\n上面的图就是一张无向图，因为所有的边都没有方向。\n比如 0 - 1 之间有变，那么说明这条边可以保证 0 -&gt; 1，也可以保证 1 -&gt; 0。\n\n\n有向图\n\n有向图表示的图中的边是有方向的。\n比如 0 -&gt; 1，不能保证一定可以 1 -&gt; 0，要根据方向来定。\n\n\n\n无权图和带权图\n无权图\n\n我们上面的图就是一张无权图（边没有携带权重）\n我们上面的图中的边是没有任何意义的，不能收 0 - 1 的边，比 4 - 9 的边更远或者用的时间更长。\n\n\n带权图\n\n带权图表示边有一定的权重\n这里的权重可以是任意你希望表示的数据：比如距离或者花费的时间或者票价。\n我们来看一张有向和带权的图\n\n\n\n现实建模\n对交通流量建模\n\n顶点可以表示街道的十字路口，边可以表示街道.。\n加权的边可以表示限速或者车道的数量或者街道的距离。\n建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道。\n\n\n对飞机航线建模\n\n航空公司可以用图来为其飞行系统建模。\n将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。\n加权的边可以表示从一个机场到另一个机场的航班成本，或两个机场间的距离。\n建模人员可以利用这个系统有效的判断从一个城市到另一个城市的最小航行成本。​\n\n\n\n二、图的表示我们知道一个图包含很多顶点，另外包含顶点和顶点之间的连线（边），这两个都是非常重要的图信息，因此都需要在程序中体现出来。\n顶点表示\n顶点的表示相对简单\n\n上面的顶点，我们抽象成了 1 2 3 4，也可以抽象成 A B C D。在后面的案例中，我们使用 A B C D。\n那么这些 A B C D 我们可以使用一个数组来存储起来 (存储所有的顶点)。\n当然，A B C D 有可能还表示其他含义的数据 (比如村庄的名字)，这个时候，可以另外创建一个数组，用于存储对应的其他数据。\n\n\n边的表示略微复杂\n\n因为边是两个顶点之间的关系，所以表示起来会稍微麻烦一些。\n下面是变常见的表示方式。\n\n\n\n邻接矩阵\n概述\n\n邻接矩阵让每个节点和一个整数向关联，该整数作为数组的下标值。\n我们用一个二维数组来表示顶点之间的连接。\n演示\n\n\n图片解析\n\n在二维数组中，0 表示没有连线，1 表示有连线。\n通过二维数组，我们可以很快的找到一个顶点和哪些顶点有连线。（比如 A 顶点，只需要 遍历第一行即可）\n另外，A - A，B - B（也就是顶点到自己的连线），通常使用 0 表示。\n\n\n邻接矩阵的问题\n\n如果是一个无向图，邻接矩阵展示出来的二维数组，其实是一个对称图。\n\n也就是 A -&gt; D 是 1 的时候，对称的位置 D -&gt; 1 一定也是 1。\n那么这种情况下会造成空间的浪费，解决办法需自己去研究下。\n\n\n邻接矩阵还有一个比较严重的问题就是如果图是一个稀疏图\n\n那么矩阵中将存在大量的 0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。\n而且即使只有一个边，我们也必须遍历一行来找出这个边，也浪费很多时间。\n\n\n\n\n\n邻接表\n概述\n\n邻接表由图中每个顶点以及和顶点相邻的顶点列表组成。\n这个列表有很多中方式来存储：数组&#x2F;链表&#x2F;字典 (哈希表) 都可以。\n演示\n\n\n图片解析\n\n其实图片比较容易理解\n比如我们要表示和 A 顶点有关联的顶点（边），A 和 B&#x2F;C&#x2F;D 有边，那么我们可以通过 A 找到 对应的数组&#x2F;链表&#x2F;字典，再取出其中的内容就可以啦。\n\n\n邻接表的问题\n\n邻接表计算“出度”是比较简单的（出度：指向别人的数量，入度：指向自己的数量）\n邻接表如果需要计算有向图的“入度”，那么是一件非常麻烦的事情。\n它必须构造一个“逆邻接表”，才能有效的计算“入度”。而临街矩阵会非常简单。\n\n\n\n三、图的封装创建图类\n先来创建 Graph 类，定义了两个属性：\nvertexes 用于存储所有的顶点，使用一个数组来保存。\nadjList adj 是 adjoin 的缩写，邻接的意思。adjList 用于存储所有的边，这里采用邻接表的形式。\n\n\n\nclass Graph &#123;  constructor() &#123;    this.vertexes = []; // 存储顶点    this.adjList = new Dictionay(); //存储边信息  &#125;&#125;\n\n添加方法\n添加顶点：可以向图中添加一些顶点。\n将添加的顶点放入到数组中。\n另外，给该顶点创建一个数组[]，该数组用于存储顶点连接的所有的边.（回顾邻接表的实现方式）\n\n\n\n// 添加顶点addVertex(val) &#123;    // 添加点    this.vertexes.push(val)    // 添加点的关系  采用邻接矩阵法 结构用 Map    this.adjList.set(val, [])&#125;\n\n\n添加边：可以指定顶点和顶点之间的边。\n添加边需要传入两个顶点，因为边是两个顶点之间的边，边不可能单独存在。\n根据顶点 v 取出对应的数组，将 w 加入到它的数组中。\n根据顶点 w 取出对应的数组，将 v 加入到它的数组中。\n因为这里实现的是无向图，所以边是可以双向的。\n\n\n\n// 添加边addEdge(val1, val2) &#123;    // 添加边需要传入两个顶点，因为边是两个顶点之间的边，边不可能单独存在。    // 这里实现的是无向图，所以这里不考虑方向问题    this.adjList.get(val1).push(val2)    this.adjList.get(val2).push(val1)&#125;\n\ntoString 方法：为了能够正确的显示图的结果，就是拿出二维数组的每一项。\n// 输出图结构toString() &#123;    let res = &#x27;&#x27;    for (let i = 0; i &lt; this.vertexes.length; i++) &#123;        res += this.vertexes[i] + &quot;-&gt;&quot;        let adj = this.adjList.get(this.vertexes[i])        for (let j = 0; j &lt; adj.length; j++) &#123;            res += adj[j] + &quot;&quot;        &#125;        res += &quot;\\n&quot;    &#125;    return res&#125;\n\n测试代码// 测试代码let graph = new Graph();// 添加顶点let myVertexes = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;];for (let i = 0; i &lt; myVertexes.length; i++) &#123;  graph.addVertex(myVertexes[i]);&#125;// 添加边graph.addEdge(&quot;A&quot;, &quot;B&quot;);graph.addEdge(&quot;A&quot;, &quot;C&quot;);graph.addEdge(&quot;A&quot;, &quot;D&quot;);graph.addEdge(&quot;C&quot;, &quot;D&quot;);graph.addEdge(&quot;C&quot;, &quot;G&quot;);graph.addEdge(&quot;D&quot;, &quot;G&quot;);graph.addEdge(&quot;D&quot;, &quot;H&quot;);graph.addEdge(&quot;B&quot;, &quot;E&quot;);graph.addEdge(&quot;B&quot;, &quot;F&quot;);graph.addEdge(&quot;E&quot;, &quot;I&quot;);\n\n四、图的遍历和其他数据结构一样，需要通过某种算法来遍历图结构中每一个数据。这样可以保证，在我们需要时，通过这种算法来访问某个顶点的数据以及它对应的边。\n遍历的方式\n图的遍历思想图的遍历算法的思想在于必须访问每个第一次访问的节点，并且追踪有哪些顶点还没有被访问到。\n\n有两种算法可以对图进行遍历\n\n广度优先搜索 (Breadth-First Search, 简称 BFS)\n深度优先搜索 (Depth-First Search, 简称 DFS)\n两种遍历算法，都需要明确指定第一个被访问的顶点。\n\n\n遍历的注意点\n\n完全探索一个顶点要求我们便查看该顶点的每一条边。\n对于每一条所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。\n为了保证算法的效率：每个顶点至多访问两次。\n\n\n两种算法的思想\n\nBFS 基于队列，入队列的顶点先被探索。\nDFS 基于栈，通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问。\n\n\n为了记录顶点是否被访问过，我们使用三种颜色来反应它们的状态。(或者两种颜色也可以)\n\n白色表示该顶点还没有被访问。\n灰色表示该顶点被访问过，但并未被探索过。\n黑色表示该顶点被访问过且被完全探索过。\n初始化颜色代码\n\n\n\n// 初始化顶点的颜色_initializeColor() &#123;    // 白色：表示该顶点还没有被访问。    // 灰色：表示该顶点被访问过，但并未被探索过。    // 黑色：表示该顶点被访问过且被完全探索过。    let colors = []    for (let i = 0; i &lt; this.vertexes.length; i++) &#123;        colors[this.vertexes[i]] = &quot;white&quot;    &#125;    return colors&#125;\n\n广度优先搜索 (BFS)\n广度优先搜索算法的思路广度优先算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深的访问顶点。\n\n图解 BFS\n\n广度优先搜索的实现\n\n创建一个队列 Q\n将 v 标注为被发现的 (灰色), 并将 v 将入队列 Q\n如果 Q 非空，执行下面的步骤：\n将 v 从 Q 中取出队列\n将 v 标注为被发现的灰色\n将 v 所有的未被访问过的邻接点（白色），加入到队列中\n将 v 标志为黑色\n\n\n\n\n广度优先搜索的代码\n// 广度优先搜索bfs(handle) &#123;    // 1.初始化颜色    let color = this._initializeColor()    // 2. 创建队列    let queue = new Queue    // 3. 将传入的顶点放入队列    queue.enqueue(this.vertexes[0])    // 4.依赖队列操作数据   队列不为空时一直持续    while (!queue.isEmpty()) &#123;        // 4.1 拿到队头        let qVal = queue.dequeue()        //  4.2 拿到队头所关联（相连）的点并设置为访问中状态（灰色）        let qAdj = this.adjList.get(qVal)        color[qVal] = &quot;gray&quot;        // 4.3 将队头关联的点添加到队尾        // 这一步是完成bfs的关键，依赖队列的先进先出的特点。        for (let i = 0; i &lt; qAdj.length; i++) &#123;            let a = qAdj[i]            if (color[a] === &quot;white&quot;) &#123;                color[a] = &quot;gray&quot;                queue.enqueue(a)            &#125;        &#125;        // 4.5设置访问完的点为黑色。        color[qVal] = &quot;black&quot;        if (handle) [            handle(qVal)        ]    &#125;&#125;\n\n测试代码\n// 调用广度优先算法let result = &quot;&quot;;graph.bfs(graph.vertexes[0], function (v) &#123;  result += v + &quot; &quot;;&#125;);console.log(result); // A B C D E F G H I\n\n深度优先搜索 (DFS)深度优先搜索的思路：\n\n深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径知道这条路径最后被访问了。\n接着原路回退并探索吓一条路径。\n图解 DFS\n\n深度优先搜索算法的实现：\n\n广度优先搜索算法我们使用的是队列，这里可以使用栈完成，也可以使用递归。\n\n方便代码书写，我们还是使用递归 (递归本质上就是函数栈的调用)\n\n深度优先搜索算法的代码：\n// 深度优先搜索dfs(handle) &#123;    // 1.初始化颜色    let color = this._initializeColor()    // 2. 遍历所有顶点，开始访问    for (let i = 0; i &lt; this.vertexes.length; i++) &#123;        if (color[this.vertexes[i]] === &quot;white&quot;) &#123;            this._dfsVisit(this.vertexes[i], color, handle)        &#125;    &#125;&#125;// dfs 的递归方法  这里直接使用函数的调用栈_dfsVisit(val, color, handle) &#123;    // 1. 将颜色设置为访问中    color[val] = &quot;gray&quot;    // 2. 执行相应的回调    if (handle) &#123;        handle(val)    &#125;    // 3. 拿与该点相邻的点，对每个点操作    let adj = this.adjList.get(val)    for (let i = 0; i &lt; adj.length; i++) &#123;        let w = adj[i]        // 如果相邻点未未访问状态，开始访问。        if (color[w] === &quot;white&quot;) &#123;            this._dfsVisit(w, color, handle)        &#125;    &#125;    // 4. 处理完后设置为访问过点。    color[val] = &quot;black&quot;&#125;\n\n测试代码\n// 调用深度优先算法result = &quot;&quot;;graph.dfs(function (v) &#123;  result += v + &quot; &quot;;&#125;);// 输出深度优先console.log(result); //A B E I F C D G H\n\n递归的代码较难理解一些，这副图来帮助理解过程：\n\n\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","图"]},{"title":"JavaScript 数据结构与算法（十）哈希表","url":"/post/792c9a94eea1/","content":"认识哈希表哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构。\n哈希表通常是基于数组实现的，但是相对于数组，它存在更多优势：\n\n哈希表可以提供非常快速的 插入 - 删除 - 查找 操作。\n无论多少数据，插入和删除值都只需接近常量的时间，即 O(1) 的时间复杂度。实际上，只需要几个机器指令即可完成。\n哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。\n哈希表相对于树来说编码要简单得多。\n\n哈希表同样存在不足之处：\n\n哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。\n通常情况下，哈希表中的 key 是不允许重复的，不能放置相同的 key，用于保存不同的元素。\n\n哈希表是什么？\n\n哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。\n哈希表的结构就是数组，但它神奇之处在于对下标值的一种变换，这种变换我们可以称之为哈希函数，通过哈希函数可以获取 HashCode。\n\n通过以下案例了解哈希表：\n\n案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。\n\n案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。\n\n\n也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的映射关系。\n认识哈希化为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如 a 为 1，b 为 2，c 为 3，以此类推 z 为 26，空格为 27（不考虑大写情况）。\n有了编码系统后，将字母转化为数字也有很多种方案：\n\n方案一：数字相加。\n\n例如 cats 转化为数字：3 + 1 + 20 + 19 = 43，那么就把 43 作为 cats 单词的下标值储存在数组中；\n但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是 43，比如 was。而在数组中一个下标值只能储存一个数据，所以该方式不合理。\n\n方案二：幂的连乘。\n\n我们平时使用的大于 10 的数字，就是用幂的连乘来表示它的唯一性的。比如： 6543 = 6 * 10^3 + 5 * 10^2 + 4 * 10 + 3；这样单词也可以用该种方式来表示：cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337。\n虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如 aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组，然而其中却有许多下标值指向的是无效的数据（比如不存在 zxcvvv 这样的单词），造成了数组空间的浪费。\n两种方案总结：\n\n第一种方案（让数字相加求和）产生的数组下标太少。\n第二种方案（与 27 的幂相乘求和）产生的数组下标又太多。\n\n现在需要一种压缩方法，把幂的连乘方案系统中得到的巨大整数范围压缩到可接受的数组范围中。可以通过取余操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。\n哈希表的一些概念\n哈希化\n将大数字转化成数组范围内下标的过程，称之为哈希化。\n\n哈希函数\n我们通常会将单词转化成大数字，把大数字进行哈希化的代码实现放在一个函数中，该函数就称为哈希函数。\n\n哈希表\n对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。\n\n\n地址的冲突在实际中，经过哈希函数哈希化过后得到的下标值可能有重复，这种情况称为冲突，冲突是不可避免的，我们只能解决冲突。\n解决冲突常见的两种方案：链地址法（拉链法）和开放地址法。\n链地址法（拉链法）如下图所示，我们将每一个数字都对 10 进行取余操作，则余数的范围 0~9 作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的数组或链表。\n\n这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。\n总结：链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一条链条，这条链条常使用的数据结构为数组或链表，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。\n开放地址法开放地址法的主要工作方式是寻找空白的单元格来放置冲突的数据项。\n\n根据探测空白单元格位置方式的不同，可分为三种方法：\n\n线性探测\n二次探测\n再哈希法\n\n线性探测\n当插入 13 时：\n\n经过哈希化（对 10 取余）之后得到的下标值 index&#x3D;3，但是该位置已经放置了数据 33。而线性探测就是从 index 位置 +1 开始向后一个一个来查找合适的位置来放置 13，所谓合适的位置指的是空的位置，如上图中 index&#x3D;4 的位置就是合适的位置。\n\n当查询 13 时：\n\n首先 13 经过哈希化得到 index&#x3D;3，如果 index&#x3D;3 的位置存放的数据与需要查询的数据 13 相同，就直接返回；不相同时，则线性查找，从 index+1 位置开始一个一个位置地查找数据 13。\n查询过程中不会遍历整个哈希表，只要查询到空位置，就停止，因为插入 13 时不会跳过空位置去插入其他位置。\n\n\n当删除 13 时：\n\n删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，不能将该位置下标的内容设置为 null，否则会影响到之后其他的查询操作，因为一遇到为 null 的位置就会停止查找。\n通常删除一个位置的数据项时，我们可以将它进行特殊处理（比如设置为 -1），这样在查找时遇到 -1 就知道要继续查找。\n\n\n\n线性探测存在的问题：\n\n线性探测存在一个比较严重的问题，就是聚集。\n\n如哈希表中还没插入任何元素时，插入 23、24、25、26、27，这就意味着下标值为 3、4、5、6、7 的位置都放置了数据，这种一连串填充单元就称为聚集。\n\n聚集会影响哈希表的性能，无论是插入&#x2F;查询&#x2F;删除都会影响。\n\n比如插入 13 时就会发现，连续的单元 3~7 都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。\n\n\n\n二次探测上文所说的线性探测存在的问题：\n\n如果之前的数据是连续插入的，那么新插入的一个数据可能需要探测很长的距离；\n二次探测是在线性探测的基础上进行了优化：\n\n线性探测：我们可以看成是步长为 1 的探测，比如从下表值 x 开始，那么线性探测就是按照下标值：x+1、x+2、x+3 等依次探测；\n\n二次探测：对步长进行了优化，比如从下标值 x 开始探测：x+1^2^、x+2^2^、x+3^3^ 。这样一次性探测比较长的距离，避免了数据聚集带来的影响。\n\n二次探测存在的问题：\n当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成步长不一的一种聚集（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。\n\n\n再哈希法在开放地址法中寻找空白单元格的最好的解决方式为再哈希化。\n\n二次探测的步长是固定的：1，4，9，16 依次类推。\n现在需要一种方法：产生一种依赖关键字 (数据) 的探测序列，而不是每个关键字探测步长都一样。\n这样，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。\n再哈希法的做法为：把关键字用另一个哈希函数，再做一次哈希化，用这次哈希化的结果作为该关键字的步长。\n\n第二次哈希化需要满足以下两点：\n\n和第一个哈希函数不同，不然哈希化后的结果仍是原来位置；\n不能输出为 0，否则每次探测都是原地踏步的死循环；\n\n优秀的哈希函数：\n\nstepSize &#x3D; constant - （key % constant）；\n其中 constant 是质数，且小于数组的容量；\n例如：stepSize &#x3D; 5 - （key % 5），满足需求，并且结果不可能为 0；\n\n哈希化的效率\n哈希表中执行插入和搜索操作效率是非常高的。\n\n如果没有发生冲突，那么效率就会更高；\n如果发生冲突，存取时间就依赖后来的探测长度；\n平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度会越来越长。\n\n装填因子\n装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值；\n装填因子 &#x3D; 总数据项 &#x2F; 哈希表长度；\n开放地址法的装填因子最大为 1，因为只有空白的单元才能放入元素；\n链地址法的装填因子可以大于 1，因为只要愿意，拉链法可以无限延伸下去；\n\n不同探测方式性能的比较\n线性探测\n可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。\n\n\n二次探测和再哈希化的性能\n二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。\n\n\n链地址法的性能\n可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如 Java 中的 HashMap 中使用的就是链地址法。\n\n\n\n哈希函数哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中尽量减少乘法和除法。\n性能高的哈希函数应具备以下两个优点：\n\n快速的计算；\n均匀的分布；\n\n快速计算霍纳法则：在中国霍纳法则也叫做秦久韶算法，具体算法为：\n\n求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求 n 次多项式 f(x) 的值就转化为求 n 个一次多项式的值。\n\n变换之前：\n\n乘法次数：n(n+1)&#x2F;2 次；\n加法次数：n 次；\n\n\n变换之后：\n\n乘法次数：n 次；\n加法次数：n 次；\n\n\n\n如果使用大 O 表示时间复杂度的话，直接从变换前的 O(N^2) 降到了 O(N)。\n均匀分布在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：链地址法或者开放地址法。但是，为了提供效率，最好的情况还是让数据在哈希表中均匀分布。因此，我们需要在使用常量的地方，尽量使用质数。比如：哈希表的长度、N 次幂的底数等。\nJava 中的 HashMap 采用的是链地址法，哈希化采用的是公式为：index &#x3D; HashCode(key) &amp; (Length-1) 即将数据化为二进制进行与运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是 JavaScript 在进行较大数据的与运算时会出现问题，所以我们使用 JavaScript 实现哈希化时采用取余运算。\n封装哈希表哈希表常见操作\nput(key, value) 插入或修改操作。\nget(key) 获取哈希表中特定位置的元素。\nremove(key) 删除哈希表中特定位置的元素。\nisEmpty() 如果哈希表中不包含任何元素，返回 trun，如果哈希表长度大于 0 则返回 false。\nsize() 返回哈希表包含的元素个数。\nresize(value) 对哈希表进行扩容操作。\n\n哈希函数的简单实现首先使用霍纳法则计算 hashCode 的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。\nhashFn(string, limit = 7) &#123;  // 自己采用的一个质数（无强制要求，质数即可）  const PRIME = 31;  // 1、定义存储 hashCode 的变量  let hashCode = 0;  // 2、使用霍纳法则（秦九韶算法），计算 hashCode 的值  for (let item of string) &#123;    hashCode = PRIME * hashCode + item.charCodeAt();  &#125;  // 3、对 hashCode 取余，并返回  return hashCode % limit;&#125;\n\n哈希函数测试\nconsole.log(hashFn(&quot;123&quot;)); //--&gt; 5console.log(hashFn(&quot;abc&quot;)); //--&gt; 6\n\n哈希表的实现创建哈希表类封装的哈希表的数据结构模型：\n\n首先创建哈希表类 HashTable，并添加必要的属性和上面实现的哈希函数，再进行其他方法的实现。\nclass HashTable &#123;  constructor() &#123;    this.storage = []; // 哈希表存储数据的变量    this.count = 0; // 当前存放的元素个数    this.limit = 7; // 哈希表长度（初始设为质数 7）  &#125;&#125;\n\nput(key,value)哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个 [key, value] 时，如果原来不存在该 key，那么就是插入操作，如果原来已经存在该 key，那么就是修改操作。\n\n实现思路：\n\n首先，根据 key 获取索引值 index，目的为将数据插入到 storage 的对应位置；\n然后，根据索引值取出 bucket，如果 bucket 不存在，先创建 bucket，随后放置在该索引值的位置；\n接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。\n最后，进行新增数据操作。\n\n代码实现\n// put(key, value) 往哈希表里添加数据put(key, value) &#123;  // 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取）  const index = hashFn(key, this.limit);  // 2、根据 index 取出对应的 bucket  let bucket = this.storage[index];  // 3、判断是否存在 bucket  if (bucket === undefined) &#123;    bucket = [];  // 不存在则创建    this.storage[index] = bucket;  &#125;  // 4、判断是插入数据操作还是修改数据操作  for (let i = 0; i &lt; bucket.length; i++) &#123;    let tuple = bucket[i]; // tuple 的格式：[key, value]    if (tuple[0] === key) &#123; // 如果 key 相等，则修改数据      tuple[1] = value;      return; // 修改完 tuple 里数据，return 终止不再往下执行。    &#125;  &#125;  // 5、bucket 新增数据  bucket.push([key, value]); // bucket 存储元组 tuple，格式为 [key, value]  this.count++;  // 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容  if (this.count / this.limit &gt; this.loadFactor) &#123;    this.resize(this.getPrime(this.limit * 2));  &#125;&#125;\n\nget(key)实现思路：\n\n首先，根据 key 通过哈希函数获取它在 storage 中对应的索引值 index。\n然后，根据索引值获取对应的 bucket。\n接着，判断获取到的 bucket 是否为 null，如果为 null，直接返回 null。\n随后，线性遍历 bucket 中每一个 key 是否等于传入的 key。如果等于，直接返回对应的 value。\n最后，遍历完 bucket 后，仍然没有找到对应的 key，直接 return null 即可。\n\n代码实现\n// 根据 get(key) 获取 valueget(key) &#123;  const index = hashFn(key, this.limit);  const bucket = this.storage[index];  if (bucket === undefined) &#123;    return null;  &#125;  for (const tuple of bucket) &#123;    if (tuple[0] === key) &#123;      return tuple[1];    &#125;  &#125;  return null;&#125;\n\nremove(key)实现思路：\n\n首先，根据 key 通过哈希函数获取它在 storage 中对应的索引值 index。\n然后，根据索引值获取对应的 bucket。\n接着，判断获取到的 bucket 是否为 null，如果为 null，直接返回 null。\n随后，线性查找 bucket，寻找对应的数据，并且删除。\n最后，依然没有找到，返回 null。\n\n// remove(key) 删除指定 key 的数据remove(key) &#123;  const index = hashFn(key, this.limit);  const bucket = this.storage[index];  if (bucket === undefined) &#123;    return null;  &#125;  // 遍历 bucket，找到对应位置的 tuple，将其删除  for (let i = 0, len = bucket.length; i &lt; len; i++) &#123;    const tuple = bucket[i];    if (tuple[0] === key) &#123;      bucket.splice(i, 1); // 删除对应位置的数组项      this.count--;      // 根据装填因子的大小，判断是否要进行哈希表压缩      if (this.limit &gt; 7 &amp;&amp; this.count / this.limit &lt; this.minLoadFactor) &#123;        this.resize(this.getPrime(Math.floor(this.limit / 2)));      &#125;      return tuple;    &#125;  &#125;&#125;\n\nisEmpty()isEmpty() &#123;  return this.count === 0;&#125;\n\nsize()size() &#123;  return this.count;&#125;\n\n哈希表的扩容与压缩为什么需要扩容？\n\n前面我们在哈希表中使用的是长度为 7 的数组，由于使用的是链地址法，装填因子 (loadFactor) 可以大于 1，所以这个哈希表可以无限制地插入新数据。\n\n但是，随着数据量的增多，storage 中每一个 index 对应的 bucket 数组（链表）就会越来越长，这就会造成哈希表效率的降低。\n\n\n什么情况下需要扩容？\n\n常见的情况是 loadFactor &gt; 0.75 的时候进行扩容。\n\n如何进行扩容？\n\n简单的扩容可以直接扩大两倍（关于质数，之后讨论）。\n扩容之后所有的数据项都要进行同步修改。\n\n实现思路：\n\n首先，定义一个变量，比如 oldStorage 指向原来的 storage。\n然后，创建一个新的容量更大的数组，让 this.storage 指向它。\n最后，将 oldStorage 中的每一个 bucket 中的每一个数据取出来依次添加到 this.storage 指向的新数组中。\n\n\nresize() 的实现装填因子 &#x3D; 哈希表中数据 &#x2F; 哈希表长度，即 loadFactor = count / HashTable.length。\nresize 方法，既可以实现哈希表的扩容，也可以实现哈希表容量的压缩。\n// 重新调整哈希表大小，扩容或压缩resize(newLimit) &#123;  // 1、保存旧的 storage 数组内容  const oldStorage = this.storage;  // 2、重置所有属性  this.storage = [];  this.count = 0;  this.limit = newLimit;  // 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage  for (const bucket of oldStorage) &#123;    if (bucket) &#123;      for (const b of bucket) &#123;        this.put(b[0], b[1]);      &#125;    &#125;  &#125;&#125;\n\n\n通常情况下当装填因子 laodFactor &gt; 0.75 时，对哈希表进行扩容。在哈希表中的添加方法（push 方法）中添加如下代码，判断是否需要调用扩容函数进行扩容。\n// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容if (this.count / this.limit &gt; this.loadFactor) &#123;  this.resize(this.getPrime(this.limit * 2));&#125;\n\n\n当装填因子 laodFactor &lt; 0.25 时，对哈希表容量进行压缩。在哈希表中的删除方法（remove 方法）中添加如下代码，判断是否需要调用扩容函数进行压缩。\n// 根据装填因子的大小，判断是否要进行哈希表压缩if (this.limit &gt; 7 &amp;&amp; this.count / this.limit &lt; this.minLoadFactor) &#123;  this.resize(this.getPrime(Math.floor(this.limit / 2)));&#125;\n\n选择质数作为哈希表容量质数判断\n1 不是质数\n\n\n方法一：针对质数的特点：只能被 1 和 number 整除，不能被 2 ~ (number-1) 整除。遍历 2 ~ (num-1) 。\n这种方法虽然能实现质数的判断，但是效率不高。\nfunction isPrime(number) &#123;  if (number &lt;= 1) return false;  for (let i = 2; i &lt; number; i++) &#123;    if (number % i === 0) &#123;      return false;    &#125;  &#125;  return true;&#125;\n\n\n方法二：只需要遍历 2 ~ num 的平方根即可。该方法性能较好。\n\nfunction isPrime(number) &#123;  if (number &lt;= 1 || number === 4) return false;  const temp = Math.ceil(Math.sqrt(number));  for (let i = 2; i &lt; temp; i++) &#123;    if (number % i === 0) &#123;      return false;    &#125;  &#125;  return true;&#125;\n\n实现扩容或压缩后的哈希表容量为质数实现思路：\n2 倍扩容或压缩之后，通过循环调用 isPrime 判断得到的容量是否为质数，不是则 +1，直到是为止。比如原长度：7，2 倍扩容后长度为 14，14 不是质数，14 + 1 = 15 不是质数，15 + 1 = 16 不是质数，16 + 1 = 17 是质数，停止循环，由此得到质数 17。\n\n第一步：首先需要为 HashTable 类添加判断质数的 isPrime 方法和获取质数的 getPrime 方法：\n// getPrime(number) 根据传入的 number 获取最临近的质数getPrime(number) &#123;  while (!isPrime(number)) &#123;    number++;  &#125;  return number;&#125;\n\n修改添加元素的 put 方法和删除元素的 remove 方法中关于数组扩容的相关操作：\n在 put 方法中添加如下代码：\n// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容if (this.count / this.limit &gt; this.loadFactor) &#123;  this.resize(this.getPrime(this.limit * 2));&#125;\n\n在 remove 方法中添加如下代码：\n// 根据装填因子的大小，判断是否要进行哈希表压缩if (this.limit &gt; 7 &amp;&amp; this.count / this.limit &lt; this.minLoadFactor) &#123;  this.resize(this.getPrime(Math.floor(this.limit / 2)));&#125;\n\n哈希表完整实现class HashTable &#123;  constructor() &#123;    this.storage = []; // 哈希表存储数据的变量    this.count = 0; // 当前存放的元素个数    this.limit = 7; // 哈希表长度（初始设为质数 7）    // 装填因子 (已有个数/总个数)    this.loadFactor = 0.75;    this.minLoadFactor = 0.25;  &#125;  // getPrime(number) 根据传入的 number 获取最临近的质数  getPrime(number) &#123;    while (!isPrime(number)) &#123;      number++;    &#125;    return number;  &#125;  // put(key, value) 往哈希表里添加数据  put(key, value) &#123;    // 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取）    const index = hashFn(key, this.limit);    // 2、根据 index 取出对应的 bucket    let bucket = this.storage[index];    // 3、判断是否存在 bucket    if (bucket === undefined) &#123;      bucket = []; // 不存在则创建      this.storage[index] = bucket;    &#125;    // 4、判断是插入数据操作还是修改数据操作    for (let i = 0; i &lt; bucket.length; i++) &#123;      let tuple = bucket[i]; // tuple 的格式：[key, value]      if (tuple[0] === key) &#123;        // 如果 key 相等，则修改数据        tuple[1] = value;        return; // 修改完 tuple 里数据，return 终止，不再往下执行。      &#125;    &#125;    // 5、bucket 新增数据    bucket.push([key, value]); // bucket 存储元组 tuple，格式为 [key, value]    this.count++;    // 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容    if (this.count / this.limit &gt; this.loadFactor) &#123;      this.resize(this.getPrime(this.limit * 2));    &#125;  &#125;  // 根据 get(key) 获取 value  get(key) &#123;    const index = hashFn(key, this.limit);    const bucket = this.storage[index];    if (bucket === undefined) &#123;      return null;    &#125;    for (const tuple of bucket) &#123;      if (tuple[0] === key) &#123;        return tuple[1];      &#125;    &#125;    return null;  &#125;  // remove(key) 删除指定 key 的数据  remove(key) &#123;    const index = hashFn(key, this.limit);    const bucket = this.storage[index];    if (bucket === undefined) &#123;      return null;    &#125;    // 遍历 bucket，找到对应位置的 tuple，将其删除    for (let i = 0, len = bucket.length; i &lt; len; i++) &#123;      const tuple = bucket[i];      if (tuple[0] === key) &#123;        bucket.splice(i, 1); // 删除对应位置的数组项        this.count--;        // 根据装填因子的大小，判断是否要进行哈希表压缩        if (this.limit &gt; 7 &amp;&amp; this.count / this.limit &lt; this.minLoadFactor) &#123;          this.resize(this.getPrime(Math.floor(this.limit / 2)));        &#125;        return tuple;      &#125;    &#125;  &#125;  isEmpty() &#123;    return this.count === 0;  &#125;  size() &#123;    return this.count;  &#125;  // 重新调整哈希表大小，扩容或压缩  resize(newLimit) &#123;    // 1、保存旧的 storage 数组内容    const oldStorage = this.storage;    // 2、重置所有属性    this.storage = [];    this.count = 0;    this.limit = newLimit;    // 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage    for (const bucket of oldStorage) &#123;      if (bucket) &#123;        for (const b of bucket) &#123;          this.put(b[0], b[1]);        &#125;      &#125;    &#125;  &#125;&#125;\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","哈希表"]},{"title":"JavaScript 数据结构与算法（四）队列","url":"/post/fd13eebac74d/","content":"认识队列队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)\n受限之处：\n\n只允许在表的前端（front）进行删除操作。\n只允许在表的后端（rear）进行插入操作。\n\n生活中类似队列结构的场景：\n\n排队，比如在电影院，商场，甚至是厕所排队。\n优先排队的人，优先处理。 (买票、结账、WC)。\n\n\n队列图解\n队列在程序中的应用\n打印队列：计算机打印多个文件的时候，需要排队打印。\n线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待 CPU 处理。\n\n队列的实现队列的实现和栈一样，有两种方案：\n\n基于数组实现。\n基于链表实现。\n\n队列常见的操作\nenqueue(element) 向队列尾部添加一个（或多个）新的项。\ndequeue() 移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。\nfront() 返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与 Map 类的 peek 方法非常类似）。\nisEmpty() 如果队列中不包含任何元素，返回 true，否则返回 false。\nsize() 返回队列包含的元素个数，与数组的 length 属性类似。\ntoString() 将队列中的内容，转成字符串形式。\n\n代码实现class Queue &#123;  constructor() &#123;    this.items = [];  &#125;  // enqueue(item) 入队，将元素加入到队列中  enqueue(item) &#123;    this.items.push(item);  &#125;  // dequeue() 出队，从队列中删除队头元素，返回删除的那个元素  dequeue() &#123;    return this.items.shift();  &#125;  // front() 查看队列的队头元素  front() &#123;    return this.items[0];  &#125;  // isEmpty() 查看队列是否为空  isEmpty() &#123;    return this.items.length === 0;  &#125;  // size() 查看队列中元素的个数  size() &#123;    return this.items.length;  &#125;  // toString() 将队列中的元素以字符串形式返回  toString() &#123;    let result = &quot;&quot;;    for (let item of this.items) &#123;      result += item + &quot; &quot;;    &#125;    return result;  &#125;&#125;\n\n测试代码const queue = new Queue();// enqueue() 测试queue.enqueue(&quot;a&quot;);queue.enqueue(&quot;b&quot;);queue.enqueue(&quot;c&quot;);queue.enqueue(&quot;d&quot;);console.log(queue.items); //--&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]// dequeue() 测试queue.dequeue();queue.dequeue();console.log(queue.items); //--&gt; [&quot;c&quot;, &quot;d&quot;]// front() 测试console.log(queue.front()); //--&gt; c// isEmpty() 测试console.log(queue.isEmpty()); //--&gt; false// size() 测试console.log(queue.size()); //--&gt; 2// toString() 测试console.log(queue.toString()); //--&gt; c d\n\n队列的应用使用队列实现小游戏：击鼓传花。\n分析：传入一组数据集合和设定的数字 number，循环遍历数组内元素，遍历到的元素为指定数字 number 时将该元素删除，直至数组剩下一个元素。\n代码实现// 利用队列结构的特点实现击鼓传花游戏求解方法的封装function passGame(nameList, number) &#123;  // 1、new 一个 Queue 对象  const queue = new Queue();  // 2、将 nameList 里面的每一个元素入队  for (const name of nameList) &#123;    queue.enqueue(name);  &#125;  // 3、开始数数  // 队列中只剩下 1 个元素时就停止数数  while (queue.size() &gt; 1) &#123;    // 不是 number 时，重新加入到队尾    // 是 number 时，将其删除    for (let i = 0; i &lt; number - 1; i++) &#123;      // number 数字之前的人重新放入到队尾（即把队头删除的元素，重新加入到队列中）      queue.enqueue(queue.dequeue());    &#125;    // number 对应这个人，直接从队列中删除    // 由于队列没有像数组一样的下标值不能直接取到某一元素，    // 所以采用，把 number 前面的 number - 1 个元素先删除后添加到队列末尾，    // 这样第 number 个元素就排到了队列的最前面，可以直接使用 dequeue 方法进行删除    queue.dequeue();  &#125;  // 4、获取最后剩下的那个人  const endName = queue.front();  // 5、返回这个人在原数组中对应的索引  return nameList.indexOf(endName);&#125;\n\n测试代码// passGame() 测试const names = [&quot;lily&quot;, &quot;lucy&quot;, &quot;tom&quot;, &quot;tony&quot;, &quot;jack&quot;];const targetIndex = passGame(names, 4);console.log(&quot;击鼓传花&quot;, names[targetIndex]); //--&gt; lily\n","categories":["数据结构与算法"],"tags":["JavaScript","数据结构","队列"]},{"title":"零基础入门 JavaScript 算法","url":"/post/efb94b4d08c6/","content":"前言提及算法，可能会有很多前端同学觉得这是一个距离自己日常工作较远的领域，认为算法并没有那么重要。事实上，这种看法是片面的，算法不仅仅是计算机科学中的一个重要概念，在前端开发中也有着广泛的应用和巨大的价值。\n一个精心设计的算法可以大幅度提高应用的性能和效率，例如：如何在大量数据中快速找到指定信息、如何高效地处理用户输入、如何在动画效果中保持流畅的用户体验、如何让页面加载更快、响应更灵敏等等场景，这些都依赖于对算法的理解和应用。掌握算法能够让我们在面对复杂问题时，具备更强的分析能力和解决策略。\n本文是一篇对前端同学相对友好的入门算法文章，提供一条易于理解的学习路径，从经典的排序、搜索等基础算法开始，逐步深入，再到一些高级算法设计思想，结合 LeetCode 真题实战案例分析，帮助你理解算法背后的实现逻辑，以及如何将其灵活应用于实际的前端开发场景中。\n学习算法，不仅能提高编程能力，对求职面试也有很大帮助，微软、字节跳动、腾讯等公司就特别喜欢问算法。\n排序简单来说，排序算法用于将一组乱序的元素按照升序或降序的顺序重新排列。其性能通常通过时间复杂度、空间复杂度、稳定性等指标来衡量。\nJavaScript 语言中的自带的排序：数组的 sort 方法。\n冒泡排序冒泡排序（Bubble Sort）是一种简单的比较排序算法。它重复地遍历待排序数组，每次比较相邻的两个元素，如果顺序相反则进行交换。这样，每一轮遍历都会将最大（或最小）的元素“冒泡”到顶端，直到整个数组都排序完成，最终达到完全有序。\n步骤：\n\n遍历数组：从头到尾遍历数组，比较相邻的两个元素。\n比较相邻元素：每次比较相邻的两个元素，如果它们的顺序不正确（比如，前一个元素大于后一个元素），则交换它们。\n重复遍历：重复上述步骤，直到没有任何一对元素需要交换，即数组已经完全排序。\n\n代码实现：\nfunction bubbleSort(array) &#123;    // 检查输入是否为数组且长度大于 1，若不满足条件，则直接返回原数组    if (!Array.isArray(array) || array.length &lt;= 1) return array    // 初始化最后一个未排序元素的索引    let lastIndex = array.length - 1    // 当还有未排序的元素时，执行排序过程    while (lastIndex &gt; 0) &#123;        // 初始化交换标志为 true，若本轮未发生交换，则排序完成        let flag = true        // 记录最后一次交换元素的位置，初始设置为未排序部分的末尾        const k = lastIndex        // 遍历未排序部分的元素        for (let j = 0; j &lt; k; j++) &#123;            // 若当前元素大于其后面的元素，则交换它们的位置            if (array[j] &gt; array[j + 1]) &#123;                flag = false // 发生了交换，将标志设置为 false                lastIndex = j // 记录最后一次交换的位置                ;[array[j], array[j + 1]] = [array[j + 1], array[j]] // 交换元素            &#125;        &#125;        // 若本轮未发生交换，则数组已经有序，直接退出循环        if (flag) break    &#125;    // 返回排序后的数组    return array&#125;// 测试console.log(bubbleSort([6,1,5,4,2,3])) // [1, 2, 3, 4, 5, 6]\n\n冒泡排序有几种可以优化的空间：\n\n优化遍历范围：在每一轮排序中，可以观察到最后一次交换发生的位置之后的元素已经是有序的，因此可以将下一轮排序的范围限定在上一轮最后一次交换的位置之前。这样可以减少不必要的比较和交换操作。\n添加标志位：如果在一轮排序过程中没有发生任何元素的交换，说明数组已经是有序的，可以提前结束排序过程。\n针对部分有序数组的优化：如果数组在初始状态下已经接近有序，可以记录下每轮排序中最后一次交换的位置，然后下一轮排序时只需要遍历到该位置即可，这样可以大大减少排序的比较次数。\n鸡尾酒排序（双向冒泡排序）：在一次排序过程中，既从左到右比较交换，又从右到左比较交换，可以在某些特定情况下提升效率。\n\n时间复杂度：\n\n最优时间复杂度：O(n)当输入数据已经是有序时，冒泡排序可以通过设置一个标志变量来检测是否发生了交换操作，如果在某一趟排序中没有交换操作发生，说明数组已经有序，因此可以提前结束排序过程。此时，最优时间复杂度为 O(n)。\n\n最坏时间复杂度：O(n^2)在最坏情况下，输入数据是逆序的，此时需要进行 n-1 趟排序，每一趟排序中需要进行的比较次数逐渐减少，总比较次数为 n(n-1)&#x2F;2，因此最坏时间复杂度为 O(n^2)。\n\n平均时间复杂度：O(n^2)在一般情况下，冒泡排序的比较和交换操作的次数与输入数据的初始排列状态有关，但总体而言其时间复杂度仍为 O(n^2)。\n\n\n空间复杂度：\n冒泡排序是一种原地排序算法，它在排序过程中只需要常数级的额外空间，即只使用了少量的辅助变量，因此其空间复杂度为 O(1)。\n稳定性：\n冒泡排序是一种稳定排序算法。在排序过程中，如果两个相等的元素相互比较，它们不会交换位置，因此相等元素的相对位置不会改变。\n冒泡排序由于其简单易懂的特性，常用于教学和小规模数据集的排序，但由于其较低的效率，通常不适合大规模数据集的排序任务。\n选择排序选择排序（Selection Sort）是一种简单的比较排序算法。它的基本思想是在未排序数组中找到最小（或最大）的元素，然后将其放置到数组的起始位置，接着在剩余的未排序部分中继续寻找最小（或最大）的元素，依次类推，直到所有元素都排序完成。\n步骤：\n\n初始状态： 将整个序列看作两部分，一部分是未排序的，一部分是已排序的（初始时已排序部分为空）。\n\n遍历未排序部分： 遍历未排序部分，找到最小（或最大）的元素。\n\n交换元素： 将找到的最小（或最大）元素与未排序部分的第一个元素交换位置，使得找到的最小元素成为已排序部分的最后一个元素。\n\n扩大已排序部分： 将已排序部分的长度增加 1，未排序部分的长度减少 1。\n\n重复： 重复以上步骤，直到所有元素都已经排序完毕。\n\n\n这个过程类似于每次从一堆未排序的卡片中选出最小（或最大）的卡片，然后放到已排序的卡片堆中。选择排序的特点是每次遍历都只进行一次交换操作，因此相对于其他排序算法，它的交换次数较少。\n代码实现：\nfunction selectionSort(array) &#123;    // 获取数组长度    const &#123; length &#125; = array    // 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序    if (!Array.isArray(array) || length &lt;= 1) return array    // 外层循环，遍历整个数组，每次找到当前未排序部分的最小元素并放到已排序部分的末尾    for (let i = 0; i &lt; length - 1; i++) &#123;        let minIndex = i // 设置当前循环最小元素索引        // 内层循环，从当前元素的下一个位置开始遍历，找到未排序部分的最小元素        for (let j = i + 1; j &lt; length; j++) &#123;            // 如果当前元素比最小元素索引小，则更新最小元素索引            if (array[minIndex] &gt; array[j]) &#123;                minIndex = j            &#125;        &#125;        // 交换最小元素到当前位置        swap(array, i, minIndex)    &#125;    return array&#125;// 交换数组中两个元素的位置function swap(array, left, right) &#123;    const temp = array[left]    array[left] = array[right]    array[right] = temp&#125;// 测试console.log(selectionSort([6, 1, 5, 4, 2, 3]))  // [1, 2, 3, 4, 5, 6]\n\n时间复杂度：\n\n最优时间复杂度：O(n^2)无论输入数据的初始排列状态如何，选择排序总是需要进行 n(n-1)&#x2F;2 次比较，因此最优时间复杂度为 O(n^2)。\n\n最坏时间复杂度：O(n^2)同样地，在最坏情况下，选择排序仍需要进行 n(n-1)&#x2F;2 次比较，所以最坏时间复杂度为 O(n^2)。\n\n平均时间复杂度：O(n^2)由于选择排序每一趟排序所需的比较次数固定，因此其平均时间复杂度也为 O(n^2)。\n\n\n空间复杂度：\n选择排序是一种原地排序算法，只需要常数级的辅助空间（通常是用于交换元素的临时变量），因此其空间复杂度为 O(1)。\n稳定性：\n选择排序通常不是稳定排序。在选择排序过程中，每次从未排序部分选择最小（或最大）元素并将其与未排序部分的第一个元素交换时，如果相等元素存在，原有的相对顺序可能会被打破。例如：\n\n初始数组：[3, 2, 2, 1]\n第一次选择：选择最小元素 1，与第一个元素 3 交换，结果：[1, 2, 2, 3]\n第二次选择：选择最小元素 2，与第二个元素 2 交换，结果：[1, 2, 2, 3]\n\n虽然这个例子没有改变相同元素的相对顺序，但在某些情况下，如处理：[2, 3, 1, 2]，第二个“2”会被提前，与第一个“2”交换，导致顺序改变。\n选择排序由于其简单性和恒定的空间复杂度，适用于对内存空间要求较高但对时间效率要求不高的场景。然而，由于其 O(n^2) 的时间复杂度，选择排序在处理大规模数据集时效率较低，通常不作为首选的排序算法。\n插入排序插入排序（Insertion Sort）是一种简单的比较排序算法。它的基本思想是将待排序数组分成已排序和未排序两部分，初始时已排序部分只有一个元素（即数组的第一个元素），然后从未排序部分依次取出元素，将其插入到已排序部分的正确位置，直到所有元素都被插入完成。\n\n插入排序类似扑克牌思想，想象在打扑克牌，拿起来第一张，放哪里无所谓，再拿起来一张，比第一张小，放左边，继续拿，可能是中间数，就插在中间，依次把牌拿完。\n\n步骤：\n\n初始已排序部分：初始时，将待排序数组的第一个元素视为已排序部分，其余元素视为未排序部分。\n遍历未排序部分：从第二个元素开始，依次遍历未排序部分的元素。\n插入到已排序部分：对于每个未排序部分的元素，将其与已排序部分的元素逐个比较，找到正确的插入位置。\n重复插入：将元素插入到已排序部分的正确位置后，已排序部分的长度增加 1，未排序部分的长度减少 1，继续重复上述步骤，直到所有元素都被插入完成。\n\n代码实现：\nfunction insertSort(array) &#123;    const &#123; length &#125; = array    // 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序    if (!Array.isArray(array) || length &lt;= 1) return array    // 循环从 1 开始，0 位置为默认的已排序的序列    for (let i = 1; i &lt; length; i++) &#123;        const temp = array[i] // 保存当前需要排序的元素        let j = i        // 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置        while (j - 1 &gt;= 0 &amp;&amp; array[j - 1] &gt; temp) &#123;            array[j] = array[j - 1]            j--        &#125;        // 将找到的位置插入元素        array[j] = temp    &#125;    return array&#125;insertSort([6,1,5,4,2,3]) // [1, 2, 3, 4, 5, 6]\n\n时间复杂度：\n\n最优时间复杂度：O(n)当输入数据已经有序时，插入排序每次只需要比较一次即可确定元素的位置，无需进行交换操作。此时，最优时间复杂度为 O(n)。\n\n最坏时间复杂度：O(n^2)在最坏情况下，输入数据是逆序的。此时，插入排序需要进行大量的比较和移动操作，每次插入元素时都需要将其与已经排序的部分进行比较并移动其他元素。因此最坏时间复杂度为 O(n^2)。\n\n平均时间复杂度：O(n^2)在一般情况下，插入排序的比较和移动操作次数与输入数据的初始排列状态有关，但总体而言，其平均时间复杂度为 O(n^2)。\n\n\n空间复杂度：\n插入排序是一种原地排序算法，它在排序过程中只需要常数级的额外空间（用于存储待插入的元素的临时变量），因此其空间复杂度为 O(1)。\n稳定性：\n插入排序是一种稳定排序算法。在插入过程中，如果待插入的元素与已排序部分的某个元素相等，插入排序会将待插入的元素放在相等元素的后面，从而保持相等元素的相对顺序不变。\n插入排序由于其简单性和对小规模数据集的高效性，常用于对小型数组进行排序或在其他更复杂的排序算法（如快速排序、归并排序）的过程中处理小数据块。然而，由于其 O(n^2) 的时间复杂度，插入排序在处理大规模数据集时效率较低。\n希尔排序希尔排序（Shell Sort）是一种改进的插入排序算法，也被称为“缩小增量排序”。它的基本思想是通过定义一个间隔序列（称为增量序列），将待排序数组分成若干个子序列，对每个子序列进行插入排序。随着排序的进行，增量序列逐渐缩小，直到增量为 1，最后对整个数组进行插入排序。\n步骤：\n\n选择增量序列：定义一个增量序列，确定每个增量值（间隔），通常以递减的方式选择。\n分组排序：将待排序数组根据当前增量值分成若干个子序列，对每个子序列进行插入排序。\n逐步缩小增量：重复上述步骤，逐步缩小增量值，直到增量为 1。\n最终排序：当增量为 1 时，对整个数组进行一次插入排序，完成排序过程。\n\n代码实现：\nfunction hillSort(array) &#123;  const &#123; length &#125; = array  // 如果输入不是数组或者数组长度小于等于 1，直接返回原数组，不需要排序  if (!Array.isArray(array) || length &lt;= 1) return array  // 第一层循环：确定增量的大小，每次增量的大小减半  for (let gap = parseInt(length &gt;&gt; 1); gap &gt;= 1; gap = parseInt(gap &gt;&gt; 1)) &#123;    // 对每个分组使用插入排序，相当于将插入排序的 1 换成了 gap    for (let i = gap; i &lt; length; i++) &#123;      const temp = array[i] // 保存当前元素      let j = i      // 第二层循环：对当前分组进行插入排序      // 如果 j - gap &gt;= 0 并且前一个元素大于当前元素，则进行交换      while (j - gap &gt;= 0 &amp;&amp; array[j - gap] &gt; temp) &#123;        array[j] = array[j - gap] // 将前一个元素后移        j -= gap // 继续比较下一个分组内的元素      &#125;      array[j] = temp // 插入元素到正确的位置    &#125;  &#125;  return array // 返回排序后的数组&#125;hillSort([6,1,5,4,2,3]) // [1, 2, 3, 4, 5, 6]\n\n时间复杂度：\n希尔排序的时间复杂度较为复杂，与所选的增量序列（gap sequence）有很大关系。常见的增量序列有希尔增量序列、Hibbard 增量序列、Sedgewick 增量序列等。以下是几种常见增量序列的时间复杂度分析：\n\n希尔增量序列（gap &#x3D; n&#x2F;2, n&#x2F;4, …, 1）：最坏时间复杂度：O(n^2)\n\nHibbard 增量序列（gap &#x3D; 2^k - 1）：最坏时间复杂度：O(n^(3&#x2F;2))\n\nSedgewick 增量序列（一种较为复杂的序列）：最坏时间复杂度：O(n^(4&#x2F;3))\n\n更优的增量序列：有些优化过的增量序列可以达到 O(n log^2 n) 的最坏时间复杂度。\n\n\n由于增量序列的选择对希尔排序的时间复杂度有很大的影响，所以具体的时间复杂度因实现而异，但通常在 O(n^2) 和 O(n log^2 n) 之间。\n空间复杂度：\n希尔排序是一种原地排序算法，其空间复杂度为 O(1)，只需要常数级的额外空间。\n稳定性：\n希尔排序不是稳定排序。在排序过程中，元素可能会跨越多个位置进行交换，因此相同元素的相对顺序可能会被打乱。\n希尔排序由于其高效性和相对简单的实现，在实际应用中有一定的优势，特别是在数据规模较大时。它通过对插入排序的改进，大大减少了数据移动的次数，从而提高了排序的效率。\n归并排序归并排序（Merge Sort）是一种基于分治法的高效排序算法。其基本思想是将数组分成更小的子数组，分别对这些子数组进行排序，然后再将它们合并起来，以得到一个有序的数组。\n步骤：\n\n分割（Divide）：将数组从中间分成两个子数组（递归地分割直到子数组的长度为 1）。\n排序（Conquer）：对每个子数组进行排序。因为子数组的长度为 1，所以它们是有序的。\n合并（Combine）：将两个有序的子数组合并成一个有序的数组。重复这个过程，直到所有的子数组被合并成一个完整的有序数组。\n\n代码实现：\nfunction mergeSort(array) &#123;  const &#123; length &#125; = array  // 如果不是数组或者数组长度小于等于 0，直接返回，不需要排序  if (!Array.isArray(array) || length &lt;= 1) return array  const mid = parseInt(length &gt;&gt; 1) // 找到中间索引值  const left = array.slice(0, mid) // 截取左半部分  const right = array.slice(mid, length) // 截取右半部分  return merge(mergeSort(left), mergeSort(right)) // 递归分解后，进行排序合并&#125;function merge(leftArray, rightArray) &#123;  const result = []  const leftLength = leftArray.length  const rightLength = rightArray.length  let il = 0  let ir = 0  // 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止  while (il &lt; leftLength &amp;&amp; ir &lt; rightLength) &#123;    if (leftArray[il] &lt; rightArray[ir]) &#123;      result.push(leftArray[il++])    &#125; else &#123;      result.push(rightArray[ir++])    &#125;  &#125;  // 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。  while (il &lt; leftLength) &#123;    result.push(leftArray[il++])  &#125;  // 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。  while (ir &lt; rightLength) &#123;    result.push(rightArray[ir++])  &#125;  return result&#125;mergeSort([6,1,5,4,2,3]) // [1, 2, 3, 4, 5, 6]\n\n基本过程：\n\n分割：将待排序数组分成两半。\n递归排序：对每一半分别进行递归排序。\n合并：合并两个有序子数组以形成一个有序的整体。\n\n时间复杂度：\n\n最优时间复杂度：O(n log n)\n最坏时间复杂度：O(n log n)\n平均时间复杂度：O(n log n)\n\n归并排序在最优、最坏和平均情况下的时间复杂度都是 O(n log n)，因为它始终将数组分成两半，然后对每一半进行排序，再合并结果。\n空间复杂度：\n归并排序的空间复杂度为 O(n)，这是因为归并排序在合并过程中需要一个额外的数组来暂存数据。对于递归实现，还需要考虑递归调用的栈空间，但总的额外空间仍然是 O(n)。\n稳定性：\n归并排序是一种稳定排序算法。在合并两个有序子数组的过程中，如果两个元素相等，先将前一个数组的元素放入结果数组中，从而保持相等元素的相对顺序不变。\n归并排序由于其稳定性和 O(n log n) 的时间复杂度，常用于处理大规模数据集，尤其是在需要稳定排序的情况下。虽然归并排序的空间复杂度较高，但其分治策略使其在许多应用中表现出色。\n快速排序快速排序（Quick Sort）是一种高效的排序算法，基于分治法。它通过选择一个”基准”（pivot）元素，并将数组分成两部分，其中一部分的所有元素都小于基准，另一部分的所有元素都大于基准。然后递归地对这两部分进行排序。\n步骤：\n\n选择基准：从数组中选择一个元素作为基准（pivot）。\n分区：重新排列数组，使得所有小于基准的元素在基准的左边，所有大于基准的元素在基准的右边（相等的元素可以放在任一侧）。此时基准元素处于其正确的位置。\n递归排序：递归地对基准左边的子数组和右边的子数组进行排序。\n\n代码实现：\nfunction quickSort(array) &#123;  // 如果不是数组或者数组长度小于等于 0，直接返回，不需要排序  if (!Array.isArray(array) || array.length &lt;= 1) return array  // 选择基准  const pivot = array[array.length - 1]  // 使用两个数组 left 和 right 来存储小于和大于基准的元素  const left = []  const right = []  // 分区过程  for (let i = 0; i &lt; array.length - 1; i++) &#123;    if (array[i] &lt; pivot) &#123;      left.push(array[i])    &#125; else &#123;      right.push(array[i])    &#125;  &#125;  // 递归地排序左右子数组并合并  return [...quickSort(left), pivot, ...quickSort(right)]&#125;quickSort([6, 1, 5, 4, 2, 3]) // [1, 2, 3, 4, 5, 6]\n\n时间复杂度：\n\n最优时间复杂度：O(n log n)当每次划分的子数组都比较均匀时，递归树的高度为 log n，每层的操作复杂度为 O(n)，所以最优时间复杂度为 O(n log n)。\n\n最坏时间复杂度：O(n^2)在最坏情况下，每次划分的子数组高度不均匀，例如每次选择的基准（pivot）是最大或最小元素，这会导致递归树退化为链表形式，时间复杂度为 O(n^2)。\n\n平均时间复杂度：O(n log n)在实际应用中，快速排序的平均性能通常很好，期望时间复杂度为 O(n log n)，因为随机选择基准或使用“三数取中”等方法可以有效避免最坏情况。\n\n\n空间复杂度：\n快速排序的空间复杂度主要取决于递归调用栈的深度：\n\n平均空间复杂度：O(log n)在理想情况下，递归调用栈的深度为 log n，因此空间复杂度为 O(log n)。\n\n最坏空间复杂度：O(n)在最坏情况下，递归调用栈的深度为 n，因此空间复杂度为 O(n)。\n\n\n稳定性：\n快速排序不是稳定排序。在排序过程中，元素的相对顺序可能会被改变，因为基准元素的交换可能会使得相等的元素顺序颠倒。\n快速排序因其高效性和较好的平均性能，广泛应用于各种排序任务。通过随机选择基准或“三数取中”等方法，可以有效地改善其性能，避免最坏情况的发生。\n堆排序堆排序（Heap Sort）是一种基于二叉堆数据结构的比较排序算法。堆排序可以分为两个阶段：构建初始堆和在堆上进行排序操作。\n步骤：\n\n构建最大堆：将无序数组构建成一个最大堆（max heap），最大堆是一个完全二叉树，其中每个节点的值都大于或等于其子节点的值。\n排序：交换堆顶元素（最大值）和堆的最后一个元素，并将堆的大小减少 1。然后对堆的根节点进行调整，使其重新成为最大堆。重复上述步骤，直到堆中剩余元素只剩一个，即完成排序。\n\nfunction heapSort(array) &#123;  // 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序  if (!Array.isArray(array) || array.length &lt;= 1) return array  const n = array.length  // 构建最大堆  for (let i = Math.floor(n / 2) - 1; i &gt;= 0; i--) &#123;    heapify(array, n, i)  &#125;  // 逐一从堆中取出元素，并对剩余元素重新堆化  for (let i = n - 1; i &gt; 0; i--) &#123;    // 将堆顶（最大值）和堆的最后一个元素交换    ;[array[0], array[i]] = [array[i], array[0]]    // 对堆的剩余部分重新堆化    heapify(array, i, 0)  &#125;  return array&#125;// 堆化函数，维护堆的性质function heapify(array, n, i) &#123;  let largest = i // 假设当前节点是最大值  const left = 2 * i + 1 // 左子节点  const right = 2 * i + 2 // 右子节点  // 如果左子节点大于当前节点，则更新最大值  if (left &lt; n &amp;&amp; array[left] &gt; array[largest]) &#123;    largest = left  &#125;  // 如果右子节点大于当前节点，则更新最大值  if (right &lt; n &amp;&amp; array[right] &gt; array[largest]) &#123;    largest = right  &#125;  // 如果最大值不是当前节点，则交换并继续堆化  if (largest !== i) &#123;    ;[array[i], array[largest]] = [array[largest], array[i]]    heapify(array, n, largest)  &#125;&#125;heapSort([6, 1, 5, 4, 2, 3]) // [1, 2, 3, 4, 5, 6]\n\n时间复杂度：\n\n最优时间复杂度：O(n log n)在最优情况下，堆排序的时间复杂度为 O(n log n)，因为构建最大堆和进行堆排序的时间复杂度都是 O(n log n)。\n\n最坏时间复杂度：O(n log n)在最坏情况下，堆排序的时间复杂度也是 O(n log n)。无论输入数据的顺序如何，都需要将数据构建成最大堆，然后进行排序。\n\n平均时间复杂度：O(n log n)\n\n\n空间复杂度：\n堆排序是一种原地排序算法，它只需要常数级别的额外空间来存储堆的数据结构，因此其空间复杂度为 O(1)。\n稳定性：\n堆排序不是稳定排序算法。在堆排序中，可能会破坏相同元素的相对顺序，因此它不是稳定的排序算法。\n堆排序由于其高效性和原地排序的特性，常用于需要稳定且较高性能的排序任务。虽然堆排序的实现相对复杂，但它的时间复杂度稳定在 O(n log n)，在实践中具有较好的性能表现。\n基数排序基数排序（Radix Sort）是一种非比较性的排序算法，它根据关键字的每个位的值来排序。基数排序适用于元素都是整数的数组，其中每个元素都有相同的位数或范围。基本思想是将待排序的元素按照位数进行分组，然后按照每一位的顺序依次排序。\n步骤：\n\n按照最低有效位进行排序：从最低位（个位）开始，将元素按照该位的值进行分组（例如 0 到 9），并按照顺序重新排列。\n\n依次对更高位进行排序：对每一位重复上述排序过程，直到按照最高位排序完成。\n\n合并分组：每次按照位数排序后，将所有分组合并为一个数组，形成新的待排序数组。\n\n重复步骤 1~3，直到所有位都被处理完毕。\n\n\n示例：\n假设我们有一个无序数组 [170, 45, 75, 90, 802, 24, 2, 66]，使用基数排序对其进行排序：\n\n按照个位进行排序：将数字按照个位的值进行分组：[170, 90, 802, 2], [24], [45, 75], [66]，并按照顺序重新排列：[170, 90, 802, 2, 24, 45, 75, 66]。\n\n按照十位进行排序：将数字按照十位的值进行分组：[802, 2], [24], [45, 66], [75], [170, 90]，并按照顺序重新排列：[802, 2, 24, 45, 66, 75, 170, 90]。\n\n按照百位进行排序（如果有的话）。\n\n排序完成，得到有序数组 [2, 24, 45, 66, 75, 90, 170, 802]。\n\n\n代码实现：\n// 获取数字的指定位数上的数字function getDigit(num, place) &#123;  return Math.floor(Math.abs(num) / 10 ** place) % 10&#125;// 获取数字的位数（最大位数）function digitCount(num) &#123;  if (num === 0) return 1  return Math.floor(Math.log10(Math.abs(num))) + 1&#125;// 获取数组中最大数字的位数function mostDigits(nums) &#123;  let maxDigits = 0  for (let i = 0; i &lt; nums.length; i++) &#123;    maxDigits = Math.max(maxDigits, digitCount(nums[i]))  &#125;  return maxDigits&#125;function radixSort(nums) &#123;  const maxDigitCount = mostDigits(nums)  for (let k = 0; k &lt; maxDigitCount; k++) &#123;    // 创建 10 个桶（0 到 9）    const digitBuckets = Array.from(&#123; length: 10 &#125;, () =&gt; [])    // 将数字放入相应的桶中    for (let i = 0; i &lt; nums.length; i++) &#123;      const digit = getDigit(nums[i], k)      digitBuckets[digit].push(nums[i])    &#125;    // 合并所有桶中的数字成为新的待排序数组    nums = [].concat(...digitBuckets)  &#125;  return nums&#125;radixSort([6, 1, 5, 4, 2, 3]) // [1, 2, 3, 4, 5, 6]\n\n时间复杂度：\n\n最优时间复杂度：O(n * k)最优情况下，每个关键字的位数相同，基数排序的时间复杂度为 O(n * k)，其中 n 是元素个数，k 是关键字的位数。\n\n最坏时间复杂度：O(n * k)最坏情况下，基数排序的时间复杂度仍然为 O(n * k)。\n\n平均时间复杂度：O(n * k)基数排序的平均时间复杂度也为 O(n * k)，其中 k 通常为常数。\n\n\n基数排序的时间复杂度主要取决于关键字的位数和元素个数，与元素的大小范围无关。\n空间复杂度：\n基数排序的空间复杂度取决于辅助存储空间的使用，通常需要一个额外的数组来存储中间结果。因此，其空间复杂度为 O(n + k)，其中 n 是元素个数，k 是关键字的范围（通常是 10）。\n稳定性：\n基数排序是一种稳定排序算法。在基数排序过程中，相同位数的元素根据其原始顺序进行排序，不会改变相等元素的相对位置，因此是稳定的。\n基数排序适用于处理整数或字符串等具有固定位数的元素集合。它的时间复杂度相对较低，并且是稳定排序算法，因此在一些特定的排序场景中具有一定的优势。\n计数排序计数排序（Counting Sort）是一种非比较性的排序算法，适用于待排序元素都属于一个有限范围的整数。计数排序的基本思想是通过统计待排序数组中每个元素出现的次数，然后根据统计信息将元素放置到正确的位置上。\n步骤：\n\n统计元素出现次数：遍历待排序数组，统计每个元素出现的次数，存储在一个辅助数组中。\n累加统计次数：对统计数组进行累加，使得每个位置存储的值表示小于等于该值的元素的个数。\n根据统计信息排序：遍历待排序数组，根据统计数组中的信息，将元素放置到正确的位置上。\n\n示例：\n假设我们有一个无序数组 [4, 2, 2, 8, 3, 3, 1]，使用计数排序对其进行排序：\n\n统计元素出现次数：统计数组中每个元素的出现次数：[1:1, 2:2, 3:2, 4:1, 8:1]。\n\n累加统计次数：将统计数组中的值进行累加：[1:1, 2:3, 3:5, 4:6, 8:7]，表示小于等于每个元素的个数。\n\n根据统计信息排序：根据累加统计次数，将待排序数组中的元素放置到正确的位置上，得到有序数组 [1, 2, 2, 3, 3, 4, 8]。\n\n\n代码实现：\nfunction countingSort(array) &#123;  // 找到待排序数组中的最大值和最小值  let min = array[0]  let max = array[0]  for (let i = 1; i &lt; array.length; i++) &#123;    if (array[i] &lt; min) min = array[i]    if (array[i] &gt; max) max = array[i]  &#125;  // 创建统计数组，长度为 max - min + 1  const countArray = new Array(max - min + 1).fill(0)  // 统计每个元素出现的次数  for (let i = 0; i &lt; array.length; i++) &#123;    countArray[array[i] - min]++  &#125;  // 根据统计信息对元素进行排序  let sortedIndex = 0  for (let i = 0; i &lt; countArray.length; i++) &#123;    while (countArray[i] &gt; 0) &#123;      array[sortedIndex] = i + min      sortedIndex++      countArray[i]--    &#125;  &#125;  return array&#125;countingSort([6, 1, 5, 4, 2, 3]) // [1, 2, 3, 4, 5, 6]\n\n时间复杂度：\n\n最优时间复杂度：O(n + k)最优情况下，计数排序的时间复杂度为 O(n + k)，其中 n 是元素个数，k 是元素的范围。\n\n最坏时间复杂度：O(n + k)最坏情况下，计数排序的时间复杂度仍然为 O(n + k)。\n\n平均时间复杂度：O(n + k)计数排序的平均时间复杂度也为 O(n + k)。\n\n\n计数排序的时间复杂度主要取决于元素的范围，而与元素的个数无关。\n空间复杂度：\n计数排序的空间复杂度取决于额外的计数数组和输出数组。因此，其空间复杂度为 O(n + k)，其中 n 是元素个数，k 是元素的范围。\n稳定性：\n计数排序是一种稳定排序算法。在计数排序中，相同元素的相对顺序不会改变，因此是稳定的。\n计数排序适用于对一定范围内的整数进行排序，并且适合于元素范围不是很大的情况下。由于其时间复杂度和空间复杂度均为线性，因此在一些特定的排序场景中具有较好的性能表现。\n搜索搜索算法简单来说就是用于找出数组中某个元素的下标。\nJavaScript 语言中的自带的搜索：数组的 indexOf 方法。\n顺序搜索顺序搜索（Sequential Search）算法是一种简单的搜索算法，它按顺序检查列表中的每个元素，直到找到目标元素或遍历完整个列表。\n代码实现：\nfunction sequentialSearch(array, target) &#123;    // 遍历数组中的每个元素    for (let i = 0; i &lt; array.length; i++) &#123;        // 如果当前元素等于目标元素，则返回当前元素的索引        if (array[i] === target) &#123;            return i        &#125;    &#125;    // 如果未找到目标元素，则返回 -1    return -1&#125;// 测试console.log(sequentialSearch([1, 2, 3, 4, 5], 0)) // -1console.log(sequentialSearch([1, 2, 3, 4, 5], 3)) // 2\n\n顺序搜索的时间复杂度为 O(n)，其中 n 是列表的长度。\n二分搜索二分搜索（Binary Search）是一种高效的搜索算法，适用于有序数组。该算法通过重复将搜索范围缩小为一半来找到目标值。\nfunction binarySearch(arr, target) &#123;  let low = 0 // 搜索范围的最低索引  let high = arr.length - 1 // 搜索范围的最高索引  while (low &lt;= high) &#123;    const mid = Math.floor((low + high) / 2) // 中间索引    if (arr[mid] === target) &#123;      return mid // 找到目标元素，返回索引    &#125;    if (arr[mid] &lt; target) &#123;      low = mid + 1 // 目标元素在右半部分，调整搜索范围的最低索引    &#125; else &#123;      high = mid - 1 // 目标元素在左半部分，调整搜索范围的最高索引    &#125;  &#125;  return -1 // 目标元素未找到&#125;// 测试console.log(binarySearch([1, 2, 3, 4, 5], 0)) // -1console.log(binarySearch([1, 2, 3, 4, 5], 3)) // 2\n\n二分搜索的时间复杂度为 O(log n)，其中 n 是数组的长度。\n算法设计思想分而治之分而治之（分治法）是一种常见的算法设计思想，其核心是将一个大问题分解成小的子问题，分别解决这些子问题，然后将子问题的解合并起来得到原问题的解。这种思想在很多算法中都有广泛的应用，特别是在解决递归问题时很常见。\n基本步骤\n分解（Divide）：将原问题划分成若干个规模较小的子问题。\n解决（Conquer）：递归地解决这些子问题，如果子问题规模足够小，则直接求解。\n合并（Combine）：将子问题的解合并成原问题的解。\n\n使用场景\n排序算法：如归并排序和快速排序。\n搜索算法：如二分搜索。\n数据压缩：如哈夫曼编码。\n分布式计算：如 MapReduce 等。\n\n分而治之的应用多数元素题目来源：LeetCode #169 简单\n给定一个大小为 n 的数组 nums，返回其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例 1：\n\n输入：nums &#x3D; [3, 2, 3]输出：3\n\n示例 2：\n\n输入：nums &#x3D; [2, 2, 1, 1, 1, 2, 2]输出：2\n\n提示：\n\nn == nums.length\n1 &lt;= n &lt;= 5 * 104\n-10^9 &lt;= nums[i] &lt;= 10^9\n\n解题步骤：\n\n分解：将数组分成左右两部分。\n解决子问题：递归地在左右两部分中分别找出多数元素。\n合并：\n如果左右部分的多数元素相同，则该元素即为整个数组的多数元素。\n如果左右部分的多数元素不同，则需要统计这两个元素在整个数组中的出现次数，出现次数较多的元素即为多数元素。\n\n\n\n代码实现：\nfunction majorityElement(nums) &#123;   // 辅助函数：统计元素在给定区间内的出现次数   function countInRange(nums, num, left, right) &#123;      let count = 0      for (let i = left; i &lt;= right; i++) &#123;         if (nums[i] === num) &#123;            count++         &#125;      &#125;      return count   &#125;   // 分治算法主函数   function majorityElementRec(nums, left, right) &#123;      // 基本情况：只有一个元素时      if (left === right) &#123;         return nums[left]      &#125;      // 将数组分成左右两部分      const mid = Math.floor((left + right) / 2)      const leftMajority = majorityElementRec(nums, left, mid)      const rightMajority = majorityElementRec(nums, mid + 1, right)      // 如果左右部分的多数元素相同，则返回该元素      if (leftMajority === rightMajority) &#123;         return leftMajority      &#125;      // 否则统计左右多数元素在整个区间内的出现次数      const leftCount = countInRange(nums, leftMajority, left, right)      const rightCount = countInRange(nums, rightMajority, left, right)      // 返回出现次数较多的元素      return leftCount &gt; rightCount ? leftMajority : rightMajority   &#125;   // 调用递归函数，从整个数组开始   return majorityElementRec(nums, 0, nums.length - 1)&#125;// 测试用例console.log(majorityElement([3, 2, 3])) // 输出：3console.log(majorityElement([2, 2, 1, 1, 1, 2, 2])) // 输出：2console.log(majorityElement([1])) // 输出：1console.log(majorityElement([1, 1, 2, 2, 2, 1, 1, 1])) // 输出：1\n\n\n时间复杂度：O(n log n)，每次递归将数组分为两部分，类似于归并排序，每层的合并操作需要线性时间，递归深度为 log n，因此总时间复杂度为 O(n log n)。\n\n空间复杂度：O(log n)，递归调用栈的深度为 log n，因此空间复杂度为 O(log n)（不包括输入和输出所占用的空间）。\n\n\n排序数组题目来源：LeetCode #912 中等\n给你一个整数数组 nums，请你将该数组升序排列。\n示例 1：\n\n输入：nums &#x3D; [5, 2, 3, 1]输出：[1, 2, 3, 5]\n\n示例 2：\n\n输入：nums &#x3D; [5, 1, 1, 2, 0, 0]输出：[0, 0, 1, 1, 2, 5]\n\n要将一个整数数组进行排序，我们可以使用分而治之的思想，这里我们选择归并排序作为实现方法，归并排序是一种稳定的排序算法。\n解题步骤：\n\n递归终止条件：当数组长度小于等于 1 时，返回数组本身，因为它已经是有序的。\n分解数组：找到数组的中点，将数组分成左右两部分。\n递归排序：递归地对左右两部分进行排序。\n合并：合并两个有序的子数组成一个有序的数组。\n\n代码实现：\nfunction sortArray(nums) &#123;   // 主函数，调用归并排序函数   return mergeSort(nums)&#125;function mergeSort(nums) &#123;   // 基本情况：如果数组长度小于等于 1，直接返回   if (nums.length &lt;= 1) &#123;      return nums   &#125;   // 计算中点   const mid = Math.floor(nums.length / 2)   // 分别对左右两部分进行排序   const left = mergeSort(nums.slice(0, mid))   const right = mergeSort(nums.slice(mid))   // 合并排序好的左右两部分   return merge(left, right)&#125;function merge(left, right) &#123;   const sortedArray = []   let i = 0   let j = 0   // 合并两个有序数组   while (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;      if (left[i] &lt; right[j]) &#123;         sortedArray.push(left[i])         i++      &#125; else &#123;         sortedArray.push(right[j])         j++      &#125;   &#125;   // 将剩余的元素添加到结果数组   while (i &lt; left.length) &#123;      sortedArray.push(left[i])      i++   &#125;   while (j &lt; right.length) &#123;      sortedArray.push(right[j])      j++   &#125;   return sortedArray&#125;// 示例测试console.log(sortArray([5, 2, 3, 1])) // 输出：[1, 2, 3, 5]console.log(sortArray([5, 1, 1, 2, 0, 0])) // 输出：[0, 0, 1, 1, 2, 5]\n\n\n时间复杂度：O(N log N)，因为数组每次都被分成两部分，并且每次合并操作的时间复杂度为 O(N)。\n空间复杂度：O(N)，因为归并排序需要额外的空间来存储合并后的数组。\n\n最大子数组和题目来源：LeetCode #53 中等\n给你一个整数数组 nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组是数组中的一个连续部分。\n示例 1：\n\n输入：nums &#x3D; [-2, 1, -3, 4, -1, 2, 1, -5, 4]输出：6解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6。\n\n示例 2：\n\n输入：nums &#x3D; [1]输出：1\n\n示例 3：\n\n输入：nums &#x3D; [5, 4, -1, 7, 8]输出：23\n\n解决最大子数组和问题，分而治之的思想是一种有效的方法。分而治之的基本思想是将问题分解成子问题，分别解决这些子问题，然后合并这些子问题的解来得到原问题的解。在这个问题中，我们将数组分成两个部分，然后递归地求解左右两部分的最大子数组和，并合并两部分的结果。\n解题步骤：\n\n递归终止条件：当数组长度为 1 时，返回数组的唯一元素。\n分解数组：找到数组的中点，将数组分成左右两部分。\n递归求解：递归地计算左半部分和右半部分的最大子数组和。\n合并：计算跨越中间的最大子数组和，包括：\n从中点向左扫描的最大子数组和。\n从中点向右扫描的最大子数组和。\n跨越中点的最大子数组和等于左半部分的最大和加上右半部分的最大和。\n\n\n\n代码实现：\nfunction maxSubArray(nums) &#123;    // 分治法求解最大子数组和    return divideAndConquer(nums, 0, nums.length - 1)&#125;function divideAndConquer(nums, left, right) &#123;    // 基本情况：如果只有一个元素，返回该元素    if (left === right) &#123;        return nums[left]    &#125;    // 计算中间点    const mid = Math.floor((left + right) / 2)    // 递归求解左半部分和右半部分的最大子数组和    const leftMax = divideAndConquer(nums, left, mid)    const rightMax = divideAndConquer(nums, mid + 1, right)    // 计算跨越中间点的最大子数组和    const crossMax = maxCrossingSubArray(nums, left, mid, right)    // 返回三个部分中最大的值    return Math.max(leftMax, rightMax, crossMax)&#125;function maxCrossingSubArray(nums, left, mid, right) &#123;    // 计算左半部分的最大子数组和    let leftSum = -Infinity    let sum = 0    for (let i = mid; i &gt;= left; i--) &#123;        sum += nums[i]        if (sum &gt; leftSum) &#123;            leftSum = sum        &#125;    &#125;    // 计算右半部分的最大子数组和    let rightSum = -Infinity    sum = 0    for (let i = mid + 1; i &lt;= right; i++) &#123;        sum += nums[i]        if (sum &gt; rightSum) &#123;            rightSum = sum        &#125;    &#125;    // 返回跨越中间点的最大子数组和    return leftSum + rightSum&#125;// 示例测试console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4])) // 输出：6console.log(maxSubArray([1])) // 输出：1console.log(maxSubArray([5, 4, -1, 7, 8])) // 输出：23\n\n\n时间复杂度：O(n log n)：每次分治将问题分成两个子问题，类似于归并排序，每次合并时需要线性的时间来计算跨越中间的最大子数组和。\n空间复杂度：O(log n)：递归调用的深度为 log n，因此空间复杂度为 O(log n)（不包括输入和输出所占用的空间）。\n\n数组中的第 K 个最大元素题目来源：LeetCode #215 中等\n给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\n请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\n示例 1:\n\n输入: [3, 2, 1, 5, 6, 4], k &#x3D; 2输出：5\n\n示例 2:\n\n输入: [3, 2, 3, 1, 2, 4, 5, 5, 6], k &#x3D; 4输出：4\n\n为了找到数组中的第 k 个最大元素，并且实现时间复杂度为 O(n) 的算法，我们可以使用快速选择算法（Quickselect）。快速选择算法是快速排序的变种，通过分而治之的方法来选择特定的第 k 个元素。\n解题步骤：\n\n选择一个主元（pivot）：通常选择数组的最后一个元素作为主元。\n分区：使用 Lomuto 分区方案，将数组重新排列，使得主元的位置是其最终位置，同时确保左边的元素都小于等于主元，右边的元素都大于主元。\n递归搜索：\n如果主元的位置正好是我们需要找的位置，直接返回主元。\n如果主元的位置大于目标位置，在左半部分继续搜索。\n如果主元的位置小于目标位置，在右半部分继续搜索。\n\n\n\n代码实现：\nfunction findKthLargest(nums, k) &#123;    // 目标是找到第 k 大的元素，即排序后第 (n-k) 小的元素    const targetIndex = nums.length - k;    return quickSelect(nums, 0, nums.length - 1, targetIndex);&#125;function quickSelect(nums, left, right, targetIndex) &#123;    if (left === right) &#123;        return nums[left];    &#125;    // 分区操作    const pivotIndex = partition(nums, left, right);    if (pivotIndex === targetIndex) &#123;        return nums[pivotIndex];    &#125; else if (pivotIndex &lt; targetIndex) &#123;        return quickSelect(nums, pivotIndex + 1, right, targetIndex);    &#125; else &#123;        return quickSelect(nums, left, pivotIndex - 1, targetIndex);    &#125;&#125;function partition(nums, left, right) &#123;    const pivot = nums[right];    let i = left;    for (let j = left; j &lt; right; j++) &#123;        if (nums[j] &lt;= pivot) &#123;            [nums[i], nums[j]] = [nums[j], nums[i]];            i++;        &#125;    &#125;    [nums[i], nums[right]] = [nums[right], nums[i]];    return i;&#125;// 示例测试console.log(findKthLargest([3, 2, 1, 5, 6, 4], 2)); // 输出：5console.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4)); // 输出：4\n\n\n时间复杂度：平均情况为 O(n)，因为每次分区都会将数组分成两部分。然而，在最坏情况下（例如数组已经有序时），时间复杂度可能达到 O(n^2)。\n空间复杂度：O(1)，因为快速选择是就地排序的算法，不需要额外的空间来存储数组。递归调用的栈空间为 O(log n)。\n\n动态规划动态规划是一种解决复杂问题的方法，通过将问题分解成更小的子问题，并利用子问题的重叠性，避免重复计算，从而提高效率。动态规划的核心思想是利用已计算的结果来构建解决方案，从而减少不必要的计算。\n基本步骤\n定义子问题：将原问题分解为若干子问题，确定这些子问题的状态和状态之间的转移关系。\n确定状态转移方程：根据子问题的定义，找出当前状态与之前状态的关系，即状态转移方程。\n初始化：确定初始状态的值。\n填表计算：利用状态转移方程，从初始状态出发，逐步计算每个子问题的值，通常使用一个表格（数组）来存储子问题的解。\n返回结果：根据问题的要求，从表格中提取最终的结果。\n\n使用场景动态规划主要用于解决以下几类问题：\n\n最优化问题：如最短路径、最大子序列和等问题。\n计数问题：如统计符合某些条件的方案数量。\n序列问题：如最长递增子序列、最长公共子序列等问题。\n划分问题：如背包问题、划分等问题。\n\n动态规划的应用爬楼梯题目来源：LeetCode #70 简单\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n示例 1：\n\n输入：n &#x3D; 2输出：2解释：有两种方法可以爬到楼顶。\n\n1 阶 + 1 阶\n2 阶\n\n\n示例 2：\n\n输入：n &#x3D; 3输出：3解释：有三种方法可以爬到楼顶。\n\n1 阶 + 1 阶 + 1 阶\n1 阶 + 2 阶\n2 阶 + 1 阶\n\n\n解题步骤：\n\n定义状态：定义一个数组 dp，其中 dp[i] 表示达到第 i 阶的方法总数。\n初始条件：知道 dp[0] = 1（到达第 0 阶的方法是站在原地）和 dp[1] = 1（到达第 1 阶的方法只有一种）。\n状态转移方程：为了到达第 i 阶，可以从第 i-1 阶迈一步或者从第 i-2 阶迈两步，所以 dp[i] = dp[i-1] + dp[i-2]。\n最终结果：dp[n] 表示达到第 n 阶的方法总数。\n\n代码实现：\nfunction climbStairs(n) &#123;   // 如果楼梯阶数为 0 或 1，直接返回 n   if (n &lt;= 1) return n   // 创建一个 dp 数组来存储每个台阶的方法数   const dp = new Array(n + 1).fill(0)   // 初始条件   dp[0] = 1   dp[1] = 1   // 计算每个台阶的方法数   for (let i = 2; i &lt;= n; i++) &#123;      dp[i] = dp[i - 1] + dp[i - 2]   &#125;   // 返回到达第 n 阶的方法总数   return dp[n]&#125;// 示例测试console.log(climbStairs(2)) // 输出：2console.log(climbStairs(3)) // 输出：3console.log(climbStairs(4)) // 输出：5console.log(climbStairs(5)) // 输出：8\n\n\n时间复杂度：O(n)，因为只需遍历一次数组。\n空间复杂度：O(n)，需要一个长度为 n+1 的数组来存储每一阶的方法数。\n\n最长递增子序列题目来源：LeetCode #300 中等\n给你一个整数数组 nums，找到其中最长严格递增子序列的长度。\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3, 6, 2, 7] 是数组 [0, 3, 1, 6, 2, 2, 7] 的子序列。\n示例 1：\n\n输入：nums &#x3D; [10, 9, 2, 5, 3, 7, 101, 18]输出：4解释：最长递增子序列是 [2, 3, 7, 101]，因此长度为 4。\n\n示例 2：\n\n输入：nums &#x3D; [0, 1, 0, 3, 2, 3]输出：4\n\n示例 3：\n\n输入：nums &#x3D; [7, 7, 7, 7, 7, 7, 7]输出：1\n\n解题步骤：\n\n定义状态：定义一个数组 dp，其中 dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度。\n初始化：每个位置的初始值为 1，因为每个位置都至少可以是一个长度为 1 的子序列。\n状态转移方程：对于每个 nums[i]，遍历其之前的元素 nums[j] (0 ≤ j &lt; i)，如果 nums[i] &gt; nums[j]，则更新 dp[i] = max(dp[i], dp[j] + 1)，表示在 nums[j] 的子序列上追加 nums[i]。\n最终结果：数组 dp 中的最大值即为最长递增子序列的长度。\n\n代码实现：\nfunction lengthOfLIS(nums) &#123;   if (nums.length === 0) return 0   // dp 数组，每个位置初始化为 1   const dp = new Array(nums.length).fill(1)   // 计算每个位置的最长递增子序列长度   for (let i = 1; i &lt; nums.length; i++) &#123;      for (let j = 0; j &lt; i; j++) &#123;         if (nums[i] &gt; nums[j]) &#123;            dp[i] = Math.max(dp[i], dp[j] + 1)         &#125;      &#125;   &#125;   // 返回 dp 数组中的最大值   return Math.max(...dp)&#125;// 示例测试console.log(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])) // 输出：4console.log(lengthOfLIS([0, 1, 0, 3, 2, 3])) // 输出：4console.log(lengthOfLIS([7, 7, 7, 7, 7, 7, 7])) // 输出：1\n\n\n时间复杂度：O(n^2)，因为我们需要嵌套循环遍历每个元素对。\n空间复杂度：O(n)，需要一个长度为 n 的数组来存储每个位置的最长子序列长度。\n\n打家劫舍题目来源：LeetCode #198 中等\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。\n示例 1：\n\n输入：[1, 2, 3, 1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4。\n\n示例 2：\n\n输入：[2, 7, 9, 3, 1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12。\n\n解题步骤：\n\n定义状态：定义一个数组 dp，其中 dp[i] 表示到达第 i 个房子时可以偷窃到的最高金额。\n初始条件：如果只有一个房子，那么可以偷窃的最高金额就是该房子的金额，即 dp[0] = nums[0]。如果有两个房子，则可以偷窃的最高金额是这两个房子中金额较大的那个，即 dp[1] = Math.max(nums[0], nums[1])。\n状态转移方程：对于每个房子 i，有两种选择：偷窃该房子（然后加上 i-2 房子的最高金额）或者不偷窃该房子（直接取 i-1 房子的最高金额）。状态转移方程为 dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])。\n最终结果：数组 dp 中的最后一个值即为可以偷窃到的最高金额。\n\n代码实现：\nfunction rob(nums) &#123;   const n = nums.length   if (n === 0) return 0   if (n === 1) return nums[0]   // dp 数组，每个位置初始化为 0   const dp = new Array(n).fill(0)   // 初始条件   dp[0] = nums[0]   dp[1] = Math.max(nums[0], nums[1])   // 填充 dp 数组   for (let i = 2; i &lt; n; i++) &#123;      dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])   &#125;   // 返回 dp 数组的最后一个值   return dp[n - 1]&#125;// 示例测试console.log(rob([1, 2, 3, 1])) // 输出：4console.log(rob([2, 7, 9, 3, 1])) // 输出：12\n\n\n时间复杂度：O(n)，因为需要遍历一次数组。\n空间复杂度：O(n)，因为需要一个长度为 n 的数组来存储每个位置的最高金额。\n\n优化空间复杂度：\n注意到我们在状态转移时，只需要前两个状态的值，所以可以将空间复杂度优化为 O(1)。\nfunction rob(nums) &#123;   const n = nums.length   if (n === 0) return 0   if (n === 1) return nums[0]   let prev1 = 0   let prev2 = 0   for (let i = 0; i &lt; n; i++) &#123;      const current = Math.max(prev1, prev2 + nums[i])      prev2 = prev1      prev1 = current   &#125;   return prev1&#125;// 示例测试console.log(rob([1, 2, 3, 1])) // 输出：4console.log(rob([2, 7, 9, 3, 1])) // 输出：12\n\n优化后的算法分析：\n\n时间复杂度：O(n)，因为需要遍历一次数组。\n空间复杂度：O(1)，因为只需要常量空间来存储前两个状态的值。\n\n通过上述方法，我们可以有效地计算出不触动警报装置的情况下，可以偷窃到的最高金额。优化后的代码在空间复杂度上更高效。\n零钱兑换题目来源：LeetCode #322 中等\n给你一个整数数组 coins，表示不同面额的硬币；以及一个整数 amount，表示总金额。\n计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n你可以认为每种硬币的数量是无限的。\n示例 1：\n\n输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11输出：3解释：11 &#x3D; 5 + 5 + 1\n\n示例 2：\n\n输入：coins &#x3D; [2], amount &#x3D; 3输出：-1\n\n示例 3：\n\n输入：coins &#x3D; [1], amount &#x3D; 0输出：0\n\n解题步骤：\n\n定义状态：定义一个数组 dp，其中 dp[i] 表示凑成金额 i 所需的最少硬币个数。\n初始化：dp[0] = 0，因为凑成金额 0 所需的硬币数是 0。其他 dp[i] 初始化为一个较大的值（如 Infinity），表示还没有计算出结果。\n状态转移方程：对于每个金额 i，尝试使用每种硬币 coin，更新 dp[i] = Math.min(dp[i], dp[i - coin] + 1)，表示从金额 i - coin 加上一个 coin 的硬币数量。\n最终结果：如果 dp[amount] 仍然是初始值 Infinity，则表示无法凑成该金额，返回 -1，否则返回 dp[amount]。\n\n代码实现：\nfunction coinChange(coins, amount) &#123;   // 创建一个 dp 数组，初始化为 Infinity   const dp = new Array(amount + 1).fill(Infinity)   dp[0] = 0 // 初始化金额为 0 时的最少硬币数为 0   // 填充 dp 数组   for (let i = 1; i &lt;= amount; i++) &#123;      for (const coin of coins) &#123;         if (i - coin &gt;= 0) &#123;            dp[i] = Math.min(dp[i], dp[i - coin] + 1)         &#125;      &#125;   &#125;   // 如果 dp[amount] 还是 Infinity，表示无法凑成该金额，返回 -1   return dp[amount] === Infinity ? -1 : dp[amount]&#125;// 示例测试console.log(coinChange([1, 2, 5], 11)) // 输出：3console.log(coinChange([2], 3)) // 输出：-1console.log(coinChange([1], 0)) // 输出：0console.log(coinChange([1, 3, 4, 5], 7)) // 输出：2 (3 + 4)console.log(coinChange([2, 5, 10, 1], 27)) // 输出：4 (10 + 10 + 5 + 2)\n\n\n时间复杂度：O(n * m)，其中 n 是金额 amount，m 是硬币种类数。\n空间复杂度：O(n)，需要一个长度为 amount + 1 的数组来存储每个金额的最少硬币数。\n\n贪心算法贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是全局最优的算法。贪心算法的核心是贪心选择性质，即每一步的局部最优选择最终能够导致全局最优解。\n基本步骤\n建立数学模型：将问题抽象为数学模型，明确所需的解和约束条件。\n选择贪心策略：根据问题的特性，选择一个贪心策略，即在每一步选择中，采取局部最优的选择。\n证明贪心选择的正确性：证明所选的贪心策略能够得到问题的最优解，通常通过数学归纳法或反证法证明。\n实施贪心算法：从初始状态开始，按照贪心策略逐步推进，直到达到问题的约束条件或无法继续推进为止。\n构造解：根据选择的步骤，构造出问题的解。\n\n使用场景贪心算法通常用于以下几类问题：\n\n最优化问题：如最小生成树、最短路径等问题。\n活动选择问题：如区间调度、任务安排等问题。\n资源分配问题：如背包问题的某些变种、最大子序列和等问题。\n图论问题：如 Dijkstra 算法求最短路径，Kruskal 算法和 Prim 算法求最小生成树。\n\n贪心算法的应用分发饼干题目来源：LeetCode #455 简单\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n示例 1:\n\n输入: g &#x3D; [1, 2, 3], s &#x3D; [1, 1]输出：1解释：你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1, 2, 3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。\n\n示例 2:\n\n输入: g &#x3D; [1, 2], s &#x3D; [1, 2, 3]输出：2解释：你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1, 2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2。\n\n先对孩子的满足度和饼干的大小排序，然后依次为每个孩子分配满足其满足度的最小饼干。\n解题步骤：\n\n排序：将孩子的胃口数组 g 和饼干尺寸数组 s 分别进行排序。\n匹配：使用两个指针，一个指向孩子的胃口数组，另一个指向饼干尺寸数组。依次尝试用当前最小的饼干去满足当前最小的胃口。\n更新指针：如果当前饼干可以满足当前孩子的胃口，两个指针都移动到下一个。如果不能，则只移动饼干的指针，尝试用下一个较大的饼干去满足当前孩子的胃口。\n结束条件：当两个指针都到达数组末尾时，匹配结束，返回满足孩子的数量。\n\n代码实现：\nfunction findContentChildren(g, s) &#123;   // 对孩子的胃口数组和饼干尺寸数组进行排序   g.sort((a, b) =&gt; a - b)   s.sort((a, b) =&gt; a - b)   let i = 0 // 孩子的指针   let j = 0 // 饼干的指针   let count = 0 // 满足的孩子数量   // 当孩子和饼干都没有处理完时进行匹配   while (i &lt; g.length &amp;&amp; j &lt; s.length) &#123;      if (s[j] &gt;= g[i]) &#123;         // 当前饼干可以满足当前孩子         count++         i++      &#125;      // 无论是否满足，都尝试下一个饼干      j++   &#125;   return count&#125;// 示例测试console.log(findContentChildren([1, 2, 3], [1, 1])) // 输出：1console.log(findContentChildren([1, 2], [1, 2, 3])) // 输出：2console.log(findContentChildren([1, 2, 3], [3])) // 输出：1console.log(findContentChildren([10, 9, 8, 7], [5, 6, 7, 8])) // 输出：2\n\n\n时间复杂度：O(n log n + m log m)，其中 n 是孩子数组的长度，m 是饼干数组的长度。这是因为排序需要 O(n log n) 和 O(m log m)。\n空间复杂度：O(1)，只需要常量级别的额外空间。\n\n柠檬水找零题目来源：LeetCode #860 简单\n在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品（按账单 bills 支付的顺序）一次购买一杯。\n每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。\n注意，一开始你手头没有任何零钱。\n给你一个整数数组 bills，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true，否则返回 false。\n示例 1：\n\n输入：bills &#x3D; [5, 5, 5, 10, 20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。\n\n示例 2：\n\n输入：bills &#x3D; [5, 5, 10, 10, 20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。\n\n遍历顾客给的钱，优先使用手中的大额钞票找零，从而保留小额钞票以应对后续的找零需求。\n解题步骤：\n\n初始化钱箱：使用两个变量 five 和 ten 来分别表示手中拥有的 5 美元和 10 美元的数量，初始值为 0。\n遍历账单：遍历顾客付的每一张账单。\n处理账单：\n如果顾客付的是 5 美元，直接收下。\n如果顾客付的是 10 美元，需要找零，检查是否有足够的 5 美元找零，如果有则找零，否则无法找零，返回 false。\n如果顾客付的是 20 美元，需要找零，优先使用 10 美元找零，然后再用 5 美元找零，如果都无法找零，则返回 false。\n\n\n返回结果：遍历结束后，如果能够给每个顾客正确找零，则返回 true，否则返回 false。\n\n代码实现：\nfunction lemonadeChange(bills) &#123;   let five = 0   let ten = 0   for (const bill of bills) &#123;      if (bill === 5) &#123;         // 顾客付 5 美元，直接收下         five++      &#125; else if (bill === 10) &#123;         // 顾客付 10 美元，尝试找零，优先使用 10 美元找零         if (five === 0) &#123;            return false // 无法找零，返回 false         &#125;         five--         ten++      &#125; else &#123;         // 顾客付 20 美元，尝试找零，优先使用 10 美元找零，再使用 5 美元找零         if (ten &gt; 0 &amp;&amp; five &gt; 0) &#123;            ten--            five--         &#125; else if (five &gt;= 3) &#123;            five -= 3         &#125; else &#123;            return false // 无法找零，返回 false         &#125;      &#125;   &#125;   return true&#125;// 示例测试console.log(lemonadeChange([5, 5, 5, 10, 20])) // 输出：trueconsole.log(lemonadeChange([5, 5, 10, 10, 20])) // 输出：false\n\n\n时间复杂度：O(n)，其中 n 是账单的数量，我们需要遍历一次账单数组。\n空间复杂度：O(1)，只需要常数级别的额外空间来存储 5 美元和 10 美元的数量。\n\n跳跃游戏题目来源：LeetCode #55 中等\n给你一个非负整数数组 nums，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断你是否能够到达最后一个下标，如果可以，返回 true；否则，返回 false。\n示例 1：\n\n输入：nums &#x3D; [2, 3, 1, 1, 4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n示例 2：\n\n输入：nums &#x3D; [3, 2, 1, 0, 4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0，所以永远不可能到达最后一个下标。\n\n从前往后遍历数组，维护当前能够到达的最远位置，如果在某一步能够到达或超过数组的最后一个位置，则返回 true。\n解题步骤：\n\n初始化：定义一个变量 maxReach，表示当前能够到达的最远位置，初始值为 0。\n遍历数组：从头到尾遍历数组的每个位置，检查当前位置是否能够到达。如果当前位置大于 maxReach，说明不能到达当前位置，返回 false。\n更新最远可达位置：如果当前位置在可达范围内，更新 maxReach 为 max(maxReach, i + nums[i])。\n检查是否可达：如果在遍历过程中，maxReach 大于或等于数组的最后一个下标，返回 true。\n\n代码实现：\nfunction canJump(nums) &#123;   let maxReach = 0   for (let i = 0; i &lt; nums.length; i++) &#123;      // 如果当前下标超过了能到达的最远位置      if (i &gt; maxReach) &#123;         return false      &#125;      // 更新能到达的最远位置      maxReach = Math.max(maxReach, i + nums[i])      // 如果能到达或超过最后一个下标      if (maxReach &gt;= nums.length - 1) &#123;         return true      &#125;   &#125;   return false&#125;// 示例测试console.log(canJump([2, 3, 1, 1, 4])) // 输出：trueconsole.log(canJump([3, 2, 1, 0, 4])) // 输出：falseconsole.log(canJump([0])) // 输出：true (只有一个元素，已经在最后一个下标)console.log(canJump([2, 0])) // 输出：true (可以直接到达最后一个下标)console.log(canJump([1, 2, 3, 4, 5])) // 输出：true (每步都能跳到最后)\n\n\ncanJump 函数：主函数，判断是否能够到达最后一个下标。\n**初始化 maxReach**：定义变量 maxReach 表示当前能够到达的最远位置，初始值为 0。\n遍历数组：\n对于每个位置 i，检查是否超过了 maxReach。如果是，返回 false，表示不能到达该位置。\n否则，更新 maxReach 为 max(maxReach, i + nums[i])，表示当前能够到达的最远位置。\n\n\n检查终止条件：如果 maxReach 已经大于或等于数组的最后一个下标，返回 true。\n返回结果：遍历结束后，如果没有返回 true，则返回 false。\n\n\n时间复杂度：O(n)，因为我们需要遍历一次数组。\n空间复杂度：O(1)，只需要常量级别的额外空间。\n\n无重叠区间题目来源：LeetCode #435 中等\n给定一个区间的集合 intervals，其中 intervals[i] = [starti, endi] 。返回需要移除区间的最小数量，使剩余区间互不重叠。\n示例 1:\n\n输入: intervals &#x3D; [[1, 2], [2, 3], [3, 4], [1, 3]]输出：1解释: 移除 [1, 3] 后，剩下的区间没有重叠。\n\n示例 2:\n\n输入: intervals &#x3D; [[1, 2], [1,2], [1,2]]输出：2解释: 你需要移除两个 [1, 2] 来使剩下的区间没有重叠。\n\n示例 3:\n\n输入: intervals &#x3D; [[1, 2], [2, 3]]输出：0解释：你不需要移除任何区间，因为它们已经是无重叠的了。\n\n先按照区间的结束时间排序，然后依次选择结束时间最早且不与前一个选择的区间重叠的区间。对于这个问题，我们要尽可能多地保留区间，从而使得需要移除的区间数量最小。\n解题步骤：\n\n排序：首先将区间按照结束时间 end 进行排序。这样可以保证每次选择的区间结束时间尽可能早，以便留出更多的空间给后面的区间。\n贪心选择：使用一个变量 end 来记录上一个选择的区间的结束时间。初始化 end 为负无穷大。\n遍历区间：依次遍历排序后的区间，如果当前区间的起始时间 start 大于等于 end，说明这个区间可以保留，同时更新 end 为当前区间的结束时间 end。否则，这个区间需要移除。\n统计结果：遍历结束后，计算需要移除的区间数量。\n\n代码实现：\nfunction eraseOverlapIntervals(intervals) &#123;   if (intervals.length === 0) return 0   // 按区间的结束时间进行排序   intervals.sort((a, b) =&gt; a[1] - b[1])   let count = 0   let end = -Infinity   for (const [start, finish] of intervals) &#123;      if (start &gt;= end) &#123;         // 当前区间可以保留，更新结束时间         end = finish      &#125; else &#123;         // 当前区间与上一个区间重叠，需要移除         count++      &#125;   &#125;   return count&#125;// 示例测试console.log(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]])) // 输出：1console.log(eraseOverlapIntervals([[1, 2], [1, 2], [1, 2]])) // 输出：2console.log(eraseOverlapIntervals([[1, 2], [2, 3]])) // 输出：0console.log(eraseOverlapIntervals([[1, 2], [1, 3], [2, 4], [3, 5]])) // 输出：1console.log(eraseOverlapIntervals([[0, 2], [1, 3], [2, 4], [3, 5], [4, 6]])) // 输出：2\n\neraseOverlapIntervals 函数：主函数，计算需要移除的区间数量。\n排序：将区间按照结束时间进行排序，使得每次选择的区间结束时间尽可能早。\n初始化变量：count 用于记录需要移除的区间数量，end 初始化为负无穷大。\n遍历区间：\n如果当前区间的起始时间 start 大于等于 end，说明这个区间可以保留，并更新 end 为当前区间的结束时间 finish。\n否则，这个区间与上一个区间重叠，需要移除，增加 count 计数器。\n\n\n返回结果：遍历结束后，返回需要移除的区间数量 count。\n\n\n时间复杂度：O(n log n)，因为我们需要对区间进行排序。\n空间复杂度：O(1)，不需要额外的空间，除了用于存储输入的区间列表。\n\n分发糖果题目来源：LeetCode #135 困难\nn 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。\n你需要按照以下要求，给这些孩子分发糖果：\n\n每个孩子至少分配到 1 个糖果。\n相邻两个孩子评分更高的孩子会获得更多的糖果。\n\n请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。\n示例 1：\n\n输入：ratings &#x3D; [1, 0, 2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。\n\n示例 2：\n\n输入：ratings &#x3D; [1, 2, 2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。\n\n先从左到右扫描数组，确保右边的评分更高的孩子获得更多糖果；再从右到左扫描数组，确保左边的评分更高的孩子获得更多糖果。\n解题步骤：\n\n初始化：创建一个数组 candies，初始化每个孩子的糖果数为 1，表示每个孩子至少有一个糖果。\n从左到右遍历：检查每个孩子与前一个孩子的评分，如果当前孩子的评分比前一个孩子高，则更新当前孩子的糖果数为 candies[i-1] + 1。\n从右到左遍历：检查每个孩子与后一个孩子的评分，如果当前孩子的评分比后一个孩子高且糖果数不大于后一个孩子，则更新当前孩子的糖果数为 candies[i+1] + 1。\n计算总糖果数：遍历 candies 数组，求和得到最少需要的糖果数。\n\n代码实现：\nfunction candy(ratings) &#123;   const n = ratings.length   const candies = new Array(n).fill(1)   // 从左到右遍历，保证右边孩子评分高的糖果更多   for (let i = 1; i &lt; n; i++) &#123;      if (ratings[i] &gt; ratings[i - 1]) &#123;         candies[i] = candies[i - 1] + 1      &#125;   &#125;   // 从右到左遍历，保证左边孩子评分高的糖果更多   for (let i = n - 2; i &gt;= 0; i--) &#123;      if (ratings[i] &gt; ratings[i + 1]) &#123;         candies[i] = Math.max(candies[i], candies[i + 1] + 1)      &#125;   &#125;   // 计算总糖果数   return candies.reduce((sum, candy) =&gt; sum + candy, 0)&#125;// 示例测试console.log(candy([1, 0, 2])) // 输出：5console.log(candy([1, 2, 2])) // 输出：4console.log(candy([1, 3, 2, 2, 1])) // 输出：7console.log(candy([1, 2, 3, 4, 5])) // 输出：15console.log(candy([5, 4, 3, 2, 1])) // 输出：15\n\n\ncandy 函数：主函数，计算最少需要的糖果数。\n初始化 candies 数组：每个孩子至少分配 1 个糖果。\n从左到右遍历：\n如果当前孩子的评分高于前一个孩子，则当前孩子的糖果数等于前一个孩子的糖果数加 1。\n\n\n从右到左遍历：\n如果当前孩子的评分高于后一个孩子且糖果数不大于后一个孩子，则更新当前孩子的糖果数为 candies[i + 1] + 1。\n\n\n计算总糖果数：通过遍历 candies 数组求和得到最少需要的糖果数。\n\n\n时间复杂度：O(n)，因为我们需要遍历两次数组，每次遍历的时间复杂度都是 O(n)。\n空间复杂度：O(n)，因为我们需要额外的数组 candies 来存储每个孩子的糖果数。\n\n回溯算法回溯算法是一种通过逐步构建解决方案的方法，当遇到某一步无法继续前进时，回溯算法会回退到上一步，尝试其他的选择，直到找到问题的解决方案或确定无解。回溯算法通常通过深度优先搜索的方式实现。\n基本步骤\n选择决策树：将问题抽象成一个决策树，每个节点代表一个决策点。\n深度优先搜索：从根节点开始，采用深度优先搜索的方式探索决策树的所有分支。\n做出选择：在每个节点处，根据问题的限制条件，做出一个选择。\n检查约束条件：检查当前选择是否满足问题的约束条件，如果满足则继续探索，否则回溯到上一步。\n标记路径：在探索过程中，记录已经探索过的路径，避免重复探索。\n撤销选择：在回溯时，撤销当前节点的选择，回到上一层继续探索其他分支。\n判断终止条件：当到达叶子节点或者无法继续探索时，判断是否找到了问题的解决方案。\n\n使用场景回溯算法通常用于以下几类问题：\n\n组合问题：如组合总和、组合总和 II 等问题。\n排列问题：如全排列、字符串的全排列等问题。\n搜索问题：如解数独、N 皇后问题等。\n子集问题：如子集、子集 II 等问题。\n\n回溯算法的应用全排列题目来源：LeetCode #46 中等\n给定一个不含重复数字的数组 nums，返回其所有可能的全排列。你可以按任意顺序返回答案。\n示例 1：\n\n输入：nums &#x3D; [1, 2, 3]输出：[[1, 2, 3], [1, 3, 2], [2, 1 ,3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n示例 2：\n\n输入：nums &#x3D; [0, 1]输出：[[0, 1], [1, 0]]\n\n示例 3：\n\n输入：nums &#x3D; [1]输出：[[1]]\n\n提示：\n\n1 &lt;= nums.length &lt;= 6\n-10 &lt;= nums[i] &lt;= 10\nnums 中的所有整数互不相同\n\n解题步骤：\n\n初始化结果集：创建一个结果数组 result 来存储所有的排列。\n回溯函数：定义一个回溯函数 backtrack，参数为当前路径 path 和剩余可选择的数字 choices。\n终止条件：当路径长度等于输入数组长度时，表明我们找到了一种排列，将其加入结果集。\n选择和探索：遍历剩余可选择的数字，将每个数字加入当前路径，并递归调用回溯函数，传递更新后的路径和剩余可选择的数字。\n回溯：在递归调用结束后，撤销上一步选择，进行下一轮选择和探索。\n\n代码实现：\nfunction permute(nums) &#123;   const result = []   function backtrack(path, choices) &#123;      if (path.length === nums.length) &#123;         result.push([...path])         return      &#125;      for (let i = 0; i &lt; choices.length; i++) &#123;         path.push(choices[i])         backtrack(path, choices.slice(0, i).concat(choices.slice(i + 1)))         path.pop()      &#125;   &#125;   backtrack([], nums)   return result&#125;// 示例测试console.log(permute([1, 2, 3])) // 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]console.log(permute([0, 1])) // 输出：[[0,1],[1,0]]console.log(permute([1])) // 输出：[[1]]\n\n\npermute 函数：主函数，接收输入数组 nums，返回所有的排列。\n初始化结果集：创建一个空数组 result 来存储所有的排列结果。\nbacktrack 函数：递归函数，构建排列。参数 path 表示当前路径，choices 表示当前剩余的可选择数字。\n终止条件：当路径长度等于输入数组长度时，将当前路径加入结果集。\n选择和探索：遍历剩余可选择的数字，将每个数字加入当前路径，递归调用 backtrack 函数，并传递更新后的路径和剩余可选择的数字。\n回溯：在递归调用结束后，撤销上一步选择，通过 path.pop() 将最后一个元素移除，进行下一轮选择和探索。\n\n\n时间复杂度：O(n * n!)，其中 n 是输入数组的长度。总共有 n! 种排列，每种排列需要 O(n) 的时间来构建。\n空间复杂度：O(n)，用于存储递归调用栈和临时路径。\n\n子集题目来源：LeetCode 78 中等\n给你一个整数数组 nums，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。\n解集不能包含重复的子集。你可以按任意顺序返回解集。\n示例 1：\n\n输入：nums &#x3D; [1, 2, 3]输出：[[], [1], [2], [1,2], [3], [1, 3], [2, 3], [1, 2, 3]]\n\n示例 2：\n\n输入：nums &#x3D; [0]输出：[[], [0]]\n\n提示：\n\n1 &lt;= nums.length &lt;= 10\n-10 &lt;= nums[i] &lt;= 10\nnums 中的所有元素互不相同\n\n解题步骤：\n\n初始化结果集：创建一个结果数组 result 来存储所有的子集。\n回溯函数：定义一个回溯函数 backtrack，参数为当前路径 path 和起始索引 start。\n添加当前路径到结果集：将当前路径 path 的拷贝加入结果集 result。\n选择和探索：从起始索引开始遍历 nums 数组，将每个数字加入当前路径，并递归调用回溯函数，传递更新后的路径和新的起始索引。\n回溯：在递归调用结束后，撤销上一步选择，进行下一轮选择和探索。\n\n代码实现：\nfunction subsets(nums) &#123;   const result = []   function backtrack(path, start) &#123;      // 将当前路径加入结果集      result.push([...path])      // 从当前索引开始遍历 nums 数组      for (let i = start; i &lt; nums.length; i++) &#123;         // 将当前数字加入路径         path.push(nums[i])         // 递归调用回溯函数，传递更新后的路径和新的起始索引         backtrack(path, i + 1)         // 回溯，撤销上一步选择         path.pop()      &#125;   &#125;   // 初始化回溯   backtrack([], 0)   return result&#125;// 示例测试console.log(subsets([1, 2, 3])) // 输出：[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]console.log(subsets([0])) // 输出：[[], [0]]\n\n\nsubsets 函数：主函数，接收输入数组 nums，返回所有的子集。\n初始化结果集：创建一个空数组 result 来存储所有的子集结果。\nbacktrack 函数：递归函数，构建子集。参数 path 表示当前路径，start 表示起始索引。\n添加当前路径到结果集：将当前路径 path 的拷贝加入结果集 result。\n选择和探索：从起始索引开始遍历 nums 数组，将每个数字加入当前路径 path，递归调用 backtrack 函数，并传递更新后的路径和新的起始索引 i + 1。\n回溯：在递归调用结束后，撤销上一步选择，通过 path.pop() 将最后一个元素移除，进行下一轮选择和探索。\n\n\n时间复杂度：O(n * 2^n)，其中 n 是输入数组的长度。总共有 2^n 个子集，每个子集的平均长度为 n&#x2F;2。\n空间复杂度：O(n)，用于存储递归调用栈和临时路径。\n\n单词拆分 II题目来源：LeetCode #140 困难\n给定一个字符串 s 和一个字符串字典 wordDict，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序返回所有这些可能的句子。\n注意：词典中的同一个单词可能在分段中被重复使用多次。\n示例 1：\n\n输入：s &#x3D; “catsanddog”, wordDict &#x3D; [“cat”, “cats”, “and”, “sand”, “dog”]输出：[“cats and dog”, “cat sand dog”]\n\n示例 2：\n\n输入：s &#x3D; “pineapplepenapple”, wordDict &#x3D; [“apple”, “pen”, “applepen”, “pine”, “pineapple”]输出：[“pine apple pen apple”, “pineapple pen apple”, “pine applepen apple”]解释：注意你可以重复使用字典中的单词。\n\n示例 3：\n\n输入：s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]输出：[]\n\n提示：\n\n1 &lt;= s.length &lt;= 20\n1 &lt;= wordDict.length &lt;= 1000\n1 &lt;= wordDict[i].length &lt;= 10\ns 和 wordDict[i] 仅有小写英文字母组成\nwordDict 中所有字符串都不同\n\n要解决这个问题，我们可以使用回溯算法结合动态规划进行优化。具体来说，我们需要递归地尝试在字符串 s 中插入空格来构成单词，同时使用缓存来存储已经计算过的结果，避免重复计算。\n解题步骤：\n\n定义缓存：使用一个对象 memo 来存储已经计算过的子问题的结果。\n定义回溯函数：递归函数 backtrack，参数为当前子字符串 s。\n递归终止条件：如果当前子字符串 s 在缓存中，直接返回缓存中的结果；如果 s 为空字符串，返回包含一个空字符串的数组。\n遍历匹配：遍历词典中的单词，如果当前子字符串 s 以该单词开头，则递归处理剩余部分的字符串，并将结果组合起来。\n更新缓存：将当前子字符串的结果存入缓存中，并返回该结果。\n\n代码实现：\nfunction wordBreak(s, wordDict) &#123;   const wordSet = new Set(wordDict)   const memo = &#123;&#125;   function backtrack(s) &#123;      // 如果当前子字符串已经在缓存中，直接返回缓存的结果      if (memo[s] !== undefined) &#123;         return memo[s]      &#125;      // 如果子字符串为空，返回包含一个空字符串的数组      if (s === &#x27;&#x27;) &#123;         return [&#x27;&#x27;]      &#125;      const result = []      // 遍历词典中的每个单词      for (const word of wordSet) &#123;         if (s.startsWith(word)) &#123;            const subResult = backtrack(s.slice(word.length))            for (const sub of subResult) &#123;               result.push(word + (sub === &#x27;&#x27; ? &#x27;&#x27; : &#x27; &#x27;) + sub)            &#125;         &#125;      &#125;      // 将当前子字符串的结果存入缓存      memo[s] = result      return result   &#125;   return backtrack(s)&#125;// 示例测试console.log(wordBreak(&#x27;catsanddog&#x27;, [&#x27;cat&#x27;, &#x27;cats&#x27;, &#x27;and&#x27;, &#x27;sand&#x27;, &#x27;dog&#x27;]))// 输出：[&quot;cats and dog&quot;, &quot;cat sand dog&quot;]console.log(wordBreak(&#x27;pineapplepenapple&#x27;, [&#x27;apple&#x27;, &#x27;pen&#x27;, &#x27;applepen&#x27;, &#x27;pine&#x27;, &#x27;pineapple&#x27;]))// 输出：[&quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot;]console.log(wordBreak(&#x27;catsandog&#x27;, [&#x27;cats&#x27;, &#x27;dog&#x27;, &#x27;sand&#x27;, &#x27;and&#x27;, &#x27;cat&#x27;]))// 输出：[]\n\n\nwordBreak 函数：主函数，接收字符串 s 和词典 wordDict，返回所有可能的句子。\n初始化：将词典转化为集合 wordSet，用于快速查找；定义缓存 memo。\nbacktrack 函数：递归函数，处理当前子字符串 s，返回其所有可能的句子组合。\n缓存查询：如果当前子字符串 s 在缓存中，直接返回缓存中的结果。\n递归终止条件：如果子字符串 s 为空，返回包含一个空字符串的数组。\n遍历词典：对于每个单词，如果当前子字符串 s 以该单词开头，则递归处理剩余部分的字符串 s.slice(word.length)。\n组合结果：将当前单词和递归结果组合成新的句子，并添加到结果集中。\n更新缓存：将当前子字符串 s 的结果存入缓存 memo，避免重复计算。\n返回结果：主函数调用 backtrack 函数，返回最终结果。\n\n\n时间复杂度：最坏情况下为 O(n^2 * k)，其中 n 是字符串 s 的长度，k 是词典 wordDict 的大小。每个子字符串的计算会涉及到对词典的遍历，并且需要组合结果。\n空间复杂度：O(n^2)，用于缓存子字符串的结果和存储递归栈。\n\n最后感谢大家看到最后，本文篇幅较长，难免会有错误，还望同学们多指正。看完本文后还没能理解透算法实现原理的同学，也不用灰心，掌握算法不是一朝半夕的事，勤加练习才能突破。\n另外，作者组建了氛围特别好的前端交流群 &amp; 自由程序猿交流群，欢迎同学们一起来交流吐槽。由于群人数较多，需要添加作者才能邀请进群。\n\n","categories":["数据结构与算法"],"tags":["JavaScript","算法"]},{"title":"Angular Material Dialog 拖拽功能的实现","url":"/post/b7e4e9336090/","content":"版本本例使用 Angular 7.x 版本，Material 7.x 版本。\n新建 Angular 指令新建指令命令：\nng generate directive dialog-draggable\n\n\n\n指令中拖拽功能代码实现：\nimport &#123; Directive, HostListener, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; MatDialogContainer, MatDialogRef &#125; from &#x27;@angular/material&#x27;;import &#123; Subscription, fromEvent &#125; from &#x27;rxjs&#x27;;import &#123; takeUntil &#125; from &#x27;rxjs/operators&#x27;;export interface Position &#123;  x: number;  y: number;&#125;@Directive(&#123;  selector: &#x27;[dialog-draggable]&#x27;&#125;)export class DialogDraggableDirective implements OnInit &#123;  private _subscription: Subscription;  mouseStart: Position;  mouseDelta: Position;  offset: Position;  constructor(    private matDialogRef: MatDialogRef&lt;any&gt;,    private container: MatDialogContainer  ) &#123;  &#125;  ngOnInit() &#123;    this.offset = this._getOffset();    this._updatePosition(this.offset.y, this.offset.x);  &#125;  @HostListener(&#x27;mousedown&#x27;, [&#x27;$event&#x27;])  onMouseDown(event: MouseEvent) &#123;    this.mouseStart = &#123; x: event.pageX, y: event.pageY &#125;;    const mouseup$ = fromEvent(document, &#x27;mouseup&#x27;);    this._subscription = mouseup$.subscribe(() =&gt; this.onMouseup());    const mousemove$ = fromEvent(document, &#x27;mousemove&#x27;)      .pipe(takeUntil(mouseup$))      .subscribe((e: MouseEvent) =&gt; this.onMouseMove(e));    this._subscription.add(mousemove$);  &#125;  onMouseMove(event: MouseEvent) &#123;    this.mouseDelta = &#123; x: (event.pageX - this.mouseStart.x), y: (event.pageY - this.mouseStart.y) &#125;;    this._updatePosition(this.offset.y + this.mouseDelta.y, this.offset.x + this.mouseDelta.x);  &#125;  onMouseup() &#123;    if (this._subscription) &#123;      this._subscription.unsubscribe();      this._subscription = undefined;    &#125;    if (this.mouseDelta) &#123;      this.offset.x += this.mouseDelta.x;      this.offset.y += this.mouseDelta.y;    &#125;  &#125;  private _updatePosition(top: number, left: number) &#123;    this.matDialogRef.updatePosition(&#123;      top: top + &#x27;px&#x27;,      left: left + &#x27;px&#x27;    &#125;);  &#125;  private _getOffset(): Position &#123;    const box = this.container[&#x27;_elementRef&#x27;].nativeElement.getBoundingClientRect();    return &#123;      x: box.left + pageXOffset,      y: box.top + pageYOffset    &#125;;  &#125;&#125;\n\n在全局的 CSS 样式文件添加 CSS：\n[dialog-draggable] &#123;  margin: -24px -24px 20px -24px !important;  padding: 10px 24px;  background: #283593 !important;  color: #fff;  cursor: move;&#125;\n\n如何使用在 Dialog 组件中使用 dialog-draggable 指令即可实现窗口拖拽，如下：\n&lt;h2 mat-dialog-title dialog-draggable&gt;  Angular Material Dialog Draggable&lt;/h2&gt;","categories":["Angular"],"tags":["Angular","Material"]},{"title":"CSS 实现元素水平和垂直居中的常用方法","url":"/post/054fed60fbea/","content":"Flexbox 布局\n父容器使用 Flexbox 布局实现子元素的水平和垂直居中。\n .container &#123;  display: flex;  align-items: center; /* 实现垂直居中 */  justify-content: center; /* 实现水平居中 */&#125;\n\n结合 Flexbox 和 margin: auto; 属性实现水平和垂直居中。\n .container &#123;    display: flex;&#125;.child &#123;    margin: auto; /* 同时实现水平和垂直居中 */&#125;\n\nGrid 布局父容器使用 Grid 布局实现子元素的水平和垂直居中。\n.container &#123;  display: grid;  place-items: center; /* 同时实现水平和垂直居中 */&#125;\n\nTable 属性使用 Table 属性实现水平和垂直居中。\n.container &#123;  width: 100px;  height: 100px;  display: table-cell;  vertical-align: middle; /* 实现垂直居中 */  text-align: center; /* 实现水平居中 */&#125;.child &#123;  width: 20px;  height: 20px;  display: inline-block;&#125;\n\n子绝父相子绝父相表示：子元素设置绝对定位，父容器设置相对定位。\n不知道子元素和父容器的高度使用 position 和 transform 属性可以同时实现水平和垂直居中。\n.container &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; /* 实现垂直居中 */ left: 50%; /* 实现水平居中 */ transform: translate(-50%, -50%);&#125;\n\n知道子元素和父容器的高度使用 position 和 margin 属性同时实现水平和垂直居中。\n.container &#123;   position: relative;   height: 100vh;&#125;.child &#123;   position: absolute;   top: 0;   bottom: 0;   left: 0;   right: 0;   margin: auto; /* 同时实现水平和垂直居中 */&#125;\n\nline-height如果子元素是单行文本，可以使用 line-height 来实现垂直居中。\n.container &#123;    height: 100px;    text-align: center; /* 实现水平居中 */    line-height: 100px; /* 实现垂直居中 */&#125;\n\n这个方法适用于只包含单行文本的元素。\n","categories":["前端"],"tags":["CSS"]},{"title":"JavaScript 的内存管理","url":"/post/a1ea44b079f7/","content":"像 C 语言这样的底层语言一般都有底层的内存管理接口，比如 malloc() 和 free()。相反，JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让 JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。\n内存生命周期不管什么程序语言，内存生命周期基本是一致的：\n\n分配你所需要的内存\n使用分配到的内存（读、写）\n不需要时将其释放\\归还\n\n所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像 JavaScript 这些高级语言中，大部分都是隐含的。\nJavaScript 的内存分配值的初始化为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。\nvar n = 123; // 给数值变量分配内存var s = &quot;azerty&quot;; // 给字符串分配内存var o = &#123;  a: 1,  b: null,&#125;; // 给对象及其包含的值分配内存// 给数组及其包含的值分配内存（就像对象一样）var a = [1, null, &quot;abra&quot;];function f(a) &#123;  return a + 2;&#125; // 给函数（可调用的对象）分配内存// 函数表达式也能分配一个对象someElement.addEventListener(  &quot;click&quot;,  function () &#123;    someElement.style.backgroundColor = &quot;blue&quot;;  &#125;,  false,);\n\n通过函数调用分配内存有些函数调用结果是分配对象内存：\nvar d = new Date(); // 分配一个 Date 对象var e = document.createElement(&quot;div&quot;); // 分配一个 DOM 元素\n\n有些方法分配新变量或者新对象：\nvar s = &quot;azerty&quot;;var s2 = s.substr(0, 3); // s2 是一个新的字符串// 因为字符串是不变量，// JavaScript 可能决定不分配内存，// 只是存储了 [0-3] 的范围。var a = [&quot;ouais ouais&quot;, &quot;nan nan&quot;];var a2 = [&quot;generation&quot;, &quot;nan nan&quot;];var a3 = a.concat(a2);// 新数组有四个元素，是 a 连接 a2 的结果\n\n使用值使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。\n当内存不再需要使用时释放大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“哪些被分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。\n高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。\n垃圾回收如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。\n引用垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。\n在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。\n引用计数垃圾收集这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。\n示例var o = &#123;  a: &#123;    b: 2,  &#125;,&#125;;// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2 变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有var oa = o2.a; // 引用“这个对象”的 a 属性// 现在，“这个对象”有两个引用了，一个是 o2，一个是 oao2 = &quot;yo&quot;; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了// 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收oa = null; // a 属性的那个对象现在也是零引用了// 它可以被垃圾回收了\n\n限制：循环引用该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。\nfunction f() &#123;  var o = &#123;&#125;;  var o2 = &#123;&#125;;  o.a = o2; // o 引用 o2  o2.a = o; // o2 引用 o  return &quot;azerty&quot;;&#125;f();\n\n实际例子IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏：\nvar div;window.onload = function () &#123;  div = document.getElementById(&quot;myDivElement&quot;);  div.circularReference = div;  div.lotsOfData = new Array(10000).join(&quot;*&quot;);&#125;;\n\n在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从 DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。\n标记 - 清除算法这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。\n这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。\n这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。\n从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记 - 清除算法的改进，并没有改进标记 - 清除算法本身和它对“对象是否不再需要”的简化定义。\n循环引用不再是问题了在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。\n限制：那些无法从根对象查询到的对象都将被清除尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。\n","categories":["前端"],"tags":["JavaScript"]},{"title":"JavaScript 的并发模型和事件循环","url":"/post/cbe58a2205e2/","content":"JavaScript 有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其他语言中的模型截然不同，比如 C 和 Java。\n运行时概念现代 JavaScript 引擎实现并着重优化了以下描述的这些语义。\n可视化描述\n栈函数调用形成了一个由若干帧组成的栈。\nfunction foo(b) &#123;  let a = 10;  return a + b + 11;&#125;function bar(x) &#123;  let y = 3;  return foo(x * y);&#125;console.log(bar(7)); // 返回 42\n\n当调用 bar 时，第一个帧被创建并压入栈中，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧被创建并被压入栈中，放在第一个帧之上，帧中包含 foo 的参数和局部变量。当 foo 执行完毕然后返回时，第二个帧就被弹出栈（剩下 bar 函数的调用帧）。当 bar 也执行完毕然后返回时，第一个帧也被弹出，栈就被清空了。\n堆对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。\n队列一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。\n在事件循环期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。\n事件循环之所以称之为事件循环，是因为它经常按照类似如下的方式来被实现：\nwhile (queue.waitForMessage()) &#123;  queue.processNextMessage();&#125;\n\nqueue.waitForMessage() 会同步地等待消息到达 (如果当前没有任何消息等待被处理)。\n“执行至完成”每一个消息完整地执行后，其他消息才会被执行。这为程序的分析提供了一些优秀的特性，包括：当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。这与 C 语言不同，例如，如果函数在线程中运行，它可能在任何位置被终止，然后在另一个线程中运行其他代码。\n这个模型的一个缺点在于当一个消息需要太长时间才能处理完毕时，Web 应用程序就无法处理与用户的交互，例如点击或滚动。为了缓解这个问题，浏览器一般会弹出一个“这个脚本运行时间过长”的对话框。一个良好的习惯是缩短单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。\n添加消息在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。\n函数 setTimeout 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其他消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其他消息，setTimeout 消息必须等待其他消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。\n下面的例子演示了这个概念（setTimeout 并不会在计时器到期之后直接执行）：\nconst s = new Date().getSeconds();setTimeout(function () &#123;  // 输出 &quot;2&quot;，表示回调函数并没有在 500 毫秒之后立即执行  console.log(&quot;Ran after &quot; + (new Date().getSeconds() - s) + &quot; seconds&quot;);&#125;, 500);while (true) &#123;  if (new Date().getSeconds() - s &gt;= 2) &#123;    console.log(&quot;Good, looped for 2 seconds&quot;);    break;  &#125;&#125;\n\n零延迟零延迟并不意味着回调会立即执行。以 0 为第二参数调用 setTimeout 并不表示在 0 毫秒后就立即调用回调函数。\n其等待的时间取决于队列里待处理的消息数量。在下面的例子中，&quot;这是一条消息&quot; 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。\n基本上，setTimeout 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。\n(function () &#123;  console.log(&quot;这是开始&quot;);  setTimeout(function cb() &#123;    console.log(&quot;这是来自第一个回调的消息&quot;);  &#125;);  console.log(&quot;这是一条消息&quot;);  setTimeout(function cb1() &#123;    console.log(&quot;这是来自第二个回调的消息&quot;);  &#125;, 0);  console.log(&quot;这是结束&quot;);&#125;)();// &quot;这是开始&quot;// &quot;这是一条消息&quot;// &quot;这是结束&quot;// &quot;这是来自第一个回调的消息&quot;// &quot;这是来自第二个回调的消息&quot;\n\n多个运行时互相通信一个 web worker 或者一个跨域的 iframe 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 postMessage 方法进行通信。如果另一个运行时侦听 message 事件，则此方法会向该运行时添加消息。\n永不阻塞JavaScript 的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。处理 I&#x2F;O 通常通过事件和回调来执行，所以当一个应用正等待一个 IndexedDB 查询返回或者一个 XHR 请求返回时，它仍然可以处理其他事情，比如用户输入。\n","categories":["前端"],"tags":["JavaScript"]},{"title":"Vue 项目动态修改 DOM 的 CSS 伪类","url":"/post/694f8d9b6034/","content":"在 Vue 项目中，如何动态修改某个 DOM 元素的 CSS 伪类的值？\n实现方法非常简单，其原理是使用 CSS3 的 var() 函数和 -- 变量。\n如下代码案例，动态修改 .demo 元素鼠标悬浮时的背景颜色：\n&lt;template&gt;  &lt;div class=&quot;demo&quot;       :style=&quot;&#123;         &#x27;--hover-background-color&#x27;: hoverBackgroundColor       &#125;&quot;  &gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        hoverBackgroundColor: &quot;#ccc&quot;,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;style&gt;  .demo:hover &#123;    background: var(--hover-background-color);  &#125;&lt;/style&gt;\n\n\ntemplate 中，绑定一个 CSS 变量 --hover-background-color。\n\nscript 中，定义一个 JS 变量 hoverBackgroundColor，用以动态控制背景颜色。\n\nstyle 中，background 的值用 var(--hover-background-color) 表示。\n\n\n","categories":["前端"],"tags":["CSS","Vue"]},{"title":"从 0 开始手把手带你搭建一套企业级 Vue3.x 工程化项目","url":"/post/04962924f0b8/","content":"Vue3 跟 Vite 正式版发布有很长一段时间了，生态圈也渐渐丰富起来，作者已在多个项目中使用，总结一下：就是快！也不用担心稳定性问题，开发体验真不是一般好！还没尝试的同学可以从本文开始学习，从 0 开始手把手带你搭建一套规范的 Vite + Vue3 + TypeScript 前端工程化项目环境。\n\n\n本文篇幅较长，从以下几个方面展开：\n\n架构搭建\n代码规范\n提交规范\n单元测试\n自动部署\n\n\n本项目完整的代码托管在 GitHub 仓库，欢迎点亮小星星 🌟🌟\n\n技术栈\n编程语言：TypeScript 4.x + JavaScript\n构建工具：Vite 2.x\n前端框架：Vue 3.x\n路由工具：Vue Router 4.x\n状态管理：Vuex 4.x\nUI 框架：Element Plus\nCSS 预编译：Stylus &#x2F; Sass &#x2F; Less\nHTTP 工具：Axios\nGit Hook 工具：husky + lint-staged\n代码规范：EditorConfig + Prettier + ESLint + Airbnb JavaScript Style Guide\n提交规范：Commitizen + Commitlint\n单元测试：vue-test-utils + jest + vue-jest + ts-jest\n自动部署：GitHub Actions\n\n架构搭建请确保你的电脑上成功安装 Node.js，本项目使用 Vite 构建工具，需要 Node.js 版本 &gt;&#x3D; 12.0.0。\n查看 Node.js 版本：\nnode -v\n\n建议将 Node.js 升级到最新的稳定版本：\n# 使用 nvm 安装最新稳定版 Node.jsnvm install stable\n\n使用 Vite 快速初始化项目雏形\n使用 NPM：\nnpm init @vitejs/app\n\n使用 Yarn：\nyarn create @vitejs/app\n\n然后按照终端提示完成以下操作：\n\n输入项目名称\n例如：本项目名称 vite-vue3-starter\n\n\n选择模板\n本项目需要使用 Vue3 + TypeScript，所以我们选择 vue-ts，会自动安装 Vue3 和 TypeScript。\n\n\n你还可以通过附加的命令行选项直接指定项目名和模板，本项目要构建 Vite + Vue3 + TypeScript 项目，则运行：\n# npm 6.xnpm init @vitejs/app vite-vue3-starter --template vue-ts# npm 7+（需要额外的双横线）npm init @vitejs/app vite-vue3-starter -- --template vue-ts# yarnyarn create @vitejs/app vite-vue3-starter --template vue-ts\n\n安装依赖\nnpm install\n\n启动项目\nnpm run dev\n\n\n如上图，表示 Vite + Vue3 + TypeScript 简单的项目骨架搭建完毕，下面我们来为这个项目集成 Vue Router、Vuex、Element Plus、Axios、Stylus&#x2F;Sass&#x2F;Less。\n\n\n修改 Vite 配置文件Vite 配置文件 vite.config.ts 位于根目录下，项目启动时会自动读取。\n本项目先做一些简单配置，例如：设置 @ 指向 src 目录、服务启动端口、打包路径、代理等。\n关于 Vite 更多配置项及用法，请查看 Vite 官网 https://vitejs.dev/config/ 。\nimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;// 如果编辑器提示 path 模块找不到，则可以安装一下 @types/node -&gt; npm i @types/node -Dimport &#123; resolve &#125; from &#x27;path&#x27;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [vue()],  resolve: &#123;    alias: &#123;      &#x27;@&#x27;: resolve(__dirname, &#x27;src&#x27;) // 设置 `@` 指向 `src` 目录    &#125;  &#125;,  base: &#x27;./&#x27;, // 设置打包路径  server: &#123;    port: 4000, // 设置服务启动端口号    open: true, // 设置服务启动时是否自动打开浏览器    cors: true // 允许跨域    // 设置代理，根据我们项目实际情况配置    // proxy: &#123;    //   &#x27;/api&#x27;: &#123;    //     target: &#x27;http://xxx.xxx.xxx.xxx:8000&#x27;,    //     changeOrigin: true,    //     secure: false,    //     rewrite: (path) =&gt; path.replace(&#x27;/api/&#x27;, &#x27;/&#x27;)    //   &#125;    // &#125;  &#125;&#125;)\n\n规范目录结构├── publish/└── src/    ├── assets/                    // 静态资源目录    ├── common/                    // 通用类库目录    ├── components/                // 公共组件目录    ├── router/                    // 路由配置目录    ├── store/                     // 状态管理目录    ├── style/                     // 通用 CSS 目录    ├── utils/                     // 工具函数目录    ├── views/                     // 页面组件目录    ├── App.vue    ├── main.ts    ├── shims-vue.d.ts├── tests/                         // 单元测试目录├── index.html├── tsconfig.json                  // TypeScript 配置文件├── vite.config.ts                 // Vite 配置文件└── package.json\n\n集成路由工具 Vue Router\n安装支持 Vue3 的路由工具 vue-router@4\nnpm i vue-router@4\n\n创建 src/router/index.ts 文件\n在 src 下创建 router 目录，然后在 router 目录里新建 index.ts 文件：\n└── src/    ├── router/        ├── index.ts  // 路由配置文件\n\nimport &#123;  createRouter,  createWebHashHistory,  RouteRecordRaw&#125; from &#x27;vue-router&#x27;import Home from &#x27;@/views/home.vue&#x27;import Vuex from &#x27;@/views/vuex.vue&#x27;const routes: Array&lt;RouteRecordRaw&gt; = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;Home&#x27;,    component: Home  &#125;,  &#123;    path: &#x27;/vuex&#x27;,    name: &#x27;Vuex&#x27;,    component: Vuex  &#125;,  &#123;    path: &#x27;/axios&#x27;,    name: &#x27;Axios&#x27;,    component: () =&gt; import(&#x27;@/views/axios.vue&#x27;) // 懒加载组件  &#125;]const router = createRouter(&#123;  history: createWebHashHistory(),  routes&#125;)export default router\n\n根据本项目路由配置的实际情况，你需要在 src 下创建 views 目录，用来存储页面组件。\n我们在 views 目录下创建 home.vue 、vuex.vue 、axios.vue。\n\n在 main.ts 文件中挂载路由配置\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router/index&#x27;createApp(App).use(router).mount(&#x27;#app&#x27;)\n\n集成状态管理工具 Vuex\n安装支持 Vue3 的状态管理工具 vuex@next\nnpm i vuex@next\n\n创建 src/store/index.ts 文件\n在 src 下创建 store 目录，然后在 store 目录里新建 index.ts 文件：\n└── src/    ├── store/        ├── index.ts  // store 配置文件\n\nimport &#123; createStore &#125; from &#x27;vuex&#x27;const defaultState = &#123;  count: 0&#125;// Create a new store instance.export default createStore(&#123;  state() &#123;    return defaultState  &#125;,  mutations: &#123;    increment(state: typeof defaultState) &#123;      state.count++    &#125;  &#125;,  actions: &#123;    increment(context) &#123;      context.commit(&#x27;increment&#x27;)    &#125;  &#125;,  getters: &#123;    double(state: typeof defaultState) &#123;      return 2 * state.count    &#125;  &#125;&#125;)\n\n在 main.ts 文件中挂载 Vuex 配置\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &#x27;./store/index&#x27;createApp(App).use(store).mount(&#x27;#app&#x27;)\n\n集成 UI 框架 Element Plus\n安装支持 Vue3 的 UI 框架 Element Plus\nnpm i element-plus\n\n在 main.ts 文件中挂载 Element Plus\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/lib/theme-chalk/index.css&#x27;createApp(App).use(ElementPlus).mount(&#x27;#app&#x27;)\n\n集成 HTTP 工具 Axios\n安装 Axios（Axios 跟 Vue 版本没有直接关系，安装最新即可）\nnpm i axios\n\n配置 Axios\n\n为了使项目的目录结构合理且规范，我们在 src 下创建 utils 目录来存储我们常用的工具函数。\n\nAxios 作为 HTTP 工具，我们在 utils 目录下创建 axios.ts 作为 Axios 配置文件：\n└── src/    ├── utils/        ├── axios.ts  // Axios 配置文件\n\nimport Axios from &#x27;axios&#x27;import &#123; ElMessage &#125; from &#x27;element-plus&#x27;const baseURL = &#x27;https://api.github.com&#x27;const axios = Axios.create(&#123;  baseURL,  timeout: 20000 // 请求超时 20s&#125;)// 前置拦截器（发起请求之前的拦截）axios.interceptors.request.use(  (response) =&gt; &#123;    /**     * 根据你的项目实际情况来对 config 做处理     * 这里对 config 不做任何处理，直接返回     */    return response  &#125;,  (error) =&gt; &#123;    return Promise.reject(error)  &#125;)// 后置拦截器（获取到响应时的拦截）axios.interceptors.response.use(  (response) =&gt; &#123;    /**     * 根据你的项目实际情况来对 response 和 error 做处理     * 这里对 response 和 error 不做任何处理，直接返回     */    return response  &#125;,  (error) =&gt; &#123;    if (error.response &amp;&amp; error.response.data) &#123;      const code = error.response.status      const msg = error.response.data.message      ElMessage.error(`Code: $&#123;code&#125;, Message: $&#123;msg&#125;`)      console.error(`[Axios Error]`, error.response)    &#125; else &#123;      ElMessage.error(`$&#123;error&#125;`)    &#125;    return Promise.reject(error)  &#125;)export default axios\n\n使用 Axios在需要使用 Axios 文件里，引入 Axios 配置文件，参考如下：\n&lt;template&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent &#125; from &#x27;vue&#x27;  import axios from &#x27;../utils/axios&#x27;  export default defineComponent(&#123;    setup() &#123;      axios        .get(&#x27;/users/XPoet&#x27;)        .then((res) =&gt; &#123;          console.log(&#x27;res: &#x27;, res)        &#125;)        .catch((err) =&gt; &#123;          console.log(&#x27;err: &#x27;, err)        &#125;)    &#125;  &#125;)&lt;/script&gt;\n\n集成 CSS 预编译器 Stylus&#x2F;Sass&#x2F;Less本项目使用 CSS 预编译器 Stylus，直接安装为开发依赖即可。Vite 内部已帮我们集成了相关的 loader，不需要额外配置。同理，你也可以使用 Sass 或 Less 等。\n\n安装\nnpm i stylus -D# ornpm i sass -Dnpm i less -D\n\n使用\n&lt;style lang=&quot;stylus&quot;&gt;  ...&lt;/style&gt;\n\n至此，一个基于 TypeScript + Vite + Vue3 + Vue Router + Vuex + Element Plus + Axios + Stylus&#x2F;Sass&#x2F;Less 的前端项目开发环境搭建完毕，项目 Demo 托管在 GitHub 仓库，需要的同学可以去下载下来，参考学习。\n下面我们来打磨这个项目，增加代码规范约束、提交规范约束、单元测试、自动部署等，让其更完善、更健壮。\n代码规范随着前端应用逐渐变得大型化和复杂化，在同一个项目中有多个人员参与时，每个人的前端能力程度不等，他们往往会用不同的编码风格和习惯在项目中写代码，长此下去，势必会让项目的健壮性越来越差。解决这些问题，理论上讲，口头约定和代码审查都可以，但是这种方式无法实时反馈，而且沟通成本过高，不够灵活，更关键的是无法把控。不以规矩，不能成方圆，我们不得不在项目使用一些工具来约束代码规范。\n本文讲解如何使用 EditorConfig + Prettier + ESLint 组合来实现代码规范化。\n这样做带来好处：\n\n解决团队之间代码不规范导致的可读性差和可维护性差的问题。\n解决团队成员不同编辑器导致的编码规范不统一问题。\n提前发现代码风格问题，给出对应规范提示，及时修复。\n减少代码审查过程中反反复复的修改过程，节约时间。\n自动格式化，统一编码风格，从此和脏乱差的代码说再见。\n\n集成 EditorConfig 配置EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。\n官网：http://editorconfig.org\n在项目根目录下增加 .editorconfig 文件：\n# Editor configuration, see http://editorconfig.org# 表示是最顶层的 EditorConfig 配置文件root = true[*] # 表示所有文件适用charset = utf-8 # 设置文件字符集为 utf-8indent_style = space # 缩进风格（tab | space）indent_size = 2 # 缩进大小end_of_line = lf # 控制换行类型(lf | cr | crlf)trim_trailing_whitespace = true # 去除行首的任意空白字符insert_final_newline = true # 始终在文件末尾插入一个新行[*.md] # 表示仅 md 文件适用以下规则max_line_length = offtrim_trailing_whitespace = false\n\n注意：\n\nVSCode 使用 EditorConfig 需要去插件市场下载插件 EditorConfig for VS Code 。\n\n\nJetBrains 系列（WebStorm、IntelliJ IDEA 等）则不用额外安装插件，可直接使用 EditorConfig 配置。\n\n\n集成 Prettier 配置Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。\n官网：https://prettier.io/\n\n安装 Prettier\nnpm i prettier -D\n\n创建 Prettier 配置文件\nPrettier 支持多种格式的配置文件，比如 .json、.yml、.yaml、.js等。\n在本项目根目录下创建 .prettierrc 文件。\n\n配置 .prettierrc\n在本项目中，我们进行如下简单配置，关于更多配置项信息，请前往官网查看 Prettier-Options 。\n&#123;  &quot;useTabs&quot;: false,  &quot;tabWidth&quot;: 2,  &quot;printWidth&quot;: 100,  &quot;singleQuote&quot;: true,  &quot;trailingComma&quot;: &quot;none&quot;,  &quot;bracketSpacing&quot;: true,  &quot;semi&quot;: false&#125;\n\nPrettier 安装且配置好之后，就能使用命令来格式化代码\n# 格式化所有文件（. 表示所有文件）npx prettier --write .\n\n注意：\n\nVSCode 编辑器使用 Prettier 配置需要下载插件 Prettier - Code formatter 。\n\n\nJetBrains 系列编辑器（WebStorm、IntelliJ IDEA 等）则不用额外安装插件，可直接使用 Prettier 配置。\n\n\nPrettier 配置好以后，在使用 VSCode 或 WebStorm 等编辑器的格式化功能时，编辑器就会按照 Prettier 配置文件的规则来进行格式化，避免了因为大家编辑器配置不一样而导致格式化后的代码风格不统一的问题。\n集成 ESLint 配置ESLint 是一款用于查找并报告代码中问题的工具，并且支持部分问题自动修复。其核心是通过对代码解析得到的 AST（Abstract Syntax Tree 抽象语法树）进行模式匹配，来分析代码达到检查代码质量和风格问题的能力。\n正如前面我们提到的因团队成员之间编程能力和编码习惯不同所造成的代码质量问题，我们使用 ESLint 来解决，一边写代码一边查找问题，如果发现错误，就给出规则提示，并且自动修复，长期下去，可以促使团队成员往同一种编码风格靠拢。\n\n安装 ESLint\n可以全局或者本地安装，作者推荐本地安装（只在当前项目中安装）。\nnpm i eslint -D\n\n配置 ESLint\nESLint 安装成功后，执行 npx eslint --init，然后按照终端操作提示完成一系列设置来创建配置文件。\n\nHow would you like to use ESLint? （你想如何使用 ESLint?）\n\n我们这里选择 To check syntax, find problems, and enforce code style（检查语法、发现问题并强制执行代码风格）\n\nWhat type of modules does your project use?（你的项目使用哪种类型的模块？）\n\n我们这里选择 JavaScript modules (import&#x2F;export)\n\nWhich framework does your project use? （你的项目使用哪种框架？）\n\n我们这里选择 Vue.js\n\nDoes your project use TypeScript?（你的项目是否使用 TypeScript？）\n\n我们这里选择 Yes\n\nWhere does your code run?（你的代码在哪里运行？）\n\n我们这里选择 Browser 和 Node（按空格键进行选择，选完按回车键确定）\n\nHow would you like to define a style for your project?（你想怎样为你的项目定义风格？）\n\n我们这里选择 Use a popular style guide（使用一种流行的风格指南）\n\nWhich style guide do you want to follow?（你想遵循哪一种风格指南？）\n\n我们这里选择 Airbnb: https://github.com/airbnb/javascript\nESLint 为我们列出了三种社区流行的 JavaScript 风格指南，分别是 Airbnb、Standard、Google。\n这三份风格指南都是由众多大佬根据多年开发经验编写，足够优秀，全球很多大小公司都在使用。我们选用 GitHub 上 star 最多的 Airbnb，免去繁琐的配置 ESLint 规则时间，然后让团队成员去学习 Airbnb JavaScript 风格指南即可。\n此时，我们在 ESLint 配置了 Airbnb JavaScript 规则，在编码时，所有不符合 Airbnb 风格的代码，编辑器都会给出提示，并且可以自动修复。\n这里作者不建议大家去自由配置 ESLint 规则，相信我，这三份 JavaScript 代码风格指南值得我们反复学习，掌握后，编程能力能上一大台阶。\n\nAirbnb JavaScript Style Guide\nAirbnb JavaScript 风格指南 - 中文版\n\n\nJavaScript Standard Style\nJavaScript Standard Style - 中文版\n\n\nGoogle JavaScript Style Guide\n\n\n\nWhat format do you want your config file to be in?（你希望你的配置文件是什么格式？）\n\n我们这里选择 JavaScript\n\nWould you like to install them now with npm?（你想现在就用 NPM 安装它们吗？）\n\n根据上面的选择，ESLint 会自动去查找缺失的依赖，我们这里选择 Yes，使用 NPM 下载安装这些依赖包。\n注意：如果自动安装依赖失败，那么需要手动安装\nnpm i @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint-config-airbnb-base eslint-plugin-import eslint-plugin-vue -D\n\n\nESLint 配置文件 .eslintrc.js\n在上一步操作完成后，会在项目根目录下自动生成 .eslintrc.js 配置文件：\nmodule.exports = &#123;  env: &#123;    browser: true,    es2021: true,    node: true  &#125;,  extends: [&#x27;plugin:vue/essential&#x27;, &#x27;airbnb-base&#x27;],  parserOptions: &#123;    ecmaVersion: 12,    parser: &#x27;@typescript-eslint/parser&#x27;,    sourceType: &#x27;module&#x27;  &#125;,  plugins: [&#x27;vue&#x27;, &#x27;@typescript-eslint&#x27;],  rules: &#123;&#125;&#125;\n\n根据项目实际情况，如果我们有额外的 ESLint 规则，也在此文件中追加。\n\n\n注意：\n\nVSCode 使用 ESLint 配置文件需要去插件市场下载插件 ESLint 。\n\n\nJetBrains 系列（WebStorm、IntelliJ IDEA 等）则不用额外安装插件。\n\n\n配置好以后，我们在 VSCode 或 WebStorm 等编辑器中开启 ESLin，写代码时，ESLint 就会按照我们配置的规则来进行实时代码检查，发现问题会给出对应错误提示和修复方案。\n如图：\n\nVSCode\n\nWebStorm\n\n\n虽然，现在编辑器已经给出错误提示和修复方案，但需要我们一个一个去点击修复，还是挺麻烦的。很简单，我们只需设置编辑器保存文件时自动执行 eslint --fix 命令进行代码风格修复。\n\nVSCode在 settings.json 设置文件中，增加以下代码：\n&quot;editor.codeActionsOnSave&quot;: &#123;   &quot;source.fixAll.eslint&quot;: true&#125;\n\nWebStorm打开设置窗口，按如下操作，最后点击 Apply -&gt; OK。\n\n\n解决 Prettier 和 ESLint 的冲突通常大家会在项目中根据实际情况添加一些额外的 ESLint 和 Prettier 配置规则，难免会存在规则冲突情况。\n本项目中的 ESLint 配置中使用了 Airbnb JavaScript 风格指南校验，其规则之一是代码结束后面要加分号，而我们在 Prettier 配置文件中加了代码结束后面不加分号的配置项，这样就有冲突了，会出现用 Prettier 格式化后的代码，ESLint 检测到格式有问题的，从而抛出错误提示。\n解决两者冲突问题，需要用到 eslint-plugin-prettier 和 eslint-config-prettier。\n\neslint-plugin-prettier 将 Prettier 的规则设置到 ESLint 的规则中。\n\neslint-config-prettier 关闭 ESLint 中与 Prettier 中会发生冲突的规则。\n\n\n最后形成优先级：Prettier 配置规则 &gt; ESLint 配置规则。\n\n安装插件\nnpm i eslint-plugin-prettier eslint-config-prettier -D\n\n在 .eslintrc.js 添加 prettier 插件\nmodule.exports = &#123;  ...  extends: [    &#x27;plugin:vue/essential&#x27;,    &#x27;airbnb-base&#x27;,    &#x27;plugin:prettier/recommended&#x27; // 添加 prettier 插件  ],  ...&#125;\n\n这样，我们在执行 eslint --fix 命令时，ESLint 就会按照 Prettier 的配置规则来格式化代码，轻松解决二者冲突问题。\n集成 husky 和 lint-staged我们在项目中已集成 ESLint 和 Prettier，在编码时，这些工具可以对我们写的代码进行实时校验，在一定程度上能有效规范我们写的代码，但团队可能会有些人觉得这些条条框框的限制很麻烦，选择视“提示”而不见，依旧按自己的一套风格来写代码，或者干脆禁用掉这些工具，开发完成就直接把代码提交到了仓库，日积月累，ESLint 也就形同虚设。\n所以，我们还需要做一些限制，让没通过 ESLint 检测和修复的代码禁止提交，从而保证仓库代码都是符合规范的。\n为了解决这个问题，我们需要用到 Git Hook，在本地执行 git commit 的时候，就对所提交的代码进行 ESLint 检测和修复（即执行 eslint --fix），如果这些代码没通过 ESLint 规则校验，则禁止提交。\n实现这一功能，我们借助 husky + lint-staged 。\n\nhusky —— Git Hook 工具，可以设置在 git 各个阶段（pre-commit、commit-msg、pre-push 等）触发我们的命令。lint-staged —— 在 git 暂存的文件上运行 linters。\n\n配置 husky\n自动配置（推荐）\n使用 husky-init 命令快速在项目初始化一个 husky 配置。\nnpx husky-init &amp;&amp; npm install\n\n这行命令做了四件事：\n\n安装 husky 到开发依赖\n\n在项目根目录下创建 .husky 目录\n\n在 .husky 目录创建 pre-commit hook，并初始化 pre-commit 命令为 npm test\n\n修改 package.json 的 scripts，增加 &quot;prepare&quot;: &quot;husky install&quot;\n\n\n\n手动配置（不推荐，懒是程序员第一生产力）\n\n安装 husky\nnpm i husky -D\n\n创建 Git hooks\nnpx husky install\n\n该命令做了两件事：\n\n在项目根目录下创建 .husky 目录\n\n在 .husky 目录创建 pre-commit hook，并初始化 pre-commit 命令为 npm test\n\n\n\n手动修改 package.json 的 scripts，增加 &quot;prepare&quot;: &quot;husky install&quot;\n\n\n\n\n\n特别注意：本项目使用 husky 6.x 版本，6.x 版本配置方式跟之前的版本有较大差异。目前网上大部分有关 husky 的教程都是 6 以前的版本，跟本文教程不太一样，当发现配置方法不一致时，一切以 husky 官网为准。\n\n到这里，husky 配置完毕，现在我们来使用它：\nhusky 包含很多 hook（钩子），常用有：pre-commit、commit-msg、pre-push。这里，我们使用 pre-commit 来触发 ESLint 命令。\n修改 .husky/pre-commit hook 文件的触发命令：\neslint --fix ./src --ext .vue,.js,.ts\n\n\n上面这个 pre-commit hook 文件的作用是：当我们执行 git commit -m &quot;xxx&quot; 时，会先对 src 目录下所有的 .vue、.js、.ts  文件执行 eslint --fix 命令，如果 ESLint 通过，成功 commit，否则终止 commit。\n但是又存在一个问题：有时候我们明明只改动了一两个文件，却要对所有的文件执行 eslint --fix。假如这是一个历史项目，我们在中途配置了 ESLint 规则，那么在提交代码时，也会对其他未修改的“历史”文件都进行检查，可能会造成大量文件出现 ESLint 错误，显然不是我们想要的结果。\n我们要做到只用 ESLint 修复自己此次写的代码，而不去影响其他的代码。所以我们还需借助一个神奇的工具 lint-staged 。\n配置 lint-stagedlint-staged 这个工具一般结合 husky 来使用，它可以让 husky 的 hook 触发的命令只作用于 git add那些文件（即 git 暂存区的文件），而不会影响到其他文件。\n接下来，我们使用 lint-staged 继续优化项目。\n\n安装 lint-staged\nnpm i lint-staged -D\n\n在 package.json里增加 lint-staged 配置项\n\n&quot;lint-staged&quot;: &#123;  &quot;*.&#123;vue,js,ts&#125;&quot;: &quot;eslint --fix&quot;&#125;,\n\n这行命令表示：只对 git 暂存区的 .vue、.js、.ts 文件执行 eslint --fix。\n\n修改 .husky/pre-commit hook 的触发命令为：npx lint-staged\n\n\n\n至此，husky 和 lint-staged 组合配置完成。\n现在我们提交代码时就会变成这样：\n假如我们修改了 scr 目录下的 test-1.js、test-2.ts 和 test-3.md 文件，然后 git add ./src/，最后 git commit -m &quot;test...&quot;，这时候就会只对 test-1.js、test-2.ts 这两个文件执行 eslint --fix。如果 ESLint 通过，成功提交，否则终止提交。从而保证了我们提交到 Git 仓库的代码都是规范的。\n\n\n提交前 test-1.js、test-2.ts\n\n提交后 test-1.js、test-2.ts 自动修复代码格式\n\n\n无论写代码还是做其他事情，都应该用长远的眼光来看，刚开始使用 ESint 的时候可能会有很多问题，改起来也很费时费力，只要坚持下去，代码质量和开发效率都会得到提升，前期的付出都是值得的。\n这些工具并不是必须的，没有它们你同样可以可以完成功能开发，但是利用好这些工具，你可以写出更高质量的代码。特别是一些刚刚接触的人，可能会觉得麻烦而放弃使用这些工具，失去了一次提升编程能力的好机会。\n\n本项目完整的代码托管在 GitHub 仓库，有需要的同学可以去下载下来，参考学习。点亮小星星 🌟 支持作者~\n\n提交规范前面我们已经统一代码规范，并且在提交代码时进行强约束来保证仓库代码质量。多人协作的项目中，在提交代码这个环节，也存在一种情况：不能保证每个人对提交信息的准确描述，因此会出现提交信息紊乱、风格不一致的情况。\n如果 git commit 的描述信息精准，在后期维护和 Bug 处理时会变得有据可查，项目开发周期内还可以根据规范的提交信息快速生成开发日志，从而方便我们追踪项目和把控进度。\n这里，我们使用社区最流行、最知名、最受认可的 Angular 团队提交规范。\n先看看 Angular 项目的提交记录：\n\n如上图，可以看出这些提交信息都是有固定格式的，下面我们来学习 Angular 规范的 commit message 格式。\ncommit message 格式规范commit message 由 Header、Body、Footer 组成。\n&lt;Header&gt;&lt;Body&gt;&lt;Footer&gt;\n\nHeaderHeader 部分包括三个字段 type（必需）、scope（可选）和 subject（必需）。\n&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\ntypetype 用于说明 commit 的提交类型（必须是以下几种之一）。\n\n\n\n值\n描述\n\n\n\nfeat\n新增一个功能\n\n\nfix\n修复一个 Bug\n\n\ndocs\n文档变更\n\n\nstyle\n代码格式（不影响功能，例如空格、分号等格式修正）\n\n\nrefactor\n代码重构\n\n\nperf\n改善性能\n\n\ntest\n测试\n\n\nbuild\n变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）\n\n\nci\n更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等\n\n\nchore\n变更构建流程或辅助工具\n\n\nrevert\n代码回退\n\n\nscopescope 用于指定本次 commit 影响的范围。scope 依据项目而定，例如在业务项目中可以依据菜单或者功能模块划分，如果是组件库开发，则可以依据组件划分。（scope 可省略）\nsubjectsubject 是本次 commit 的简洁描述，长度约定在 50 个字符以内，通常遵循以下几个规范：\n\n用动词开头，第一人称现在时表述，例如：change 代替 changed 或 changes\n第一个字母小写\n结尾不加句号（.）\n\nBodybody 是对本次 commit 的详细描述，可以分成多行。（body 可省略）\n跟 subject 类似，用动词开头，body 应该说明修改的原因和更改前后的行为对比。\nFooter如果本次提交的代码是突破性的变更或关闭缺陷，则 Footer 必需，否则可以省略。\n\n突破性的变更\n当前代码与上一个版本有突破性改变，则 Footer 以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动的理由。\n\n关闭缺陷\n如果当前提交是针对特定的 issue，那么可以在 Footer 部分填写需要关闭的单个 issue 或一系列 issues。\n\n\n参考例子\nfeat\nfeat(browser): onUrlChange event (popstate/hashchange/polling)Added new event to browser:- forward popstate event if available- forward hashchange event if popstate not available- do polling when neither popstate nor hashchange availableBreaks $browser.onHashChange, which was removed (use onUrlChange instead)\n\nfix\nfix(compile): couple of unit tests for IE9Older IEs serialize html uppercased, but IE9 does not...Would be better to expect case insensitive, unfortunately jasmine doesnot allow to user regexps for throw expectations.Closes #392Breaks foo.bar api, foo.baz should be used instead\n\nstyle\nstyle(location): add couple of missing semi colons\n\nchore\nchore(release): v3.4.2\n\n规范 commit message 的好处\n首行就是简洁实用的关键信息，方便在 git history 中快速浏览。\n具有更加详细的 body 和 footer，可以清晰的看出某次提交的目的和影响。\n可以通过 type 过滤出想要查找的信息，也可以通过关键字快速查找相关提交。\n可以直接从 commit 生成 change log。\n\n集成 Commitizen 实现规范提交上面介绍了 Angular 规范提交的格式，初次接触的同学咋一看可能会觉得复杂，其实不然，如果让大家在 git commit 的时候严格按照上面的格式来写，肯定是有压力的，首先得记住不同的类型到底是用来定义什么，subject 怎么写，body 怎么写，footer 要不要写等等问题，懒才是程序员第一生产力，为此我们使用 Commitizen 工具来帮助我们自动生成 commit message 格式，从而实现规范提交。\n\nCommitizen 是一个帮助撰写规范 commit message 的工具。它有一个命令行工具 cz-cli。\n\n安装 Commitizennpm install commitizen -D\n\n初始化项目成功安装 Commitizen 后，我们用 cz-conventional-changelog 适配器来初始化项目：\nnpx commitizen init cz-conventional-changelog --save-dev --save-exact\n\n这行命令做了两件事：\n\n安装 cz-conventional-changelog 到开发依赖（devDependencies）\n在 package.json 中增加了 config.commitizen&quot;config&quot;: &#123;  &quot;commitizen&quot;: &#123;    &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;  &#125;&#125;\n\n\n使用 Commitizen以前我们提交代码都是 git commit -m &quot;xxx&quot;，现在改为 git cz，然后按照终端操作提示，逐步填入信息，就能自动生成规范的 commit message。\n\n最后，在 Git 提交历史中就能看到刚刚规范的提交记录了：\n自定义配置提交说明从上面的截图可以看到，git cz 终端操作提示都是英文的，如果想改成中文的或者自定义这些配置选项，我们使用 cz-customizable 适配器。\ncz-customizable 初始化项目运行如下命令使用 cz-customizable 初始化项目，注意之前已经初始化过一次，这次再初始化，需要加 --force 覆盖。\nnpx commitizen init cz-customizable --save-dev --save-exact --force\n\n这行命令做了两件事：\n\n安装 cz-customizable 到开发依赖（devDependencies）\n&quot;devDependencies&quot;: &#123;  ...  &quot;cz-customizable&quot;: &quot;^6.3.0&quot;,  ...&#125;,\n\n修改 package.json 中的 config.commitizen 字段为：\n&quot;config&quot;: &#123;  &quot;commitizen&quot;: &#123;    &quot;path&quot;: &quot;./node_modules/cz-customizable&quot;  &#125;&#125;\n\n使用 cz-customizable在项目根目录下创建 .cz-config.js 文件，然后按照官方提供的示例来配置。\n在本项目中我们修改成中文：\nmodule.exports = &#123;  // type 类型（定义之后，可通过上下键选择）  types: [    &#123; value: &#x27;feat&#x27;, name: &#x27;feat:     新增功能&#x27; &#125;,    &#123; value: &#x27;fix&#x27;, name: &#x27;fix:      修复 bug&#x27; &#125;,    &#123; value: &#x27;docs&#x27;, name: &#x27;docs:     文档变更&#x27; &#125;,    &#123; value: &#x27;style&#x27;, name: &#x27;style:    代码格式（不影响功能，例如空格、分号等格式修正）&#x27; &#125;,    &#123; value: &#x27;refactor&#x27;, name: &#x27;refactor: 代码重构（不包括 bug 修复、功能新增）&#x27; &#125;,    &#123; value: &#x27;perf&#x27;, name: &#x27;perf:     性能优化&#x27; &#125;,    &#123; value: &#x27;test&#x27;, name: &#x27;test:     添加、修改测试用例&#x27; &#125;,    &#123; value: &#x27;build&#x27;, name: &#x27;build:    构建流程、外部依赖变更（如升级 npm 包、修改 webpack 配置等）&#x27; &#125;,    &#123; value: &#x27;ci&#x27;, name: &#x27;ci:       修改 CI 配置、脚本&#x27; &#125;,    &#123; value: &#x27;chore&#x27;, name: &#x27;chore:    对构建过程或辅助工具和库的更改（不影响源文件、测试用例）&#x27; &#125;,    &#123; value: &#x27;revert&#x27;, name: &#x27;revert:   回滚 commit&#x27; &#125;  ],  // scope 类型（定义之后，可通过上下键选择）  scopes: [    [&#x27;components&#x27;, &#x27;组件相关&#x27;],    [&#x27;hooks&#x27;, &#x27;hook 相关&#x27;],    [&#x27;utils&#x27;, &#x27;utils 相关&#x27;],    [&#x27;element-ui&#x27;, &#x27;对 element-ui 的调整&#x27;],    [&#x27;styles&#x27;, &#x27;样式相关&#x27;],    [&#x27;deps&#x27;, &#x27;项目依赖&#x27;],    [&#x27;auth&#x27;, &#x27;对 auth 修改&#x27;],    [&#x27;other&#x27;, &#x27;其他修改&#x27;],    // 如果选择 custom，后面会让你再输入一个自定义的 scope。也可以不设置此项，把后面的 allowCustomScopes 设置为 true    [&#x27;custom&#x27;, &#x27;以上都不是？我要自定义&#x27;]  ].map(([value, description]) =&gt; &#123;    return &#123;      value,      name: `$&#123;value.padEnd(30)&#125; ($&#123;description&#125;)`    &#125;  &#125;),  // 是否允许自定义填写 scope，在 scope 选择的时候，会有 empty 和 custom 可以选择。  // allowCustomScopes: true,  // allowTicketNumber: false,  // isTicketNumberRequired: false,  // ticketNumberPrefix: &#x27;TICKET-&#x27;,  // ticketNumberRegExp: &#x27;\\\\d&#123;1,5&#125;&#x27;,  // 针对每一个 type 去定义对应的 scopes，例如 fix  /*  scopeOverrides: &#123;    fix: [      &#123; name: &#x27;merge&#x27; &#125;,      &#123; name: &#x27;style&#x27; &#125;,      &#123; name: &#x27;e2eTest&#x27; &#125;,      &#123; name: &#x27;unitTest&#x27; &#125;    ]  &#125;,  */  // 交互提示信息  messages: &#123;    type: &#x27;确保本次提交遵循 Angular 规范！\\n选择你要提交的类型：&#x27;,    scope: &#x27;\\n选择一个 scope（可选）：&#x27;,    // 选择 scope: custom 时会出下面的提示    customScope: &#x27;请输入自定义的 scope：&#x27;,    subject: &#x27;填写简短精炼的变更描述：\\n&#x27;,    body:      &#x27;填写更加详细的变更描述（可选）。使用 &quot;|&quot; 换行：\\n&#x27;,    breaking: &#x27;列举非兼容性重大的变更（可选）：\\n&#x27;,    footer: &#x27;列举出所有变更的 ISSUES CLOSED（可选）。例如：#31, #34：\\n&#x27;,    confirmCommit: &#x27;确认提交？&#x27;  &#125;,  // 设置只有 type 选择了 feat 或 fix，才询问 breaking message  allowBreakingChanges: [&#x27;feat&#x27;, &#x27;fix&#x27;],  // 跳过要询问的步骤  // skipQuestions: [&#x27;body&#x27;, &#x27;footer&#x27;],  // subject 限制长度  subjectLimit: 100  breaklineChar: &#x27;|&#x27;, // 支持 body 和 footer  // footerPrefix : &#x27;ISSUES CLOSED:&#x27;  // askForBreakingChangeFirst : true,&#125;\n\n建议大家结合项目实际情况来自定义配置提交规则，例如很多时候我们不需要写长描述，公司内部的代码仓库也不需要管理 issue，那么可以把询问 body 和 footer 的步骤跳过（在 .cz-config.js 中修改成 skipQuestions: [&#39;body&#39;, &#39;footer&#39;]）。\n\n集成 commitlint 验证提交规范在“代码规范”章节，我们已经讲到过，尽管制定了规范，但在多人协作的项目中，总有些人依旧我行我素，因此提交代码这个环节，我们也增加一个限制：只让符合 Angular 规范的 commit message 通过，我们借助 @commitlint&#x2F;config-conventional 和 @commitlint&#x2F;cli 来实现。\n安装 commitlint安装 @commitlint&#x2F;config-conventional 和 @commitlint&#x2F;cli\nnpm i @commitlint/config-conventional @commitlint/cli -D\n\n配置 commitlint\n创建 commitlint.config.js 文件在项目根目录下创建 commitlint.config.js 文件，并填入以下内容：\nmodule.exports = &#123; extends: [&#x27;@commitlint/config-conventional&#x27;] &#125;\n\n或直接使用快捷命令：\necho &quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot; &gt; commitlint.config.js\n\n使用 husky 的 commit-msg hook 触发验证提交信息的命令我们使用 husky 命令在 .husky 目录下创建 commit-msg 文件，并在此执行 commit message 的验证命令。\nnpx husky add .husky/commit-msg &quot;npx --no-install commitlint --edit $1&quot;\n\n\n\n\ncommitlint 验证\n不符合规范的提交信息如下图，提交信息 test commitlint 不符合规范，提交失败。\n\n符合规范的提交信息如下图，提交信息 test: commitlint test 符合规范，成功提交到仓库。\n\n\n因为已在项目中集成 commitizen，建议大家用 git cz 来代替 git commit 提交代码，可以保证提交信息规范。\n\n本项目完整的代码托管在 GitHub 仓库，同学可以去下载下来，参考学习。点亮小星星 🌟 支持作者~\n\n单元测试单元测试是项目开发中一个非常重要的环节，完整的测试能为代码和业务提供质量保证，减少 Bug 的出现。\n本章节将带领大家在 Vite + Vue3 + TypeScript 的项目中集成单元测试工具。\n安装核心依赖我们使用 Vue 官方提供的 vue-test-utils 和社区流行的测试工具 jest 来进行 Vue 组件的单元测试。\n\nvue-test-utils The next iteration of Vue Test Utils. It targets Vue 3.\njest Delightful JavaScript Testing.\nvue-jest Jest Vue transformer\nts-jest A Jest transformer with source map support that lets you use Jest to test projects written in TypeScript.\n\n安装这些工具为开发依赖（devDependencies）：\nnpm i @vue/test-utils@next jest vue-jest@next ts-jest -D\n\n创建 jest 配置文件在项目根目录下新建 jest.config.js 文件：\nmodule.exports = &#123;  moduleFileExtensions: [&#x27;vue&#x27;, &#x27;js&#x27;, &#x27;ts&#x27;],  preset: &#x27;ts-jest&#x27;,  testEnvironment: &#x27;jsdom&#x27;,  transform: &#123;    &#x27;^.+\\\\.vue$&#x27;: &#x27;vue-jest&#x27;, // vue 文件用 vue-jest 转换    &#x27;^.+\\\\.ts$&#x27;: &#x27;ts-jest&#x27; // ts 文件用 ts-jest 转换  &#125;,  // 匹配 __tests__ 目录下的 .js/.ts 文件 或其他目录下的 xx.test.js/ts xx.spec.js/ts  testRegex: &#x27;(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.(ts)$&#x27;&#125;\n\n创建单元测试文件在上面的 jest.config.js 文件中，我们配置只匹配 __tests__ 目录下的任意 .ts 文件或其他目录下的 xx.test.ts&#x2F;xx.spec.ts 文件进行单元测试。\n这里，我们在项目根目录下创建 tests 目录来存储单元测试文件\n├── src/└── tests/                           // 单元测试目录    ├── Test.spec.ts                 // Test 组件测试\n\n\nTest.vue\n\n&lt;template&gt;  &lt;div class=&quot;test-container page-container&quot;&gt;    &lt;div class=&quot;page-title&quot;&gt;Unit Test Page&lt;/div&gt;    &lt;p&gt;count is: &#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;increment&quot;&gt;increment&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, ref &#125; from &#x27;vue&#x27;  export default defineComponent(&#123;    name: &#x27;Vuex&#x27;,    setup() &#123;      const count = ref&lt;number&gt;(0)      const increment = () =&gt; &#123;        count.value += 1      &#125;      return &#123; count, increment &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\nTest.spec.ts\nimport &#123; mount &#125; from &#x27;@vue/test-utils&#x27;import Test from &#x27;../src/views/Test.vue&#x27;test(&#x27;Test.vue&#x27;, async () =&gt; &#123;  const wrapper = mount(Test)  expect(wrapper.html()).toContain(&#x27;Unit Test Page&#x27;)  expect(wrapper.html()).toContain(&#x27;count is: 0&#x27;)  await wrapper.find(&#x27;button&#x27;).trigger(&#x27;click&#x27;)  expect(wrapper.html()).toContain(&#x27;count is: 1&#x27;)&#125;)\n\n集成 @types&#x2F;jest\n如上图，我们使用 VSCode &#x2F; WebStrom &#x2F; IDEA 等编辑器时，在单元测试文件中，IDE 会提示某些方法不存在（如 test、describe、it、expect等），安装 @types&#x2F;jest 即可解决。\nnpm i @types/jest -D\n\nTypeScript 的编译器也会提示 jest 的方法和类型找不到，我们还需把 @types&#x2F;jest 添加根目录下的 ts.config.json（TypeScript 配置文件）中：\n&#123;  &quot;compilerOptions&quot;: &#123;    ...    &quot;types&quot;: [&quot;vite/client&quot;, &quot;jest&quot;]  &#125;,&#125;\n\n添加 eslint-plugin-jest\n因为我们在项目中集成了 ESLint，如上图很明显是没通过 ESLint 规则检验。因此，我们还需要在 ESLint 中增加 eslint-plugin-jest 插件来解除对 jest 的校验。\n\n安装 eslint-plugin-jest\nnpm i eslint-plugin-jest -D\n\n添加 eslint-plugin-jest 到 ESLint 配置文件 .eslintrc.js 中\nmodule.exports = &#123;  ...  extends: [    ...    &#x27;plugin:jest/recommended&#x27;  ],  ...&#125;\n\n现在，我们的单元测试代码就不会有错误提示信息了 ؏؏☝ᖗ 乛 ◡ 乛 ᖘ☝؏؏\n\n执行单元测试在根目录下 package.json 文件的 scripts 中，添加一条单元测试命令： &quot;test&quot;: &quot;jest&quot;。\n\n执行命令 npm run test 即可进行单元测试，jest 会根据 jest.config.js 配置文件去查找 __tests__ 目录下的 .ts 文件或其他任意目录下的 .spec.ts 和 .test.ts 文件，然后执行单元测试方法。\n\n你可以在 jest.config.js 配置文件中，自由配置单元测试文件的目录。\n\n\n单元测试全部通过时的终端显示信息\n\n单元测试未全部通过时的终端显示信息\n\n\n当单元测试没有全部通过时，我们需要根据报错信息去优化对应组件的代码，进一步提高项目健壮性。但是写单元测试是件比较痛苦的事，我个人觉得也没必要全部组件都写单元测试，根据项目实际情况有针对性去写就行了。\n单元测试约束前面，我们使用 husky 在 Git 的 pre-commit 和 commit-msg 阶段分别约束代码风格规范和提交信息规范。这一步，我们在 pre-push 阶段进行单元测试，只有单元测试全部通过才让代码 push 到远端仓库，否则终止 push。\n使用 husky 命令在 .husky 目录下自动创建 pre-push hook 文件，并在此执行单元测试命令 npm run test。\nnpx husky add .husky/pre-push &quot;npm run test $1&quot;\n\n\n现在，我们在 git push 时就能先进行单元测试了，只有单元测试全部通过，才能成功 push。\n\n本项目完整的代码托管在 GitHub 仓库，同学可以去下载下来，参考学习。点亮小星星 🌟 支持作者~\n\n自动部署到了这一步，我们已经在项目中集成代码规范约束、提交信息规范约束，单元测试约束，从而保证我们远端仓库（如 GitHub、GitLab、Gitee 仓库等）的代码都是高质量的。\n本项目是要搭建一套规范的前端工程化环境，为此我们使用 CI（Continuous Integration 持续集成）来完成项目最后的部署工作。\n常见的 CI 工具有 GitHub Actions、GitLab CI、Travis CI、Circle CI 等。\n这里，我们使用 GitHub Actions。\n什么是 GitHub ActionsGitHub Actions 是 GitHub 的持续集成服务，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器、发布到第三方服务等等，GitHub 把这些操作称为 actions。\n配置 GitHub Actions创建 GitHub 仓库因为 GitHub Actions 只对 GitHub 仓库有效，所以我们创建 GitHub 仓库来托管项目代码。\n\n其中，我们用：\n\nmaster 分支存储项目源代码\ngh-pages 分支存储打包后的静态文件\n\n\ngh-pages 分支，是 GitHub Pages 服务的固定分支，可以通过 HTTP 的方式访问到这个分支的静态文件资源。\n\n创建 GitHub Token创建一个有 repo 和 workflow 权限的 GitHub Token\n\n注意：新生成的 Token 只会显示一次，保存起来，后面要用到。如有遗失，重新生成即可。\n\n在仓库中添加 secret将上面新创建的 Token 添加到 GitHub 仓库的 Secrets 里，并将这个新增的 secret 命名为 VUE3_DEPLOY （名字无所谓，看你喜欢）。\n步骤：仓库 -&gt; settings -&gt; Secrets -&gt; New repository secret。\n\n\n新创建的 secret VUE3_DEPLOY 在 Actions 配置文件中要用到，两个地方需保持一致！\n\n创建 Actions 配置文件\n在项目根目录下创建 .github 目录。\n在 .github 目录下创建 workflows 目录。\n在 workflows 目录下创建 deploy.yml 文件。\n\n\ndeploy.yml 文件的内容：\nname: deployon:  push:    branches: [master] # master 分支有 push 时触发jobs:  deploy:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - name: Setup Node.js v14.x        uses: actions/setup-node@v1        with:          node-version: &#x27;14.x&#x27;      - name: Install        run: npm install # 安装依赖      - name: Build        run: npm run build # 打包      - name: Deploy        uses: peaceiris/actions-gh-pages@v3 # 使用部署到 GitHub pages 的 action        with:          publish_dir: ./dist # 部署打包后的 dist 目录          github_token: $&#123;&#123; secrets.VUE3_DEPLOY &#125;&#125; # secret 名          user_name: $&#123;&#123; secrets.MY_USER_NAME &#125;&#125;          user_email: $&#123;&#123; secrets.MY_USER_EMAIL &#125;&#125;          commit_message: Update Vite2.x + Vue3.x + TypeScript Starter # 部署时的 git 提交信息，自由填写\n\n自动部署触发原理当有新提交的代码 push 到 GitHub 仓库时，就会触发 GitHub Actions，在 GitHub 服务器上执行 Action 配置文件里面的命令，例如：安装依赖、项目打包等，然后将打包好的静态文件部署到 GitHub Pages 上，最后，我们就能通过域名访问了。\n\n🌏 通过域名 https://vite-vue3-starter.xpoet.cn/ 访问本项目\n\n使用自动部署，我们只需专注于项目开发阶段，任何重复且枯燥的行为都交由程序去完成，懒才是程序员第一生产力。\n事实上，自动部署只是 GitHub Actions 功能的冰山一角，GitHub Actions 能做的事还很多很多，大家感兴趣的话自行查阅。\n最后本文从技术选项到架构搭建、从代码规范约束到提交信息规范约束，从单元测试到自动部署，一步一步带领大家如何从一个最简单的前端项目骨架到规范的前端工程化环境，基本上涵盖了前端项目开发的整个流程。\n因篇幅较长，所涉及技术点较多，难免会出现错误，希望大家多多指正，谢谢大家！\n\n\n","categories":["前端"],"tags":["Vue","Vite","前端工程化"]},{"title":"前端工程化入门","url":"/post/936c9599737d/","content":"本文带你入门前端工程化，分为 7 个小节讲解：\n\n技术选型\n统一规范\n测试\n部署\n监控\n性能优化\n重构\n\n技术选型对于前端工程师来说，技术选型挺简单的，就是做选择题，三大框架中选一个。个人认为可以依据以下两个特点来选：\n\n选你或团队最熟的，保证在遇到棘手的问题时有人能填坑。\n选市场占有率高的。换句话说，就是选好招人的。\n\n第二点对于小公司来说，特别重要。本来小公司就不好招人，要是还选一个市场占有率不高的框架（例如 Angular），简历你都看不到几个…\n\n\nUI 组件库更简单，github 上哪个 star 多就用哪个。star 多，说明用的人就多，很多坑别人都替你踩过了，省事。\n统一规范代码规范先来看看统一代码规范的好处：\n\n规范的代码可以促进团队合作\n规范的代码可以降低维护成本\n规范的代码有助于 code review（代码审查）\n养成代码规范的习惯，有助于程序员自身的成长\n\n当团队的成员都严格按照代码规范来写代码时，可以保证每个人的代码看起来都像是一个人写的，看别人的代码就像是在看自己的代码。更重要的是我们能够认识到规范的重要性，并坚持规范的开发习惯。\n如何制订代码规范建议找一份好的代码规范，在此基础上结合团队的需求作个性化修改。\n下面列举一些 star 较多的 js 代码规范：\n\nairbnb（英文版）\nairbnb（中文版）\nstandard (中文版) \n百度前端编码规范\n\nCSS 代码规范也有不少，例如：\n\nstyleguide\nspec\n\n如何检查代码规范使用 eslint 可以检查代码符不符合团队制订的规范，下面来看一下如何配置 eslint 来检查代码。\n\n下载依赖\n\n// eslint-config-airbnb-base 使用 airbnb 代码规范npm i -D babel-eslint eslint eslint-config-airbnb-base eslint-plugin-import\n\n\n配置 .eslintrc 文件\n\n&#123;  &quot;parserOptions&quot;: &#123;    &quot;ecmaVersion&quot;: 2019  &#125;,  &quot;env&quot;: &#123;    &quot;es6&quot;: true  &#125;,  &quot;parser&quot;: &quot;babel-eslint&quot;,  &quot;extends&quot;: &quot;airbnb-base&quot;&#125;\n\n\n在 package.json 的 scripts 加上这行代码 &quot;lint&quot;: &quot;eslint --ext .js test/ src/&quot;。然后执行 npm run lint 即可开始验证代码。代码中的 test/ src/ 是指你要进行校验的代码目录，这里指明了要检查 test、src 目录下的代码。\n\n不过这样检查代码效率太低，每次都得手动检查。并且报错了还得手动修改代码。\n为了改善以上缺点，我们可以使用 VSCode。使用它并加上适当的配置可以在每次保存代码的时候，自动验证代码并进行格式化，省去了动手的麻烦。\ncss 检查代码规范则使用 stylelint 插件。\n由于篇幅有限，具体如何配置请看我的另一篇文章 ESlint + stylelint + VSCode 自动格式化代码 (2020)。\n\ngit 规范git 规范包括两点：分支管理规范、git commit 规范。\n分支管理规范一般项目分主分支（master）和其他分支。当有团队成员要开发新功能或改 BUG 时，就从 master 分支开一个新的分支。例如项目要从客户端渲染改成服务端渲染，就开一个分支叫 ssr，开发完了再合并回 master 分支。如果改一个 BUG，也可以从 master 分支开一个新分支，并用 BUG 号命名（不过我们小团队嫌麻烦，没这样做，除非有特别大的 BUG）。\ngit commit 规范&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;\n\n大致分为三个部分 (使用空行分割):\n\n标题行：必填，描述主要修改类型和内容\n主题内容：描述为什么修改，做了什么样的修改，以及开发的思路等等\n页脚注释：可以写注释，BUG 号链接\n\ntype: commit 的类型\nfeat: 新功能、新特性\nfix: 修改 bug\nperf: 更改代码，以提高性能\nrefactor: 代码重构（重构，在不影响代码内部行为、功能下的代码修改）\ndocs: 文档修改\nstyle: 代码格式修改，注意不是 css 修改（例如分号修改）\ntest: 测试用例新增、修改\nbuild: 影响项目构建或依赖项修改\nrevert: 恢复上一次提交\nci: 持续集成相关文件修改\nchore: 其他修改（不在上述类型中的修改）\nrelease: 发布新版本\nworkflow: 工作流相关文件修改\n\n\nscope: commit 影响的范围，比如：route, component, utils, build…\nsubject: commit 的概述\nbody: commit 具体修改内容，可以分为多行。\nfooter: 一些备注，通常是 BREAKING CHANGE 或修复的 bug 的链接。\n\n示例：\n\nfix（修复 BUG）\n如果修复的这个 BUG 只影响当前修改的文件，可不加范围。如果影响的范围比较大，要加上范围描述。\n例如这次 BUG 修复影响到全局，可以加个 global。如果影响的是某个目录或某个功能，可以加上该目录的路径，或者对应的功能名称。\n// 示例 1fix(global): 修复 checkbox 不能复选的问题// 示例 2 下面圆括号里的 common 为通用管理的名称fix(common): 修复字体过小的 BUG，将通用管理下所有页面的默认字体大小修改为 14px// 示例 3fix: value.length -&gt; values.length\n\nfeat（添加新功能或新页面）\nfeat: 添加网站主页静态页面这是一个示例，假设对点检任务静态页面进行了一些描述。这里是备注，可以是放 BUG 链接或者一些重要性的东西。\n\nchore（其他修改）\nchore 的中文翻译为日常事务、例行工作，顾名思义，即不在其他 commit 类型中的修改，都可以用 chore 表示。\nchore: 将表格中的查看详情改为详情\n\n其他类型的 commit 和上面三个示例差不多，就不说了。\n\n\n验证 git commit 规范验证 git commit 规范，主要通过 git 的 pre-commit 钩子函数来进行。当然，你还需要下载一个辅助工具来帮助你进行验证。\n下载辅助工具\nnpm i -D husky\n\n在 package.json 加上下面的代码\n&quot;husky&quot;: &#123;  &quot;hooks&quot;: &#123;    &quot;pre-commit&quot;: &quot;npm run lint&quot;,    &quot;commit-msg&quot;: &quot;node script/verify-commit.js&quot;,    &quot;pre-push&quot;: &quot;npm test&quot;  &#125;&#125;\n\n然后在你项目根目录下新建一个文件夹 script，并在下面新建一个文件 verify-commit.js，输入以下代码：\nconst msgPath = process.env.HUSKY_GIT_PARAMS;const msg = require(&quot;fs&quot;).readFileSync(msgPath, &quot;utf-8&quot;).trim();const commitRE = /^(feat|fix|docs|style|refactor|perf|test|workflow|build|ci|chore|release|workflow)(\\(.+\\))?: .&#123;1,50&#125;/;if (!commitRE.test(msg)) &#123;  console.log();  console.error(`        不合法的 commit 消息格式。        请查看 git commit 提交规范：https://github.com/woai3c/Front-end-articles/blob/master/git%20commit%20style.md    `);  process.exit(1);&#125;\n\n现在来解释下各个钩子的含义：\n\n&quot;pre-commit&quot;: &quot;npm run lint&quot; 在 git commit 前执行 npm run lint 检查代码格式。\n\n&quot;commit-msg&quot;: &quot;node script/verify-commit.js&quot; 在 git commit 时执行脚本。verify-commit.js 验证 commit 消息。如果不符合脚本中定义的格式，将会报错。\n\n&quot;pre-push&quot;: &quot;npm test&quot; 在你执行 git push 将代码推送到远程仓库前，执行 npm test 进行测试。如果测试失败，将不会执行这次推送。\n\n\n项目规范主要是项目文件的组织方式和命名方式。\n用我们的 Vue 项目举个例子。\n├─public├─src├─test\n\n一个项目包含 public（公共资源，不会被 webpack 处理）、src（源码）、test（测试代码），其中 src 目录，又可以细分。\n├─api （接口）├─assets （静态资源）├─components （公共组件）├─styles （公共样式）├─router （路由）├─store （vuex 全局数据）├─utils （工具函数）└─views （页面）\n\n文件名称如果过长则用 - 隔开。\nUI 规范UI 规范需要前端、UI、产品沟通，互相商量，最后制定下来，建议使用统一的 UI 组件库。\n制定 UI 规范的好处：\n\n统一页面 UI 标准，节省 UI 设计时间\n提高前端开发效率\n\n测试测试是前端工程化建设必不可少的一部分，它的作用就是找出 bug，越早发现 bug，所需要付出的成本就越低。并且，它更重要的作用是在将来，而不是当下。\n设想一下半年后，你的项目要加一个新功能。在加完新功能后，你不确定有没有影响到原有的功能，需要测试一下。由于时间过去太久，你对项目的代码已经不了解了。在这种情况下，如果没有写测试，你就得手动一遍一遍的去试。而如果写了测试，你只需要跑一遍测试代码就 OK 了，省时省力。\n写测试还可以让你修改代码时没有心理负担，不用一直想着改这里有没有问题？会不会引起 BUG？而写了测试就没有这种担心了。\n在前端用得最多的就是单元测试（主要是端到端测试我用得很少，不熟），这里着重讲解一下。\n单元测试单元测试就是对一个函数、一个组件、一个类做的测试，它针对的粒度比较小。\n它应该怎么写呢？\n\n根据正确性写测试，即正确的输入应该有正常的结果。\n根据异常写测试，即错误的输入应该是错误的结果。\n\n对一个函数做测试例如一个取绝对值的函数 abs()，输入 1,2，结果应该与输入相同；输入 -1,-2，结果应该与输入相反。如果输入非数字，例如 &quot;abc&quot;，应该抛出一个类型错误。\n对一个类做测试假设有这样一个类：\nclass Math &#123;    abs() &#123;    &#125;    sqrt() &#123;    &#125;    pow() &#123;    &#125;    ...&#125;\n\n单元测试，必须把这个类的所有方法都测一遍。\n对一个组件做测试组件测试比较难，因为很多组件都涉及了 DOM 操作。\n例如一个上传图片组件，它有一个将图片转成 base64 码的方法，那要怎么测试呢？一般测试都是跑在 node 环境下的，而 node 环境没有 DOM 对象。\n我们先来回顾一下上传图片的过程：\n\n点击 &lt;input type=&quot;file&quot; /&gt;，选择图片上传。\n触发 input 的 change 事件，获取 file 对象。\n用 FileReader 将图片转换成 base64 码。\n\n这个过程和下面的代码是一样的：\ndocument.querySelector(&quot;input&quot;).onchange = function fileChangeHandler(e) &#123;  const file = e.target.files[0];  const reader = new FileReader();  reader.onload = (res) =&gt; &#123;    const fileResult = res.target.result;    console.log(fileResult); // 输出 base64 码  &#125;;  reader.readAsDataURL(file);&#125;;\n\n上面的代码只是模拟，真实情况下应该是这样使用\ndocument.querySelector(&quot;input&quot;).onchange = function fileChangeHandler(e) &#123;  const file = e.target.files[0];  tobase64(file);&#125;;function tobase64(file) &#123;  return new Promise((resolve, reject) =&gt; &#123;    const reader = new FileReader();    reader.onload = (res) =&gt; &#123;      const fileResult = res.target.result;      resolve(fileResult); // 输出 base64 码    &#125;;    reader.readAsDataURL(file);  &#125;);&#125;\n\n可以看到，上面代码出现了 window 的事件对象 event、FileReader。也就是说，只要我们能够提供这两个对象，就可以在任何环境下运行它。所以我们可以在测试环境下加上这两个对象：\n// 重写 Filewindow.File = function () &#123;&#125;;// 重写 FileReaderwindow.FileReader = function () &#123;  this.readAsDataURL = function () &#123;    this.onload &amp;&amp;      this.onload(&#123;        target: &#123;          result: fileData,        &#125;,      &#125;);  &#125;;&#125;;\n\n然后测试可以这样写：\n// 提前写好文件内容const fileData = &quot;data:image/test&quot;;// 提供一个假的 file 对象给 tobase64() 函数function test() &#123;  const file = new File();  const event = &#123; target: &#123; files: [file] &#125; &#125;;  file.type = &quot;image/png&quot;;  file.name = &quot;test.png&quot;;  file.size = 1024;  it(&quot;file content&quot;, (done) =&gt; &#123;    tobase64(file).then((base64) =&gt; &#123;      expect(base64).toEqual(fileData); // &#x27;data:image/test&#x27;      done();    &#125;);  &#125;);&#125;// 执行测试test();\n\n通过这种 hack 的方式，我们就实现了对涉及 DOM 操作的组件的测试。我的 vue-upload-imgs 库就是通过这种方式写的单元测试，有兴趣可以了解一下。\nTDD 测试驱动开发TDD 就是根据需求提前把测试代码写好，然后根据测试代码实现功能。\nTDD 的初衷是好的，但如果你的需求经常变（你懂的），那就不是一件好事了。很有可能你天天都在改测试代码，业务代码反而没怎么动。所以到现在为止，三年多的程序员生涯，我还没尝试过 TDD 开发。\n虽然环境如此艰难，但有条件的情况下还是应该试一下 TDD 的。例如在你自己负责一个项目又不忙的时候，可以采用此方法编写测试用例。\n测试框架推荐我常用的测试框架是 jest，好处是有中文文档，API 清晰明了，一看就知道是干什么用的。\n部署在没有学会自动部署前，我是这样部署项目的：\n\n执行测试 npm run test。\n构建项目 npm run build。\n将打包好的文件放到静态服务器。\n\n一次两次还行，如果天天都这样，就会把很多时间浪费在重复的操作上。所以我们要学会自动部署，彻底解放双手。\n自动部署（又叫持续部署 Continuous Deployment，英文缩写 CD）一般有两种触发方式：\n\n轮询。\n监听 webhook 事件。\n\n轮询轮询，就是构建软件每隔一段时间自动执行打包、部署操作。\n这种方式不太好，很有可能软件刚部署完我就改代码了。为了看到新的页面效果，不得不等到下一次构建开始。\n另外还有一个副作用，假如我一天都没更改代码，构建软件还是会不停的执行打包、部署操作，白白的浪费资源。\n所以现在的构建软件基本采用监听 webhook 事件的方式来进行部署。\n监听 webhook 事件webhook 钩子函数，就是在你的构建软件上进行设置，监听某一个事件（一般是监听 push 事件），当事件触发时，自动执行定义好的脚本。\n例如 Github Actions 就有这个功能。\n对于新人来说，仅看我这一段讲解是不可能学会自动部署的。为此我特地写了一篇自动化部署教程，不需要你提前学习自动化部署的知识，只要照着指引做，就能实现前端项目自动化部署。\n前端项目自动化部署——超详细教程（Jenkins、Github Actions），教程已经奉上，各位大佬看完后要是觉得有用，不要忘了点赞，感激不尽。\n监控监控，又分性能监控和错误监控，它的作用是预警和追踪定位问题。\n性能监控性能监控一般利用 window.performance 来进行数据采集。\n\nPerformance 接口可以获取到当前页面中与性能相关的信息，它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、User Timing API 和 Resource Timing API。\n\n这个 API 的属性 timing，包含了页面加载各个阶段的起始及结束时间。\n\n\n为了方便大家理解 timing 各个属性的意义，我在知乎找到一位网友对于 timing 写的简介（忘了姓名，后来找不到了，见谅），在此转载一下。\ntiming: &#123;    // 同一个浏览器上一个页面卸载 (unload) 结束时的时间戳。如果没有上一个页面，这个值会和 fetchStart 相同。\tnavigationStart: 1543806782096,\t// 上一个页面 unload 事件抛出时的时间戳。如果没有上一个页面，这个值会返回 0。\tunloadEventStart: 1543806782523,\t// 和 unloadEventStart 相对应，unload 事件处理完成时的时间戳。如果没有上一个页面，这个值会返回 0。\tunloadEventEnd: 1543806782523,\t// 第一个 HTTP 重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回 0。\tredirectStart: 0,\t// 最后一个 HTTP 重定向完成时（也就是说是 HTTP 响应的最后一个比特直接被收到的时间）的时间戳。\t// 如果没有重定向，或者重定向中的一个不同源，这个值会返回 0.\tredirectEnd: 0,\t// 浏览器准备好使用 HTTP 请求来获取 (fetch) 文档的时间戳。这个时间点会在检查任何应用缓存之前。\tfetchStart: 1543806782096,\t// DNS 域名查询开始的 UNIX 时间戳。        //如果使用了持续连接 (persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart 一致。\tdomainLookupStart: 1543806782096,\t// DNS 域名查询完成的时间。\t//如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等\tdomainLookupEnd: 1543806782096,\t// HTTP（TCP）域名查询结束的时间戳。        //如果使用了持续连接 (persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart 一致。\tconnectStart: 1543806782099,\t// HTTP（TCP）返回浏览器与服务器之间的连接建立时的时间戳。        // 如果建立的是持久连接，则返回值等同于 fetchStart 属性的值。连接建立指的是所有握手和认证过程全部结束。\tconnectEnd: 1543806782227,\t// HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回 0。\tsecureConnectionStart: 1543806782162,\t// 返回浏览器向服务器发出 HTTP 请求时（或开始读取本地缓存时）的时间戳。\trequestStart: 1543806782241,\t// 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。        //如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。\tresponseStart: 1543806782516,\t// 返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时        //（如果在此之前 HTTP 连接已经关闭，则返回关闭时）的时间戳。\tresponseEnd: 1543806782537,\t// 当前网页 DOM 结构开始解析时（即 Document.readyState 属性变为“loading”、相应的 readystatechange 事件触发时）的时间戳。\tdomLoading: 1543806782573,\t// 当前网页 DOM 结构结束解析、开始加载内嵌资源时（即 Document.readyState 属性变为“interactive”、相应的 readystatechange 事件触发时）的时间戳。\tdomInteractive: 1543806783203,\t// 当解析器发送 DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。\tdomContentLoadedEventStart: 1543806783203,\t// 当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。\tdomContentLoadedEventEnd: 1543806783216,\t// 当前文档解析完成，即 Document.readyState 变为 &#x27;complete&#x27;且相对应的 readystatechange 被触发时的时间戳\tdomComplete: 1543806783796,\t// load 事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是 0。\tloadEventStart: 1543806783796,\t// 当 load 事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是 0.\tloadEventEnd: 1543806783802&#125;\n\n通过以上数据，我们可以得到几个有用的时间\n// 重定向耗时redirect: timing.redirectEnd - timing.redirectStart,// DOM 渲染耗时dom: timing.domComplete - timing.domLoading,// 页面加载耗时load: timing.loadEventEnd - timing.navigationStart,// 页面卸载耗时unload: timing.unloadEventEnd - timing.unloadEventStart,// 请求耗时request: timing.responseEnd - timing.requestStart,// 获取性能信息时当前时间time: new Date().getTime(),\n\n还有一个比较重要的时间就是白屏时间，它指从输入网址，到页面开始显示内容的时间。\n将以下脚本放在 &lt;/head&gt; 前面就能获取白屏时间。\n&lt;script&gt;  whiteScreen = new Date() - performance.timing.navigationStart;&lt;/script&gt;\n\n通过这几个时间，就可以得知页面首屏加载性能如何了。\n另外，通过 window.performance.getEntriesByType(&#39;resource&#39;) 这个方法，我们还可以获取相关资源（js、css、img…）的加载时间，它会返回页面当前所加载的所有资源。\n\n它一般包括以下几个类型\n\nsciprt\nlink\nimg\ncss\nfetch\nother\nxmlhttprequest\n\n我们只需用到以下几个信息\n// 资源的名称name: item.name,// 资源加载耗时duration: item.duration.toFixed(2),// 资源大小size: item.transferSize,// 资源所用协议protocol: item.nextHopProtocol,\n\n现在，写几行代码来收集这些数据。\n// 收集性能信息const getPerformance = () =&gt; &#123;  if (!window.performance) return;  const timing = window.performance.timing;  const performance = &#123;    // 重定向耗时    redirect: timing.redirectEnd - timing.redirectStart,    // 白屏时间    whiteScreen: whiteScreen,    // DOM 渲染耗时    dom: timing.domComplete - timing.domLoading,    // 页面加载耗时    load: timing.loadEventEnd - timing.navigationStart,    // 页面卸载耗时    unload: timing.unloadEventEnd - timing.unloadEventStart,    // 请求耗时    request: timing.responseEnd - timing.requestStart,    // 获取性能信息时当前时间    time: new Date().getTime(),  &#125;;  return performance;&#125;;// 获取资源信息const getResources = () =&gt; &#123;  if (!window.performance) return;  const data = window.performance.getEntriesByType(&quot;resource&quot;);  const resource = &#123;    xmlhttprequest: [],    css: [],    other: [],    script: [],    img: [],    link: [],    fetch: [],    // 获取资源信息时当前时间    time: new Date().getTime(),  &#125;;  data.forEach((item) =&gt; &#123;    const arry = resource[item.initiatorType];    arry &amp;&amp;      arry.push(&#123;        // 资源的名称        name: item.name,        // 资源加载耗时        duration: item.duration.toFixed(2),        // 资源大小        size: item.transferSize,        // 资源所用协议        protocol: item.nextHopProtocol,      &#125;);  &#125;);  return resource;&#125;;\n\n小结通过对性能及资源信息的解读，我们可以判断出页面加载慢有以下几个原因：\n\n资源过多\n网速过慢\nDOM 元素过多\n\n除了用户网速过慢，我们没办法之外，其他两个原因都是有办法解决的，性能优化将在下一节《性能优化》中会讲到。\n错误监控现在能捕捉的错误有三种。\n\n资源加载错误，通过 addEventListener(&#39;error&#39;, callback, true) 在捕获阶段捕捉资源加载失败错误。\njs 执行错误，通过 window.onerror 捕捉 js 错误。\npromise 错误，通过 addEventListener(&#39;unhandledrejection&#39;, callback) 捕捉 promise 错误，但是没有发生错误的行数，列数等信息，只能手动抛出相关错误信息。\n\n我们可以建一个错误数组变量 errors 在错误发生时，将错误的相关信息添加到数组，然后在某个阶段统一上报，具体如何操作请看代码\n// 捕获资源加载失败错误 js css img...addEventListener(  &quot;error&quot;,  (e) =&gt; &#123;    const target = e.target;    if (target != window) &#123;      monitor.errors.push(&#123;        type: target.localName,        url: target.src || target.href,        msg: (target.src || target.href) + &quot; is load error&quot;,        // 错误发生的时间        time: new Date().getTime(),      &#125;);    &#125;  &#125;,  true);// 监听 js 错误window.onerror = function (msg, url, row, col, error) &#123;  monitor.errors.push(&#123;    type: &quot;javascript&quot;,    row: row,    col: col,    msg: error &amp;&amp; error.stack ? error.stack : msg,    url: url,    // 错误发生的时间    time: new Date().getTime(),  &#125;);&#125;;// 监听 promise 错误 缺点是获取不到行数数据addEventListener(&quot;unhandledrejection&quot;, (e) =&gt; &#123;  monitor.errors.push(&#123;    type: &quot;promise&quot;,    msg: (e.reason &amp;&amp; e.reason.msg) || e.reason || &quot;&quot;,    // 错误发生的时间    time: new Date().getTime(),  &#125;);&#125;);\n\n小结通过错误收集，可以了解到网站错误发生的类型及数量，从而可以做相应的调整，以减少错误发生。完整代码和 DEMO 请看我另一篇文章 前端性能和错误监控 的末尾，大家可以复制代码（HTML 文件）在本地测试一下。\n数据上报性能数据上报性能数据可以在页面加载完之后上报，尽量不要对页面性能造成影响。\nwindow.onload = () =&gt; &#123;  // 在浏览器空闲时间获取性能及资源信息  // https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback  if (window.requestIdleCallback) &#123;    window.requestIdleCallback(() =&gt; &#123;      monitor.performance = getPerformance();      monitor.resources = getResources();    &#125;);  &#125; else &#123;    setTimeout(() =&gt; &#123;      monitor.performance = getPerformance();      monitor.resources = getResources();    &#125;, 0);  &#125;&#125;;\n\n当然，你也可以设一个定时器，循环上报。不过每次上报最好做一下对比去重再上报，避免同样的数据重复上报。\n错误数据上报我在 DEMO 里提供的代码，是用一个 errors 数组收集所有的错误，再在某一阶段统一上报（延时上报）。其实，也可以改成在错误发生时上报（即时上报）。这样可以避免在收集完错误延时上报还没触发，用户却已经关掉网页导致错误数据丢失的问题。\n// 监听 js 错误window.onerror = function (msg, url, row, col, error) &#123;  const data = &#123;    type: &quot;javascript&quot;,    row: row,    col: col,    msg: error &amp;&amp; error.stack ? error.stack : msg,    url: url,    // 错误发生的时间    time: new Date().getTime(),  &#125;;  // 即时上报  axios.post(&#123; url: &quot;xxx&quot;, data &#125;);&#125;;\n\nSPAwindow.performance API 是有缺点的，在 SPA 切换路由时，window.performance.timing 的数据不会更新。所以我们需要另想办法来统计切换路由到加载完成的时间。拿 Vue 举例，一个可行的办法就是切换路由时，在路由的全局前置守卫 beforeEach 里获取开始时间，在组件的 mounted 钩子里执行 vm.$nextTick 函数来获取组件的渲染完毕时间。\nrouter.beforeEach((to, from, next) =&gt; &#123;  store.commit(&quot;setPageLoadedStartTime&quot;, new Date());&#125;);\n\nmounted() &#123;\tthis.$nextTick(() =&gt; &#123;\t\tthis.$store.commit(&#x27;setPageLoadedTime&#x27;, new Date() - this.$store.state.pageLoadedStartTime)\t&#125;)&#125;\n\n除了性能和错误监控，其实我们还可以做得更多。\n用户信息收集navigator使用 window.navigator 可以收集到用户的设备信息，操作系统，浏览器信息…\nUV (Unique visitor)是指通过互联网访问、浏览这个网页的自然人。访问您网站的一台电脑客户端为一个访客。00:00-24:00 内相同的客户端只被计算一次。一天内同个访客多次访问仅计算一个 UV。在用户访问网站时，可以生成一个随机字符串 + 时间日期，保存在本地。在网页发生请求时（如果超过当天 24 小时，则重新生成），把这些参数传到后端，后端利用这些信息生成 UV 统计报告。\nPV (Page View)即页面浏览量或点击量，用户每 1 次对网站中的每个网页访问均被记录 1 个 PV。用户对同一页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。\n页面停留时间\n传统网站用户在进入 A 页面时，通过后台请求把用户进入页面的时间捎上。过了 10 分钟，用户进入 B 页面，这时后台可以通过接口捎带的参数可以判断出用户在 A 页面停留了 10 分钟。\n\nSPA可以利用 router 来获取用户停留时间，拿 Vue 举例，通过 router.beforeEach、destroyed 这两个钩子函数来获取用户停留该路由组件的时间。\n\n\n浏览深度通过 document.documentElement.scrollTop 属性以及屏幕高度，可以判断用户是否浏览完网站内容。\n页面跳转来源通过 document.referrer 属性，可以知道用户是从哪个网站跳转而来。\n小结通过分析用户数据，我们可以了解到用户的浏览习惯、爱好等等信息，想想真是恐怖，毫无隐私可言。\n前端监控部署教程前面说的都是监控原理，但要实现还是得自己动手写代码。为了避免麻烦，我们可以用现有的工具 sentry 去做这件事。\nsentry 是一个用 python 写的性能和错误监控工具，你可以使用 sentry 提供的服务（免费功能少），也可以自己部署服务。现在来看一下如何使用 sentry 提供的服务实现监控。\n注册账号打开 https://sentry.io/signup/ 网站，进行注册。\n\n\n选择项目，我选的 Vue。\n\n安装 sentry 依赖选完项目，下面会有具体的 sentry 依赖安装指南。\n\n根据提示，在你的 Vue 项目执行这段代码 npm install --save @sentry/browser @sentry/integrations @sentry/tracing，安装 sentry 所需的依赖。\n再将下面的代码拷到你的 main.js，放在 new Vue() 之前。\nimport * as Sentry from &quot;@sentry/browser&quot;;import &#123; Vue as VueIntegration &#125; from &quot;@sentry/integrations&quot;;import &#123; Integrations &#125; from &quot;@sentry/tracing&quot;;Sentry.init(&#123;  dsn: &quot;xxxxx&quot;, // 这里是你的 dsn 地址，注册完就有  integrations: [    new VueIntegration(&#123;      Vue,      tracing: true,    &#125;),    new Integrations.BrowserTracing(),  ],  // We recommend adjusting this value in production, or using tracesSampler  // for finer control  tracesSampleRate: 1.0,&#125;);\n\n然后点击第一步中的 skip this onboarding，进入控制台页面。\n如果忘了自己的 DSN，请点击左边的菜单栏选择 Settings -&gt; Projects -&gt; 点击自己的项目 -&gt; Client Keys(DSN)。\n创建第一个错误在你的 Vue 项目执行一个打印语句 console.log(b)。\n这时点开 sentry 主页的 issues 一项，可以发现有一个报错信息 b is not defined：\n\n这个报错信息包含了错误的具体信息，还有你的 IP、浏览器信息等等。\n但奇怪的是，我们的浏览器控制台并没有输出报错信息。\n这是因为被 sentry 屏蔽了，所以我们需要加上一个选项 logErrors: true。\n\n然后再查看页面，发现控制台也有报错信息了：\n\n上传 sourcemap一般打包后的代码都是经过压缩的，如果没有 sourcemap，即使有报错信息，你也很难根据提示找到对应的源码在哪。\n下面来看一下如何上传 sourcemap。\n首先创建 auth token。\n\n\n\n\n这个生成的 token 一会要用到。\n安装 sentry-cli 和 @sentry/webpack-plugin：\nnpm install sentry-cli-binary -gnpm install --save-dev @sentry/webpack-plugin\n\n安装完上面两个插件后，在项目根目录创建一个 .sentryclirc 文件（不要忘了在 .gitignore 把这个文件添加上，以免暴露 token），内容如下：\n[auth]token=xxx[defaults]url=https://sentry.io/org=woai3cproject=woai3c\n\n把 xxx 替换成刚才生成的 token。\norg 是你的组织名称。\n\nproject 是你的项目名称，根据下面的提示可以找到。\n\n\n在项目下新建 vue.config.js 文件，把下面的内容填进去：\nconst SentryWebpackPlugin = require(&quot;@sentry/webpack-plugin&quot;);const config = &#123;  configureWebpack: &#123;    plugins: [      new SentryWebpackPlugin(&#123;        include: &quot;./dist&quot;, // 打包后的目录        ignore: [&quot;node_modules&quot;, &quot;vue.config.js&quot;, &quot;babel.config.js&quot;],      &#125;),    ],  &#125;,&#125;;// 只在生产环境下上传 sourcemapmodule.exports = process.env.NODE_ENV == &quot;production&quot; ? config : &#123;&#125;;\n\n填完以后，执行 npm run build，就可以看到 sourcemap 的上传结果了。\n\n我们再来看一下没上传 sourcemap 和上传之后的报错信息对比。\n未上传 sourcemap\n\n已上传 sourcemap\n\n可以看到，上传 sourcemap 后的报错信息更加准确。\n切换中文环境和时区\n\n选完刷新即可。\n性能监控\n打开 performance 选项，就能看到你每个项目的运行情况。具体的参数解释请看文档 Performance Monitoring。\n性能优化性能优化主要分为两类：\n\n加载时优化\n运行时优化\n\n例如压缩文件、使用 CDN 就属于加载时优化；减少 DOM 操作，使用事件委托属于运行时优化。在解决问题之前，必须先找出问题，否则无从下手。所以在做性能优化之前，最好先调查一下网站的加载性能和运行性能。\n手动检查检查加载性能一个网站加载性能如何主要看白屏时间和首屏时间。\n\n白屏时间：指从输入网址，到页面开始显示内容的时间。\n首屏时间：指从输入网址，到页面完全渲染的时间。\n\n将以下脚本放在 &lt;/head&gt; 前面就能获取白屏时间。\n&lt;script&gt;  new Date() - performance.timing.navigationStart;&lt;/script&gt;\n\n在 window.onload 事件里执行 new Date() - performance.timing.navigationStart 即可获取首屏时间。\n检查运行性能配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。打开网站，按 F12 选择 performance，点击左上角的灰色圆点，变成红色就代表开始记录了。这时可以模仿用户使用网站，在使用完毕后，点击 stop，然后你就能看到网站运行期间的性能报告。如果有红色的块，代表有掉帧的情况；如果是绿色，则代表 FPS 很好。另外，在 performance 标签下，按 ESC 会弹出来一个小框。点击小框左边的三个点，把 rendering 勾出来。\n\n\n这两个选项，第一个是高亮重绘区域，另一个是显示帧渲染信息。把这两个选项勾上，然后浏览网页，可以实时的看到你网页渲染变化。\n利用工具检查监控工具可以部署一个前端监控系统来监控网站性能，上一节中讲到的 sentry 就属于这一类。\nchrome 工具 Lighthouse如果你安装了 Chrome 52+ 版本，请按 F12 打开开发者工具。\n\n它不仅会对你网站的性能打分，还会对 SEO 打分。\n\n使用 Lighthouse 审查网络应用\n如何做性能优化网上关于性能优化的文章和书籍多不胜数，但有很多优化规则已经过时了。所以我写了一篇性能优化文章 前端性能优化 24 条建议 (2020)，分析总结出了 24 条性能优化建议，强烈推荐。\n重构《重构 2》一书中对重构进行了定义：\n\n所谓重构（refactoring）是这样一个过程：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减小整理过程中引入错误的概率。本质上说，重构就是在代码写好之后改进它的设计。\n\n重构和性能优化有相同点，也有不同点。\n相同的地方是它们都在不改变程序功能的情况下修改代码；不同的地方是重构为了让代码变得更加易读、理解，性能优化则是为了让程序运行得更快。重构可以一边写代码一边重构，也可以在程序写完后，拿出一段时间专门去做重构。没有说哪个方式更好，视个人情况而定。\n如果你专门拿一段时间来做重构，建议你在重构一段代码后，立即进行测试。这样可以避免修改代码太多，在出错时找不到错误点。\n重构的原则\n事不过三，三则重构。即不能重复写同样的代码，在这种情况下要去重构。\n如果一段代码让人很难看懂，那就该考虑重构了。\n如果已经理解了代码，但是非常繁琐或者不够好，也可以重构。\n过长的函数，需要重构。\n一个函数最好对应一个功能，如果一个函数被塞入多个功能，那就要对它进行重构了。\n\n重构手法在《重构 2》这本书中，介绍了多达上百个重构手法。但我觉得有两个是比较常用的：\n\n提取重复代码，封装成函数\n拆分太长或功能太多的函数\n\n提取重复代码，封装成函数假设有一个查询数据的接口 /getUserData?age=17&amp;city=beijing。现在需要做的是把用户数据：&#123; age: 17, city: &#39;beijing&#39; &#125; 转成 URL 参数的形式：\nlet result = &quot;&quot;;const keys = Object.keys(data); // &#123; age: 17, city: &#x27;beijing&#x27; &#125;keys.forEach((key) =&gt; &#123;  result += &quot;&amp;&quot; + key + &quot;=&quot; + data[key];&#125;);result.substr(1); // age=17&amp;city=beijing\n\n如果只有这一个接口需要转换，不封装成函数是没问题的。但如果有多个接口都有这种需求，那就得把它封装成函数了：\nfunction JSON2Params(data) &#123;  let result = &quot;&quot;;  const keys = Object.keys(data);  keys.forEach((key) =&gt; &#123;    result += &quot;&amp;&quot; + key + &quot;=&quot; + data[key];  &#125;);  return result.substr(1);&#125;\n\n拆分太长或功能太多的函数假设现在有一个注册功能，用伪代码表示：\nfunction register(data) &#123;  // 1. 验证用户数据是否合法  /**   * 验证账号   * 验证密码   * 验证短信验证码   * 验证身份证   * 验证邮箱   */  // 2. 如果用户上传了头像，则将用户头像转成 base64 码保存  /**   * 新建 FileReader 对象   * 将图片转换成 base64 码   */  // 3. 调用注册接口  // ...&#125;\n\n这个函数包含了三个功能，验证、转换、注册。其中验证和转换功能是可以提取出来单独封装成函数的：\nfunction register(data) &#123;  // 1. 验证用户数据是否合法  // verify()  // 2. 如果用户上传了头像，则将用户头像转成 base64 码保存  // tobase64()  // 3. 调用注册接口  // ...&#125;\n\n如果你对重构有兴趣，强烈推荐你阅读 《重构 2》 这本书。\n","categories":["前端"],"tags":["前端工程化"]},{"title":"实用的 JavaScript 一行代码","url":"/post/671346207db3/","content":"检查日期是否有效const isDateValid = (...val) =&gt; !Number.isNaN(new Date(...val).valueOf())isDateValid(&#x27;Thu Nov 16 2023 15:44:26 GMT+0800&#x27;)  // true\n\n计算两个日期之间的间隔天数const dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)dayDif(new Date(&quot;2023-11-16&quot;), new Date(&quot;2024-1-1&quot;))  // 46\n\n查找日期位于一年中的第几天const dayOfYear = (date) =&gt; Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24)dayOfYear(new Date())  // 307\n\n字符串首字母大写const capitalize = str =&gt; str.charAt(0).toUpperCase() + str.slice(1)capitalize(&quot;hello world&quot;)  // &#x27;Hello world&#x27;\n\n翻转字符串const reverseStr = str =&gt; str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)reverseStr(&#x27;hello world&#x27;)  // &#x27;dlrow olleh&#x27;\n\n生成一个随机字符串const randomString = () =&gt; Math.random().toString(36).slice(2)// randomString()  // &#x27;e3ogdzoa2sh&#x27;\n\n生成一个 UUID 字符串const getUuid = () =&gt; Number(Math.random().toString().substr(2, 5) + Date.now()).toString(36)// getUuid()  // 5agy96in1r00\n\n从指定位置截断字符串const truncateString = (string, length) =&gt; string.length &lt; length ? string : `$&#123;string.slice(0, length)&#125;...`truncateString(&#x27;hello world&#x27;, 3)   // &#x27;hel...&#x27;\n\n去除字符串中的 HTML 标签const stripHtml = html =&gt; (new DOMParser().parseFromString(html, &#x27;text/html&#x27;)).body.textContent || &#x27;&#x27;stripHtml(&#x27;&lt;div&gt;123&lt;/div&gt;&#x27;)  // &#x27;123&#x27;\n\n去除数组中的重复项const myUnique = array =&gt; [...new Set(array)]myUnique([1, 1, 2, 3])  // [1, 2, 3]\n\n获取一组数字的平均值const average = (...args) =&gt; args.reduce((a, b) =&gt; a + b) / args.lengthaverage(1, 2, 3, 4, 5, 6, 7, 8, 9)  // 5\n\n获取指定位数四舍五入的值const myRound = (n, d) =&gt; Number(Math.round(n + &quot;e&quot; + d) + &quot;e-&quot; + d)myRound(1.005, 2)    // 1.01myRound(1.555677, 3) // 1.556\n\nRGB 转化为十六进制const rgbToHex = (r, g, b) =&gt; &quot;#&quot; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1)rgbToHex(255, 255, 255)  // &#x27;#ffffff&#x27;rgbToHex(0, 0, 0)  // &#x27;#000000&#x27;\n\n获取选中的文本const getSelectedText = () =&gt; window.getSelection().toString()getSelectedText()\n\n检测是否是黑暗模式const isDarkMode = window.matchMedia &amp;&amp; window.matchMedia(&#x27;(prefers-color-scheme: dark)&#x27;).matchesconsole.log(isDarkMode)\n\n获取变量的类型const myTypeOf = (data) =&gt; Object.prototype.toString.call(data).slice(8, -1).toLowerCase()// 测试console.log(myTypeOf(1))  // numberconsole.log(myTypeOf(&#x27;1&#x27;)) // stringconsole.log(myTypeOf(true)) // booleanconsole.log(myTypeOf([])) // arrayconsole.log(myTypeOf(&#123;&#125;)) // objectconsole.log(myTypeOf(/^/)) // regexpconsole.log(myTypeOf(new Date())) // dateconsole.log(myTypeOf(Math)) // mathconsole.log(myTypeOf(() =&gt; &#123;&#125;)) // functionconsole.log(myTypeOf()) // undefined\n\n判断对象是否为空const isEmptyObj = obj =&gt; Reflect.ownKeys(obj).length === 0 &amp;&amp; obj.constructor === ObjectisEmptyObj(&#123;&#125;)  // trueisEmptyObj(&#123;xx: 123&#125;)  // false\n\n\n持续完善中 …\n\n","categories":["前端"],"tags":["JavaScript"]},{"title":"实用的 JavaScript 字符串内置方法","url":"/post/60dbe9ddd652/","content":"在 JavaScript 中，字符串是一种常用的数据类型，作为我们开发人员使用最频繁的数据类型之一，本文介绍一些你可能不太了解但又非常实用的字符串内置方法，帮助你提升开发效率，快速完成数据处理。\ncharAt(index)返回指定索引位置的字符。\nconst str = &#x27;Hello, World&#x27;const char = str.charAt(7)console.log(char) // 输出：W\n\ncharCodeAt(index)返回指定索引位置字符的 Unicode 编码。\nconst str = &#x27;Hello, World&#x27;const charCode = str.charCodeAt(7)console.log(charCode) // 输出：87\n\nconcat(str1, str2, …)连接两个或多个字符串。\nconst str1 = &#x27;Hello&#x27;const str2 = &#x27;World&#x27;const result = str1.concat(&#x27;, &#x27;, str2, &#x27;!&#x27;)console.log(result) // 输出：Hello, World!\n\nindexOf(searchValue, startIndex)返回指定字符串在原字符串中首次出现的位置索引。\nconst str = &#x27;Hello, World&#x27;const index = str.indexOf(&#x27;World&#x27;)console.log(index) // 输出：7\n\nlastIndexOf(searchValue, startIndex)返回指定字符串在原字符串中最后一次出现的位置索引。\nconst str = &#x27;Hello, World&#x27;const index = str.lastIndexOf(&#x27;l&#x27;)console.log(index) // 输出：10\n\nslice(startIndex, endIndex)提取字符串的一部分，返回新字符串。\nconst str = &#x27;Hello, World&#x27;const sliced = str.slice(7, 12)console.log(sliced) // 输出：World\n\nsubstring(startIndex, endIndex)与 slice 类似，提取字符串的一部分，返回新字符串。\nconst str = &#x27;Hello, World&#x27;const sub = str.substring(7, 12)console.log(sub) // 输出：World\n\nsubstr(startIndex, length)提取字符串的一部分，返回新字符串，基于起始位置和长度。\nconst str = &#x27;Hello, World&#x27;const sub = str.substr(7, 5)console.log(sub) // 输出：World\n\ntoUpperCase()将字符串转换为大写。\nconst str = &#x27;Hello, World&#x27;const upper = str.toUpperCase()console.log(upper) // HELLO, WORLD\n\ntoLowerCase()将字符串转换为小写。\nconst str = &#x27;Hello, World&#x27;const lower = str.toLowerCase()console.log(lower) // 输出：hello, world\n\nreplace(searchValue, replaceValue)替换字符串中的指定值。\nconst str = &#x27;Hello, World&#x27;const replaced = str.replace(&#x27;World&#x27;, &#x27;Universe&#x27;)console.log(replaced) // 输出：Hello, Universe\n\nsplit(separator, limit)将字符串拆分为子字符串数组。\nconst str = &#x27;apple,orange,banana&#x27;const fruits = str.split(&#x27;,&#x27;)console.log(fruits) // 输出：[&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;]\n\ntrim()去除字符串两端的空格。\nconst str = &#x27;   Hello, World   &#x27;const trimmed = str.trim()console.log(trimmed) // 输出：Hello, World","categories":["前端"],"tags":["JavaScript"]},{"title":"实用的 JavaScript 对象内置方法","url":"/post/486016ae5786/","content":"在 JavaScript 中，对象是一种特殊的数据结构，可以用来存储不同类型的元素。\n作为我们开发人员使用最频繁的数据结构之一，本文介绍一些你可能不太了解但又非常实用的对象内置方法，帮助你提升开发效率，快速完成数据处理。\nObject.keys(obj)\n描述：返回一个包含给定对象所有可枚举属性名称的数组。\n\n用法：\n const myObject = &#123; a: 1, b: 2, c: 3 &#125;;const keysArray = Object.keys(myObject);console.log(keysArray); // 输出: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]\n\nObject.values(obj)\n描述：返回一个包含给定对象所有可枚举属性值的数组。\n\n用法：\n const myObject = &#123; a: 1, b: 2, c: 3 &#125;;const valuesArray = Object.values(myObject);console.log(valuesArray); // 输出: [1, 2, 3]\n\nObject.entries(obj)\n描述：返回一个包含给定对象所有可枚举属性的键值对数组。\n\n用法：\n const myObject = &#123; a: 1, b: 2, c: 3 &#125;;const entriesArray = Object.entries(myObject);console.log(entriesArray); // 输出: [[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]]\n\nObject.assign(target, source1, source2, …)\n描述：将一个或多个源对象的属性复制到目标对象中。\n\n用法：\n const targetObject = &#123; a: 1, b: 2 &#125;;const sourceObject = &#123; b: 3, c: 4 &#125;;const mergedObject = Object.assign(targetObject, sourceObject);console.log(mergedObject); // 输出: &#123; a: 1, b: 3, c: 4 &#125;  // 等同于 &#123; ...targetObject, ...sourceObject &#125;\n\nObject.freeze(obj)\n描述：冻结一个对象，使其属性不可修改。\n\n用法：\n const myObject = &#123; a: 1, b: 2 &#125;;Object.freeze(myObject);myObject.a = 100; // 不会报错，但不会修改成功console.log(myObject); // 输出: &#123; a: 1, b: 2 &#125;\n\nObject.seal(obj)\n描述：密封一个对象，阻止添加新属性并将所有现有属性标记为不可配置。\n\n用法：\n const myObject = &#123; a: 1, b: 2 &#125;;Object.seal(myObject);myObject.c = 3; // 不会报错，但不会添加新属性delete myObject.a; // 不会报错，但不会删除属性console.log(myObject); // 输出: &#123; a: 1, b: 2 &#125;\n\nObject.hasOwnProperty(prop)\n描述：返回一个布尔值，指示对象是否具有指定属性。\n\n用法：\n const myObject = &#123; a: 1, b: 2, c: 3 &#125;;console.log(myObject.hasOwnProperty(&#x27;b&#x27;)); // 输出：trueconsole.log(myObject.hasOwnProperty(&#x27;d&#x27;)); // 输出：false\n\nObject.hasOwn(obj, prop)\n描述：返回一个布尔值，判断对象是否具有指定属性。（跟 Object.hasOwnProperty() 作用一致）\n\n用法：\n const myObject = &#123; a: 1, b: 2, c: 3 &#125;;console.log(Object.hasOwn(myObject, &#x27;a&#x27;)); // 输出：trueconsole.log(Object.hasOwn(myObject, &#x27;d&#x27;)); // 输出：false\n\nObject.getOwnPropertyDescriptor(obj, prop)\n描述：返回一个对象，该对象描述了给定对象上指定属性的配置。\n\n用法：\n const myObject = &#123; a: 1, b: 2 &#125;;const propertyDescriptor = Object.getOwnPropertyDescriptor(myObject, &#x27;a&#x27;);console.log(propertyDescriptor);// 输出: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;\n\nObject.defineProperties(obj, props)\n描述：定义或修改对象的多个属性。\n\n用法：\n const myObject = &#123;&#125;;Object.defineProperties(myObject, &#123;  a: &#123; value: 1, writable: true &#125;,  b: &#123; value: 2, writable: false &#125;,&#125;);console.log(myObject); // 输出: &#123; a: 1, b: 2 &#125;\n\nObject.getPrototypeOf(obj)\n描述：返回指定对象的原型。\n\n用法：\n const myObject = &#123;&#125;;const prototype = Object.getPrototypeOf(myObject);console.log(prototype); // 输出：&#123;&#125;\n\nObject.setPrototypeOf(obj, prototype)\n描述：设置对象的原型（即修改对象的 [[Prototype]] 内部属性）。\n\n用法：\n const myObject = &#123;&#125;;const newPrototype = &#123; a: 1 &#125;;Object.setPrototypeOf(myObject, newPrototype);console.log(myObject.a); // 输出：1\n\nObject.getOwnPropertySymbols(obj)\n描述：返回一个数组，包含给定对象自身的所有符号属性。\n\n用法：\n const mySymbol = Symbol(&#x27;mySymbol&#x27;);const myObject = &#123; a: 1, [mySymbol]: &#x27;symbol&#x27; &#125;;const symbolProperties = Object.getOwnPropertySymbols(myObject);console.log(symbolProperties); // 输出：[Symbol(mySymbol)]\n\nObject.is(obj1, obj2)\n描述：比较两个值是否相同，类似于 === 运算符\n\n用法：\n console.log(Object.is(1, 1)); // 输出：trueconsole.log(Object.is(&#123;&#125;, &#123;&#125;)); // 输出：false，不同的引用\n\n","categories":["前端"],"tags":["JavaScript"]},{"title":"实用的 JavaScript 数组内置方法","url":"/post/5628566fd965/","content":"在 JavaScript 中，数组是一种特殊的数据结构，可以用来存储不同类型的元素。作为我们开发人员使用最频繁的数据结构之一，本文介绍一些你可能不太了解但又非常实用的数组内置方法，帮助你提升开发效率，快速完成数据处理。\nconcat()此方法用于连接两个或多个数组，它不会改变现有的数组，返回的是多个数组连接后一个新数组。\nconst myArray = [1, 2, 3, 4, 5];const myArray2 = [10, 20, 30, 40, 50];myArray.concat(myArray2);// -------&gt; 输出：[1, 2, 3, 4, 5, 10, 20, 30, 40, 50]\n\nfrom()from() 方法用于通过拥有 length 属性的对象或可迭代的对象来返回一个数组。如果对象是数组返回 true，否则返回 false。\n\n用法：Array.from(object, mapFunction, thisValue)object 要转换为数组的对象（必需）mapFunction 数组中每个元素要调用的函数（可选）thisValue 映射函数 (mapFunction) 中的 this 对象（可选）\n\nconst myString = &quot;XPOET&quot;;Array.from(myString);// -------&gt; 输出：[&quot;X&quot;, &quot;P&quot;, &quot;O&quot;, &quot;E&quot;, &quot;T&quot;]const mySet = new Set([&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);Array.from(mySet);// -------&gt; 输出：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]Array.from([1, 2, 3], (x) =&gt; x * 10);// -------&gt; 输出：[10, 20, 30]\n\nreverse()此方法用于反转数组中元素的顺序，使第一个元素成为最后一个，最后一个元素成为第一个。\nconst myArray = [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;];myArray.reverse();// -------&gt; 输出：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]\n\nforEach()此方法用于循环遍历数组中的每个元素，并将元素传递给回调函数。\n\nforEach() 对空数组不执行。\n\nconst myArray = [  &#123; id: 1, name: &quot;Job&quot; &#125;,  &#123; id: 2, name: &quot;Alan&quot; &#125;,  &#123; id: 3, name: &quot;Lily&quot; &#125;,];myArray.forEach((element) =&gt; console.log(element.name));// -------&gt; 输出：Job//               Alan//               Lily\n\nfind()在数组中查找并返回符合条件的元素。如果符合条件的元素有多个，那么只返回第一个元素。如果没有符合条件的元素，则返回 undefined。\n\nfind() 对空数组不执行；不改变数组的原始值。\n\nconst myArray = [  &#123; id: 1, name: &quot;John&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,];myArray.find((element) =&gt; element.id === 2);// -------&gt; 输出：&#123;id: 3, name: &quot;Ali&quot;&#125;myArray.find((element) =&gt; element.id === 5);// -------&gt; 输出：undefined\n\nfindIndex()在数组中查找并返回符合条件的元素的索引（index）。如果符合条件的元素有多个，那么只返回第一个元素的索引（index）。如果没有符合条件的元素，则返回 -1。\n\nfindIndex() 对空数组不执行；不会改变数组的原始值。\n\nconst myArray = [  &#123; id: 1, name: &quot;John&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,];myArray.findIndex((element) =&gt; element.id === 3);// -------&gt; 输出：2myArray.findIndex((element) =&gt; element.id === 7);// -------&gt; 输出：-1\n\nfilter()在数组中过滤出符合条件的所有元素，并返回一个新数组。如果数组中没有符合条件的元素，则返回一个空数组。\n\nfilter() 不改变数组的原始值。\n\nconst myArray = [  &#123; id: 1, name: &quot;John&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,  &#123; id: 4, name: &quot;Mass&quot; &#125;,];myArray.filter((element) =&gt; element.name === &quot;Mass&quot;);// -------&gt; 输出：[&#123;id: 3, name: &quot;Mass&quot;&#125;, &#123;id: 4, name: &quot;Mass&quot;&#125;]\n\nincludes()此方法用于判断数组中是否包含指定的值，如果有返回 true，否则返回 false。\nconst myArray = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, 1, 2, 3, 4, 5];myArray.includes(3);// -------&gt; 输出：truemyArray.includes(8);// -------&gt; 输出：falsemyArray.includes(&quot;A&quot;);// -------&gt; 输出：true\n\nsome()在数组内判断是否有符合条件的元素，只要有一个元素符合条件，则返回 true，否则返回 false。\n\nsome() 对空数组不执行；不改变数组的原始值。\n\nconst myArray = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];myArray.some((item) =&gt; item === &quot;d&quot;);// -------&gt; 输出：truemyArray.some((item) =&gt; item === &quot;h&quot;);// -------&gt; 输出：false\n\nevery()在数组内判断每一个元素是否都符合匹配条件，如果是，返回true，反之则返回 false。\nconst myArray = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];myArray.every((item) =&gt; item === &quot;d&quot;);// -------&gt; 输出：falseconst myArray2 = [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;];myArray2.every((item) =&gt; item === &quot;a&quot;);// -------&gt; 输出：true\n\nsort()此方法对数组内的元素进行排序，并返回排序后的新数组。\nconst myArray = [5, 4, 3, 2, 1];// 升序myArray.sort((a, b) =&gt; a - b);// -------&gt; 输出：[1, 2, 3, 4, 5]// 降序myArray.sort((a, b) =&gt; b - a);// -------&gt; 输出：[5, 4, 3, 2, 1]\n\nmap()循环遍历数组中的每一个元素，并返回一个新数组，新数组中的元素为原始数组元素调用函数处理后的值。\n\nmap() 对空数组不执行；不会改变原始数组。\n\nconst myArray = [5, 4, 3, 2, 1];myArray.map((x) =&gt; x * x);// -------&gt; 输出：[25, 16, 9, 4, 1]\n\nfill()此方法用于把一个固定值来替换数组中的元素（固定值可以是字母、数字、字符串、数组等等），并返回替换后的新数组。\n\n语法：fill(value, start, end)value 参数 1：固定值start 参数 2：开始替换的索引end 参数 3：结束替换的索引\n\nconst myArray = [1, 2, 3, 4, 5];myArray.fill(&quot;A&quot;, 1, 3);// -------&gt; 输出：[1, &quot;A&quot;, &quot;A&quot;, 4, 5]\n\nreduce()reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。\n\n语法：reduce(function(total, currentValue, currentIndex, array), initialValue)total 初始值，或者计算结束后的返回值（必需）currentValue 当前元素（必需）currentIndex 当前元素的索引（可选）array 当前元素所属的数组对象（可选）\n\nconst myArray = [1, 2, 3, 4, 5];myArray.reduce((total, value) =&gt; total * value);// 1 * 2 * 3 * 4 * 5// -------&gt; 输出：120\n\nflat()flat() 方法用于数组扁平化处理，即把数组中多维数组降维，最后返回降维后新数组。\n\n用法：flat(depth)depth 表示要降维的深度 (可选，默认为 1)\n\nconst myArray = [1, 2, [3, 4, 5, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]]];myArray.flat();// -------&gt; 输出：[[1, 2, 3, 4, 5, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]]myArray.flat(2);// -------&gt; 输出：[1, 2, 3, 4, 5, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;]\n\nflatMap()该方法将函数应用于数组的每个元素，然后将结果压缩为一个新数组。该方法结合了 flat() 和 map()。\nconst myArray = [[1], [2], [3], [4], [5]];myArray.flatMap((arr) =&gt; arr * 10);// -------&gt; 输出：[10, 20, 30, 40, 50]// 等同于：myArray.flat().map((arr) =&gt; arr * 10);// -------&gt; 输出：[10, 20, 30, 40, 50]\n","categories":["前端"],"tags":["JavaScript"]},{"title":"实用的 JavaScript 正则表达式","url":"/post/5acdfa458cc9/","content":"此文收录在日常开发及各种业务场景下常用的正则表达式，持续更新…\n正则表达式正则表达式（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。\n正则表达式是一种强大的文本匹配和处理工具，它在处理字符串、表单验证、文本搜索等场景中都发挥着重要的作用。\n语法/正则表达式主体/修饰符(可选)\n\neg:const RE = /xpoet/i;解析：/xpoet/i 是一个正则表达式xpoet 是一个正则表达式主体 (用于检索)i 是一个修饰符 (搜索不区分大小写)\n\n常用的匹配规则验证数字验证整数或带小数点的数字\nconst regex = /^-?\\d+(\\.\\d+)?$/console.log(regex.test(1))  // trueconsole.log(regex.test(-1))  // trueconsole.log(regex.test(1.1))  // trueconsole.log(regex.test(&#x27;1a&#x27;))  // false\n\n验证邮箱验证字符串是否符合邮箱格式\nconst regex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]&#123;2,4&#125;$/console.log(regex.test(&#x27;example@email.com&#x27;))  // trueconsole.log(regex.test(&#x27;example#email.com&#x27;))  // false\n\n验证汉字验证字符串是否只包含汉字。[\\u4e00-\\u9fa5] 匹配汉字的 Unicode 范围。\nconst regex = /^[\\u4e00-\\u9fa5]+$/console.log(regex.test(&#x27;中文&#x27;))  // trueconsole.log(regex.test(&#x27;Chinese&#x27;))  // falseconsole.log(regex.test(&#x27;123&#x27;))  // false\n\n验证英文验证字符串是否只包含英文。\nconst regex = /^[a-zA-Z]+$/console.log(regex.test(&#x27;中文&#x27;))  // falseconsole.log(regex.test(&#x27;Chinese&#x27;))  // trueconsole.log(regex.test(&#x27;123&#x27;))  // false\n\n验证网址const regex = /^(https?:\\/\\/)?([a-zA-Z0-9-]+\\.)&#123;1,&#125;([a-zA-Z]&#123;2,&#125;)(\\/[^\\s]*)?$/console.log(regex.test(&#x27;https://www.example.com&#x27;))  // trueconsole.log(regex.test(&#x27;https://example&#x27;))  // false\n\n验证手机号const regex = /^1[3456789]\\d&#123;9&#125;$/console.log(regex.test(13000000000))  // trueconsole.log(regex.test(12000000000))  // false\n\n验证身份证号码验证身份证号码的格式，支持 15 位和 18 位身份证号码。\nconst regex = /(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)/console.log(regex.test(&#x27;440101200001011000&#x27;))  // trueconsole.log(regex.test(&#x27;4400000000&#x27;))  // false\n\n验证图片格式const regex = /(png|jpg|jpeg|gif|webp|awebp|bmp|avif|svg\\+xml|svg|x-icon)$/iconsole.log(regex.test(&#x27;image.jpg&#x27;))  // trueconsole.log(regex.test(&#x27;image.png&#x27;))  // trueconsole.log(regex.test(&#x27;image.png1&#x27;))  // false\n\n验证 IPv4 地址const regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/console.log(regex.test(&#x27;192.168.1.1&#x27;))    // trueconsole.log(regex.test(&#x27;192.168.1&#x27;))      // trueconsole.log(regex.test(&#x27;192.168.1.257&#x27;))  // false\n\n验证十六进制颜色验证 RGB Hex 颜色\nconst regex = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/console.log(regex.test(&#x27;#000&#x27;))     // trueconsole.log(regex.test(&#x27;#0000&#x27;))    // false\n\n验证 QQ 号验证 QQ 号，5 ~ 11 位数\nconst regex = /^[1-9][0-9]&#123;4,10&#125;$/console.log(regex.test(10000))     // trueconsole.log(regex.test(00000))     // false\n\n\n验证车牌号验证 QQ 号，5 ~ 11 位数\nconst regex = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$/console.log(regex.test(&#x27;粤B99999&#x27;))     // trueconsole.log(regex.test(&#x27;粤B9999&#x27;))     // false\n","categories":["前端"],"tags":["JavaScript","正则表达式"]},{"title":"常考的 JavaScript 手写题","url":"/post/9b7700b386a6/","content":"现在的前端招聘圈，对前端程序员的能力要求真的是越来越高了（内卷真的太厉害了），出去找工作面试，哪怕是家小公司，大概率都会考一些 JS 手写题，你不会但别人会，自然就被卷死了。\n其实，对一个前端工程师来说，JS 本就重中之重，我们要掌握的可不仅仅是这些手写题。  \n当然，你不会这些手写题也不能代表你的 JS 编程能力不好，我觉得那是因为你不熟悉而已。\n\n\n现在就跟着作者来一步一步学习，彻底搞懂这些常考的 JS 手写题，无论是在业务开发还是求职面试中都很实用。\n\n截止目前，市面上超过 98% 的浏览器支持 ES6，ES6 (ECMAScript 2015) 都已经是 2015 年的标准了，所以这些手写题里面能使用 ES6 实现的均采用 ES6 实现。以下的每一道手写题，都经过作者反复检验，也配备了测试代码，小伙伴放心大胆学起来。\n如发现错误或者有更好的实现方式，欢迎大家指正。\n\n代码仓库：https://github.com/XPoet/handwriting-js\n\n手写类型判断const myTypeOf = (data) =&gt; Object.prototype.toString.call(data).slice(8, -1).toLowerCase()// 测试console.log(myTypeOf(1)) //--&gt; numberconsole.log(myTypeOf(&#x27;1&#x27;)) //--&gt; stringconsole.log(myTypeOf(true)) //--&gt; booleanconsole.log(myTypeOf([])) //--&gt; arrayconsole.log(myTypeOf(&#123;&#125;)) //--&gt; objectconsole.log(myTypeOf(/^/)) //--&gt; regexpconsole.log(myTypeOf(new Date())) //--&gt; dateconsole.log(myTypeOf(Math)) //--&gt; mathconsole.log(myTypeOf(() =&gt; &#123;&#125;)) //--&gt; function\n\n手写数组去重const myUnique = array =&gt; [...new Set(array)]// 测试console.log(myUnique([1, 1, 2, 3])) //--&gt; [1, 2, 3]\n\n手写 Ajax 的 GET 方法function myAjaxGet(url) &#123;  // 创建一个 Promise 对象  return new Promise(function(resolve, reject) &#123;    const xhr = new XMLHttpRequest()    // 新建一个 http 请求    xhr.open(&#x27;GET&#x27;, url, true)    // 设置响应的数据类型    xhr.responseType = &#x27;json&#x27;    // 设置请求头信息    xhr.setRequestHeader(&#x27;Accept&#x27;, &#x27;application/json&#x27;)    // 设置状态的监听函数    xhr.onreadystatechange = function() &#123;      if (this.readyState !== 4) return      // 当请求成功或失败时，改变 Promise 的状态      if (this.status === 200) &#123;        resolve(this.response)      &#125; else &#123;        reject(new Error(this.statusText))      &#125;    &#125;    // 设置错误监听函数    xhr.onerror = function() &#123;      reject(new Error(this.statusText))    &#125;    // 发送 http 请求    xhr.send(null)  &#125;)&#125;// 测试myAjaxGet(&#x27;https://api.github.com/users/XPoet&#x27;).then(res =&gt; &#123;  console.log(&#x27;res: &#x27;, res) //--&gt; &#123;...&#125;&#125;)\n\n手写函数节流定义：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。\n使用场景：窗口 resize、scroll、输入框 input、频繁点击等\n/** * @param fn 需要执行的函数 * @param delay 间隔时间 */const throttle = (fn, delay = 1000) =&gt; &#123;  // 上一次执行 fn 的时间  let prevTime = 0  // 将 throttle 处理结果当作函数返回  return function(...args) &#123;    // 获取当前时间，转换成时间戳，单位毫秒 ms    const nowTime = Date.now()    // 将当前时间和上一次执行函数的时间进行对比    // 大于间隔时间就把 prevTime 设置为当前时间并执行函数 fn    if (nowTime - prevTime &gt; delay) &#123;      prevTime = nowTime      fn.apply(this, args)    &#125;  &#125;&#125;// 测试const testFn = throttle(() =&gt; &#123;  console.log(&#x27;函数节流测试 - fn 执行了&#x27;)&#125;, 1000)// 定时器每 100 毫秒执行一次 testFn 函数，但是只有间隔时间差大于 1000 毫秒时才会执行 fnsetInterval(testFn, 100) //--&gt; 函数节流测试 - fn 执行了\n\n手写函数防抖定义：在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。使用场景：搜索框输入搜索、点击提交等\nfunction debounce(fn, wait) &#123;  let timer = null  return function(...args) &#123;    const ctx = this    // 如果此时存在定时器的话，则取消之前的定时器重新记时    if (timer) &#123;      clearTimeout(timer)      timer = null    &#125;    // 设置定时器，使事件间隔指定事件后执行    timer = setTimeout(() =&gt; &#123;      fn.apply(ctx, args)    &#125;, wait)  &#125;&#125;// 测试const testFn = debounce(() =&gt; &#123;  console.log(&#x27;函数防抖测试 - fn 执行了&#x27;)&#125;, 2000)// 定时器每 1000 毫秒执行一次 testFn 函数，等待时间未大于 2000 毫秒，所以 fn 永远不会执行setInterval(testFn, 1000)// 定时器每 3000 毫秒执行一次 testFn 函数，等待时间大于 2000 毫秒，所以 fn 会隔 3000 执行一次setInterval(testFn, 3000) //--&gt; 函数防抖测试 - fn 执行了\n\n手写深浅拷贝浅拷贝function shallowCopy(object) &#123;  // 只拷贝对象类型的数据  if (!object || typeof object !== &#x27;object&#x27;) return  // object 如果是数组类型就新建一个空数组，否则新建空对象  const newObject = Array.isArray(object) ? [] : &#123;&#125;  // 遍历 object，进行属性拷贝  for (const key in object) &#123;    if (object.hasOwnProperty(key)) &#123;      newObject[key] = object[key]    &#125;  &#125;  return newObject&#125;// 测试const obj1 = &#123; x: 1, y: 2, z: 3 &#125;const obj2 = shallowCopy(obj1)console.log(obj2) //--&gt; &#123; x: 1, y: 2, z: 3 &#125;const arr1 = [1, 2, 3]const arr2 = shallowCopy(arr1)console.log(arr2) //--&gt; [1, 2, 3]\n\n\n深拷贝function deepCopy(object) &#123;  // 只拷贝对象类型的数据  if (!object || typeof object !== &#x27;object&#x27;) return  // object 如果是数组类型就新建一个空数组，否则新建空对象  const newObject = Array.isArray(object) ? [] : &#123;&#125;  for (const key in object) &#123;    if (object.hasOwnProperty(key)) &#123;      // object[key] 如果是对象类型，则使用递归继续遍历拷贝属性      newObject[key] = typeof object[key] === &#x27;object&#x27; ? deepCopy(object[key]) : object[key]    &#125;  &#125;  return newObject&#125;// 测试const obj1 = &#123; x: 1, y: &#123; z: 3 &#125; &#125;const obj2 = deepCopy(obj1)console.log(obj2) //--&gt; &#123; x: 1, y: &#123; z: 3 &#125; &#125;const arr1 = [1, [2, 3]]const arr2 = deepCopy(arr1)console.log(arr2) //--&gt; [1, [2, 3]]\n\n手写 call、apply 和 bind 函数在 JavaScript 中，call、apply 和 bind 是 Function 对象自带的三个方法，这三个方法的主要作用是改变函数中的 this 指向。\n共同点：\n\napply 、 call 、bind 三者都是用来改变函数的 this 对象指向。\napply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文。（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context），这就是 this 关键字的值。）\napply 、 call 、bind 三者都可以利用后续参数传参。\n\n区别：\n\nbind 是返回对应函数，便于稍后调用。\napply 、call 则是立即调用。\n\ncall() 和 apply() 的作用是一样的，都是用于改变 this 的指向，区别在于 call 接受多个参数，而 apply 接受的是一个数组。\n第一个参数的取值有以下 4 种情况：\n\n不传，或者传 null、undefined，函数中的 this 指向 window 对象。\n传递另一个函数的函数名，函数中的 this 指向这个函数的引用。\n传递字符串、数值或布尔类型等基础类型，函数中的 this 指向其对应的包装对象，如 String、Number、Boolean。\n传递一个对象，函数中的 this 指向这个对象。\n\nfunction a() &#123;  console.log(this)&#125;function b() &#123;&#125;const c = &#123; x: 1 &#125;a.call() //--&gt; windowa.call(null) //--&gt; windowa.call(undefined) //windowa.call(1) //--&gt; Number &#123;1&#125;a.call(&#x27;&#x27;) //--&gt; String &#123;&#x27;&#x27;&#125;a.call(true) //--&gt; Boolean &#123;true&#125;a.call(b) //--&gt; function b()&#123;&#125;a.call(c) //--&gt; &#123;x: 1&#125;\n\n手写 callcall 函数的实现步骤：\n\n判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n判断传入上下文对象是否存在，如果不存在，则设置为 window。\n将函数作为上下文对象的一个属性。\n使用上下文对象来调用这个方法，并保存返回结果。\n删除刚才新增的属性。\n返回结果。\n\nFunction.prototype.myCall = function(ctx, ...args) &#123;  // 判断调用对象  if (typeof this !== &#x27;function&#x27;) &#123;    throw new TypeError(&#x27;Type Error&#x27;)  &#125;  // 判断 ctx 是否传入，如果未传入则设置为 window  ctx = ctx || window  // 将调用函数设为对象的方法  ctx.fn = this  // 调用函数  const result = ctx.fn(...args)  // 将属性删除  delete ctx.fn  return result&#125;// 测试const obj = &#123;  test(a, b, c) &#123;    console.log(this, a, b)  &#125;&#125;obj.test.myCall(obj, 4, 5) //--&gt; &#123;test: ƒ, fn: ƒ&#125; 4 5\n\n手写 apply\n判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n判断传入上下文对象是否存在，如果不存在，则设置为 window。\n将函数作为上下文对象的一个属性。\n判断参数值是否传入。\n使用上下文对象来调用这个方法，并保存返回结果。\n删除刚才新增的属性。\n返回结果。\n\nFunction.prototype.myApply = function(ctx) &#123;  // 判断调用对象是否为函数  if (typeof this !== &#x27;function&#x27;) &#123;    throw new TypeError(&#x27;Type Error&#x27;)  &#125;  let result = null  // 判断 ctx 是否存在，如果未传入则为 window  ctx = ctx || window  // 将函数设为对象的方法  ctx.fn = this  // 调用方法  if (arguments[1]) &#123;    result = ctx.fn(...arguments[1])  &#125; else &#123;    result = ctx.fn()  &#125;  // 将属性删除  delete ctx.fn  return result&#125;// 测试const obj = &#123;  test(a, b, c) &#123;    console.log(this, a, b, c)  &#125;&#125;obj.test.myApply(obj, [4, 5, 6]) //--&gt; &#123;test: ƒ, fn: ƒ&#125; 4 5 6\n\n手写 bind\n判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n保存当前函数的引用，获取其余传入参数值。\n创建一个函数返回。\n函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n\nFunction.prototype.myBind = function(ctx, ...args) &#123;  // 判断调用对象是否为函数  if (typeof this !== &#x27;function&#x27;) &#123;    throw new TypeError(&#x27;Type Error&#x27;)  &#125;  const fn = this  return function Fn() &#123;    // 根据调用方式，传入不同绑定值    return fn.apply(      this instanceof Fn ? this : ctx, args.concat(...arguments)    )  &#125;&#125;// 测试const obj = &#123;  test(a, b, c) &#123;    console.log(this, a + b)  &#125;&#125;obj.test.myBind(obj, 4, 5)() //--&gt; &#123;test: ƒ&#125; 9\n\n函数柯里化函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。例如：add(1, 2, 3, 4, 5) 转换成 add(1)(2)(3)(4)(5)\nfunction curry(fn, ...args) &#123;  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args)&#125;// 测试// 普通函数function fn(a, b, c, d, e) &#123;  console.log(a, b, c, d, e)&#125;// 生成的柯里化函数const _fn = curry(fn)_fn(1, 2, 3, 4, 5) //--&gt; 1 2 3 4 5_fn(1)(2)(3, 4, 5) //--&gt; 1 2 3 4 5_fn(1, 2)(3, 4)(5) //--&gt; 1 2 3 4 5_fn(1)(2)(3)(4)(5) //--&gt; 1 2 3 4 5\n看起来柯里化好像是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。而这里对于函数参数的自由处理，正是柯里化的核心所在。柯里化本质上是降低通用性，提高适用性。\n手写 EventBus/** * 手写 EventBus */class EventBus &#123;  constructor() &#123;    // 存储事件及其对应的回调函数    this.events = &#123;&#125;  &#125;  // 订阅事件  subscribe(eventName, callback) &#123;    // 如果事件不存在，则创建一个新的事件数组    if (!this.events[eventName]) &#123;      this.events[eventName] = []    &#125;    // 将回调函数添加到事件数组中    this.events[eventName].push(callback)  &#125;  // 取消订阅事件  unsubscribe(eventName, callback) &#123;    // 如果事件不存在，则直接返回    if (!this.events[eventName]) &#123;      return    &#125;    // 从事件数组中移除指定的回调函数    this.events[eventName] = this.events[eventName].filter(cb =&gt; cb !== callback)  &#125;  // 发布事件  next(eventName, data) &#123;    // 如果事件不存在，则直接返回    if (!this.events[eventName]) &#123;      return    &#125;    // 遍历事件数组，依次执行回调函数    this.events[eventName].forEach(callback =&gt; &#123;      callback(data)    &#125;)  &#125;&#125;// 创建一个新的 EventBus 实例const eventBus = new EventBus()// 定义事件处理函数const handler1 = data =&gt; &#123;  console.log(&#x27;Handler 1:&#x27;, data)&#125;const handler2 = data =&gt; &#123;  console.log(&#x27;Handler 2:&#x27;, data)&#125;// 订阅事件eventBus.subscribe(&#x27;event1&#x27;, handler1)eventBus.subscribe(&#x27;event1&#x27;, handler2)// 发布事件eventBus.next(&#x27;event1&#x27;, &#x27;Hello, EventBus!&#x27;)// 取消订阅事件eventBus.unsubscribe(&#x27;event1&#x27;, handler2)\n\n手写 PromisePromise 是异步编程的一种解决方案，比传统的解决方案回调函数和事件更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise  对象。\n所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n下面我们用 ES6 语法来手写一个 Promise：\nclass MyPromise &#123;  // Promise/A+ 规范规定的三种状态  PENDING = &#x27;pending&#x27; // 等待状态  FULFILLED = &#x27;fulfilled&#x27;// 成功状态  REJECTED = &#x27;rejected&#x27; // 失败状态  // 构造函数接收一个执行回调  constructor(executor) &#123;    this._status = this.PENDING // Promise 初始状态    this._value = undefined // then 回调的值    this._resolveQueue = [] // resolve 时触发的成功队列    this._rejectQueue = [] // reject 时触发的失败队列    // 使用箭头函数固定 this（resolve 函数在 executor 中触发，不然找不到 this）    const resolve = value =&gt; &#123;      const run = () =&gt; &#123;        // Promise/A+ 规范规定的 Promise 状态只能从 pending 触发，变成 fulfilled        if (this._status === this.PENDING) &#123;          this._status = this.FULFILLED // 更改状态          this._value = value // 储存当前值，用于 then 回调          // 执行 resolve 回调          while (this._resolveQueue.length) &#123;            const callback = this._resolveQueue.shift()            callback(value)          &#125;        &#125;      &#125;      // 把 resolve 执行回调的操作封装成一个函数，放进 setTimeout 里，以实现 Promise 异步调用的特性（规范上是微任务，这里是宏任务）      setTimeout(run)    &#125;    // 同 resolve    const reject = value =&gt; &#123;      const run = () =&gt; &#123;        if (this._status === this.PENDING) &#123;          this._status = this.REJECTED          this._value = value          while (this._rejectQueue.length) &#123;            const callback = this._rejectQueue.shift()            callback(value)          &#125;        &#125;      &#125;      setTimeout(run)    &#125;    // new Promise() 时立即执行 executor，并传入 resolve 和 reject    executor(resolve, reject)  &#125;  // then 方法，接收一个成功的回调和一个失败的回调  then(onFulfilled, onRejected) &#123;    // 根据规范，如果 then 的参数不是 function，则忽略它，让值继续往下传递，链式调用继续往下执行    typeof onFulfilled !== &#x27;function&#x27; ? onFulfilled = value =&gt; value : null    typeof onRejected !== &#x27;function&#x27; ? onRejected = error =&gt; error : null    // then 返回一个新的 Promise    return new MyPromise((resolve, reject) =&gt; &#123;      const resolveFn = value =&gt; &#123;        try &#123;          const x = onFulfilled(value)          // 分类讨论返回值，如果是 Promise，那么等待 Promise 状态变更，否则直接 resolve          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)        &#125; catch (error) &#123;          reject(error)        &#125;      &#125;      const rejectFn = error =&gt; &#123;        try &#123;          const x = onRejected(error)          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)        &#125; catch (error) &#123;          reject(error)        &#125;      &#125;      switch (this._status) &#123;        case this.PENDING:          this._resolveQueue.push(resolveFn)          this._rejectQueue.push(rejectFn)          break        case this.FULFILLED:          resolveFn(this._value)          break        case this.REJECTED:          rejectFn(this._value)          break      &#125;    &#125;)  &#125;  catch(onRejected) &#123;    return this.then(null, onRejected)  &#125;  finally(callback) &#123;    return this.then(value =&gt; MyPromise.resolve(callback()).then(() =&gt; value), error =&gt; &#123;      MyPromise.resolve(callback()).then(() =&gt; error)    &#125;)  &#125;  // 静态 resolve 方法  static resolve(value) &#123;    return value instanceof MyPromise ? value : new MyPromise(resolve =&gt; resolve(value))  &#125;  // 静态 reject 方法  static reject(error) &#123;    return new MyPromise((resolve, reject) =&gt; reject(error))  &#125;  // 静态 all 方法  static all(promiseArr) &#123;    let count = 0    let result = []    return new MyPromise((resolve, reject) =&gt; &#123;      if (!promiseArr.length) &#123;        return resolve(result)      &#125;      promiseArr.forEach((p, i) =&gt; &#123;        MyPromise.resolve(p).then(value =&gt; &#123;          count++          result[i] = value          if (count === promiseArr.length) &#123;            resolve(result)          &#125;        &#125;, error =&gt; &#123;          reject(error)        &#125;)      &#125;)    &#125;)  &#125;  // 静态 race 方法  static race(promiseArr) &#123;    return new MyPromise((resolve, reject) =&gt; &#123;      promiseArr.forEach(p =&gt; &#123;        MyPromise.resolve(p).then(value =&gt; &#123;          resolve(value)        &#125;, error =&gt; &#123;          reject(error)        &#125;)      &#125;)    &#125;)  &#125;&#125;// 测试function fn() &#123;  return new MyPromise((resolve, reject) =&gt; &#123;    if (Math.random() &gt; 0.5) &#123;      setTimeout(() =&gt; &#123;        resolve(`resolve ***`)      &#125;, 500)    &#125; else &#123;      setTimeout(() =&gt; &#123;        reject(`reject ***`)      &#125;, 500)    &#125;  &#125;)&#125;fn().then(res =&gt; &#123;  console.log(&#x27;resolve value: &#x27;, res)&#125;).catch(err =&gt; &#123;  console.log(&#x27;reject value: &#x27;, err)&#125;)\n\n手写 JSONPfunction jsonp(url, params, callback) &#123;  // 判断是否含有参数  let queryString = url.indexOf(&#x27;?&#x27;) === &#x27;-1&#x27; ? &#x27;?&#x27; : &#x27;&amp;&#x27;;  // 添加参数  for (var k in params) &#123;    if (params.hasOwnProperty(k)) &#123;      queryString += k + &#x27;=&#x27; + params[k] + &#x27;&amp;&#x27;;    &#125;  &#125;  // 处理回调函数名  let random = Math.random().toString().replace(&#x27;.&#x27;, &#x27;&#x27;),    callbackName = &#x27;myJsonp&#x27; + random;  // 添加回调函数  queryString += &#x27;callback=&#x27; + callbackName;  // 构建请求  let scriptNode = document.createElement(&#x27;script&#x27;);  scriptNode.src = url + queryString;  window[callbackName] = function () &#123;    // 调用回调函数    callback(...arguments);    // 删除这个引入的脚本    document.getElementsByTagName(&#x27;head&#x27;)[0].removeChild(scriptNode);  &#125;;  // 发起请求  document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(scriptNode);&#125;\n\n手写观察者模式var events = (function () &#123;  var topics = &#123;&#125;;  return &#123;    // 注册监听函数    subscribe: function (topic, handler) &#123;      if (!topics.hasOwnProperty(topic)) &#123;        topics[topic] = [];      &#125;      topics[topic].push(handler);    &#125;,    // 发布事件，触发观察者回调事件    publish: function (topic, info) &#123;      if (topics.hasOwnProperty(topic)) &#123;        topics[topic].forEach(function (handler) &#123;          handler(info);        &#125;);      &#125;    &#125;,    // 移除主题的一个观察者的回调事件    remove: function (topic, handler) &#123;      if (!topics.hasOwnProperty(topic)) return;      var handlerIndex = -1;      topics[topic].forEach(function (item, index) &#123;        if (item === handler) &#123;          handlerIndex = index;        &#125;      &#125;);      if (handlerIndex &gt;= 0) &#123;        topics[topic].splice(handlerIndex, 1);      &#125;    &#125;,    // 移除主题的所有观察者的回调事件    removeAll: function (topic) &#123;      if (topics.hasOwnProperty(topic)) &#123;        topics[topic] = [];      &#125;    &#125;  &#125;;&#125;)();\n\n","categories":["前端"],"tags":["JavaScript"]},{"title":"快速掌握 Vue 3.0 基础语法","url":"/post/c8069422dc20/","content":"经过两年多的迭代，Vue 3.0 终于在 9 月 18 日 发布了正式版，底层使用 TypeScript 进行大规模重构，有着很大的改变。Vue 3.0 采用 Composition API，类似 React Hook，使用更加灵活。\nVue 2.x 与 Vue 3.0 的对比\nVue 2 对 TypeScript 支持不友好，所有属性都放在 this 对象上，难以推断出数据类型。\nVue 2 大量的 API 挂载在 Vue 对象的原型上，难以实现 tree shaking。\nVue 2 架构层面对跨平台 DOM 渲染开发支持不友好。\nVue 3 采用 Composition API，受 React Hook 启发。\nVue 3 更好地支持 JSX。\nVue 3 的 Template 支持多个根标签，Vue 2.x 不支持。\nVue 3 对虚拟 DOM 进行了重写、对模板的编译进行了优化。\n…\n\nsetup() 函数setup() 是 Vue 3.0 专门为组件提供的新属性。它为我们使用 Vue 3.0 的 Composition API 新特性提供了统一的入口，setup() 在 beforeCreate() 之后和 created() 之前执行，Vue 3.0 取消了这两个 2.x 版本的生命周期钩子函数，统一用 setup() 代替，该函数相当于一个生命周期函数，Vue 2.x 中的 data，methods，watch 等全部都用对应的新增 API 写在 setup() 中。\nsetup(props, context) &#123;    // context.attrs    // context.slots    // context.parent    // context.root    // context.emit    // context.refs    return &#123;    &#125;  &#125;\n\n\nprops 用来接收 props 数据。\ncontext 用来定义上下文，上下文对象中包含了一些有用的属性，这些属性在 Vue 2.x 中需要通过 this 才能访问到，但在 setup() 中无法访问到 this。\nreturn &#123;&#125; 返回值，返回的是响应式数据，template 模版中需要使用的函数。\n\nreactive() 函数reactive() 接收一个普通对象，返回一个响应式的数据对象，响应式数据对象创建出来之后，在 setup() 中 return 出去，即可在 template 中使用。\n&lt;template&gt; &#123;&#123; name &#125;&#125; &lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, reactive, ref, toRefs &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    setup(props, context) &#123;      const person = reactive(&#123;        name: &quot;zhangsan&quot;,        age: 18,      &#125;);      return person;    &#125;,  &#125;);&lt;/script&gt;\n\nref() 函数ref() 用来根据给定的值创建一个响应式的数据对象，ref() 调用的返回值是一个对象，这个对象上只包含一个 value 属性，只在 setup() 函数内部获取 ref() 对象的值需要加上 .value。\n&lt;template&gt;  &lt;div class=&quot;mine&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, ref &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    setup() &#123;      const count = ref&lt;number&gt;(10);      console.log(count.value);      return &#123;        count,      &#125;;    &#125;,  &#125;);&lt;/script&gt;\n\n在 reactive() 对象中访问 ref() 创建的响应式数据对象时，不需要加 .value。\n&lt;template&gt;  &lt;div class=&quot;mine&quot;&gt;&#123;&#123; count &#125;&#125; - &#123;&#123; n &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, reactive, ref, toRefs &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    setup() &#123;      const count = ref&lt;number&gt;(10);      const obj = reactive(&#123;        n: 100,        count,      &#125;);      // 通过 reactive 来获取 ref 的值时，不需要使用 .value 属性      console.log(obj.count); // 10      return &#123;        ...toRefs(obj),      &#125;;    &#125;,  &#125;);&lt;/script&gt;\n\nisRef() 函数isRef() 用来判断某个值是否为 ref() 创建出来的对象。\nimport &#123; defineComponent, isRef, ref &#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup(props, context) &#123;    const name: string = &quot;vue&quot;;    const age = ref&lt;number&gt;(18);    console.log(isRef(age)); // true    console.log(isRef(name)); // false    return &#123;      age,      name,    &#125;;  &#125;,&#125;);\n\ntoRefs() 函数toRefs() 可以将 reactive() 创建出来的响应式对象，转换为普通的对象，这个普通对象上的每个属性节点，都是 ref() 类型的响应式数据。\n&lt;template&gt;  &lt;div class=&quot;mine&quot;&gt;&#123;&#123; name &#125;&#125; &#123;&#123; age &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, reactive, ref, toRefs &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    setup(props, context) &#123;      const person = reactive(&#123;        name: &quot;zhangsan&quot;,      &#125;);      const age = ref(18);      return &#123;        ...toRefs(person),        age,      &#125;;    &#125;,  &#125;);&lt;/script&gt;\n\ncomputed() 函数computed() 用来创建计算属性，和前面一样，它返回的值是一个 ref() 对象。里面可以传方法，或者对象，对象中包含 set()、get() 方法。\n创建只读的计算属性import &#123; computed, defineComponent, ref &#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup(props, context) &#123;    const age = ref(18);    // 根据 age 的值，创建一个响应式的计算属性 readOnlyAge，它会根据依赖的 ref 自动计算并返回一个新的 ref    const readOnlyAge = computed(() =&gt; age.value++); // 19    return &#123;      age,      readOnlyAge,    &#125;;  &#125;,&#125;);\n\n通过 set()、get() 方法创建一个可读可写的计算属性import &#123; computed, defineComponent, ref &#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup(props, context) &#123;    const age = ref&lt;number&gt;(18);    const computedAge = computed(&#123;      get: () =&gt; age.value + 1,      set: (value) =&gt; age.value + value,    &#125;);    // 为计算属性赋值的操作，会触发 set 函数，触发 set 函数后，age 的值会被更新    age.value = 100;    return &#123;      age,      computedAge,    &#125;;  &#125;,&#125;);\n\nwatch() 函数watch() 用来监听特定的数据源，并在回调函数中返回。默认情况是懒执行的，仅在监听的源数据变更时才执行回调。\n监听 reactive() 创建的数据源import &#123; computed, defineComponent, reactive, toRefs, watch &#125; from &quot;vue&quot;;interface Person &#123;  name: string;  age: number;&#125;export default defineComponent(&#123;  setup(props, context) &#123;    const person = reactive&lt;Person&gt;(&#123; name: &quot;vue&quot;, age: 10 &#125;);    watch(      () =&gt; person.age,      (newValue, oldValue) =&gt; &#123;        console.log(newValue); // 100        console.log(oldValue); // 10      &#125;    );    // 修改 age 时会触发 watch 的回调，打印出改变前后的值    person.age = 100;    return &#123;      ...toRefs(person),    &#125;;  &#125;,&#125;);\n\n监听用 ref() 创建的数据源import &#123; defineComponent, ref, watch &#125; from &quot;vue&quot;;interface Person &#123;  name: string;  age: number;&#125;export default defineComponent(&#123;  setup(props, context) &#123;    const age = ref&lt;number&gt;(10);    watch(age, (oldValue, newValue) =&gt; &#123;      console.log(&quot;oldValue: &quot;, oldValue); // 10      console.log(&quot;newValue: &quot;, newValue); // 100    &#125;);    // 修改 age 时会触发 watch 的回调，打印变更后的值    age.value = 100;    return &#123;      age,    &#125;;  &#125;,&#125;);\n\n同时监听多个值import &#123; computed, defineComponent, reactive, toRefs, watch &#125; from &quot;vue&quot;;interface Person &#123;  name: string;  age: number;&#125;export default defineComponent(&#123;  setup(props, context) &#123;    const state = reactive&lt;Person&gt;(&#123; name: &quot;zhangsan&quot;, age: 10 &#125;);    watch(      [() =&gt; state.age, () =&gt; state.name],      ([newAge, newName], [oldAge, oldName]) =&gt; &#123;        console.log(newAge);        console.log(newName);        console.log(oldAge);        console.log(oldName);      &#125;    );    // 修改 state 时会触发 watch 的回调，打印变更前后的值，此时需要注意，更改其中一个值，都会执行 watch 的回调    state.age = 100;    state.name = &quot;lisi&quot;;    return &#123;      ...toRefs(state),    &#125;;  &#125;,&#125;);\n\nstop 停止监听在 setup() 内创建的 watch() 监视，会在当前组件被销毁的时候自动停止。如果想要明确地停止某个监听，可以调用 watch() 的返回值即可。\nimport &#123; computed, defineComponent, reactive, toRefs, watch &#125; from &quot;vue&quot;;interface Person &#123;  name: string;  age: number;&#125;export default defineComponent(&#123;  setup(props, context) &#123;    const state = reactive&lt;Person&gt;(&#123; name: &quot;zhangsan&quot;, age: 10 &#125;);    const stop = watch(      [() =&gt; state.age, () =&gt; state.name],      ([newAge, newName], [oldAge, oldName]) =&gt; &#123;        console.log(newAge);        console.log(newName);        console.log(oldAge);        console.log(oldName);      &#125;    );    state.age = 100;    state.name = &quot;lisi&quot;;    setTimeout(() =&gt; &#123;      stop();      // 此时修改时，不会触发 watch 回调      state.age = 1000;      state.name = &quot;wangwu&quot;;    &#125;, 1000); // 1 秒之后讲取消 watch 的监听    return &#123;      ...toRefs(state),    &#125;;  &#125;,&#125;);\n\nLifeCycle Hooks 新的生命周期函数import &#123;  defineComponent,  onBeforeMount,  onBeforeUnmount,  onBeforeUpdate,  onErrorCaptured,  onMounted,  onUnmounted,  onUpdated,&#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup(props, context) &#123;    onBeforeMount(() =&gt; &#123;      console.log(&quot;beformounted!&quot;);    &#125;);    onMounted(() =&gt; &#123;      console.log(&quot;mounted!&quot;);    &#125;);    onBeforeUpdate(() =&gt; &#123;      console.log(&quot;beforupdated!&quot;);    &#125;);    onUpdated(() =&gt; &#123;      console.log(&quot;updated!&quot;);    &#125;);    onBeforeUnmount(() =&gt; &#123;      console.log(&quot;beforunmounted!&quot;);    &#125;);    onUnmounted(() =&gt; &#123;      console.log(&quot;unmounted!&quot;);    &#125;);    onErrorCaptured(() =&gt; &#123;      console.log(&quot;errorCaptured!&quot;);    &#125;);    return &#123;&#125;;  &#125;,&#125;);\n\nTemplate refs通过 refs 来返回真实 DOM 元素，为了获得对模板内元素或组件实例的引用，我们可以在 setup() 中声明一个 ref() 并返回它。\n\n在 HTML 添加 ref 的属性。\n在 steup() 中定义一个 ref()。\n在 steup() 中返回 ref() 的实例。\nonMounted() 中可以得到 ref() 的 RefImpl 的对象，通过 .value 获取真实 DOM。\n\n&lt;template&gt;  &lt;div ref=&quot;elmRefs&quot;&gt;    &lt;span&gt;test&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, onMounted, ref &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    setup(props, context) &#123;      // 获取真实 DOM      const elmRefs = ref&lt;null | HTMLElement&gt;(null);      onMounted(() =&gt; &#123;        console.log(elmRefs.value); // 得到一个 RefImpl 的对象，通过 .value 访问到数据      &#125;);      return &#123;        elmRefs,      &#125;;    &#125;,  &#125;);&lt;/script&gt;\n\nVue 3 全局配置通过 Vue 实例上 config 来配置，包含 Vue 应用程序全局配置的对象。在挂载应用程序之前修改下面列出的属性。\nconst app = Vue.createApp(&#123;&#125;)app.config = &#123;...&#125;\n\n为组件渲染功能和观察程序期间的未捕获错误分配处理程序\napp.config.errorHandler = (err, vm, info) =&gt; &#123;&#125;;\n\n可以在应用程序内的任何组件实例中访问的全局属性，组件的属性将具有优先权。这可以代替 Vue 2.x Vue.prototype 扩展。\nimport axios from &quot;axios&quot;;const app = Vue.createApp(&#123;&#125;);app.config.globalProperties.$http = axios;\n\n可以在组件内通过 getCurrentInstance() 来获取全局 globalProperties 中配置的信息，getCurrentInstance() 获取当前组件的实例，然后通过 ctx 属性获得当前上下文，这样我们就能在 setup() 中使用 router 和 vuex，通过这个属性我们就可以操作变量、全局属性、组件属性等等。\nsetup() &#123;  const &#123; ctx &#125; = getCurrentInstance();  // ctx.$http&#125;\n\nSuspense 组件在介绍 Vue 的 Suspense 组件之前，我们有必要先了解一下 React 的 Suspense 组件，因为它们的功能类似。React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件。\nimport React, &#123; Suspense &#125; from &quot;react&quot;;const myComponent = React.lazy(() =&gt; import(&quot;./Component&quot;));function MyComponent() &#123;  return (    &lt;div&gt;      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;        &lt;myComponent /&gt;      &lt;/Suspense&gt;    &lt;/div&gt;  );&#125;\n\nVue 3 也新增了 React.lazy 类似功能的 defineAsyncComponent 函数，处理动态引入的组件。defineAsyncComponent 可以接受返回 Promise 的工厂函数。从服务器检索到组件定义时，应该调用 Promise 的解析回调。您还可以调用 reject(reason) 来指示负载已经失败。\nimport &#123; defineAsyncComponent &#125; from &quot;vue&quot;;const AsyncComp = defineAsyncComponent(  () =&gt; import(&quot;./components/AsyncComponent.vue&quot;));app.component(&quot;async-component&quot;, AsyncComp);\n\nVue 3 也新增了 Suspense 组件：\n&lt;template&gt;  &lt;Suspense&gt;    &lt;template #default&gt;      &lt;my-component /&gt;    &lt;/template&gt;    &lt;template #fallback&gt; Loading ... &lt;/template&gt;  &lt;/Suspense&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, defineAsyncComponent &#125; from &quot;vue&quot;;  const MyComponent = defineAsyncComponent(() =&gt; import(&quot;./Component&quot;));  export default defineComponent(&#123;    components: &#123;      MyComponent,    &#125;,    setup() &#123;      return &#123;&#125;;    &#125;,  &#125;);&lt;/script&gt;\n","categories":["前端"],"tags":["Vue"]},{"title":"Keep 主题使用指南","url":"/post/271ccb1e71c9/","content":"如你所见，Keep 主题的设计十分简约、大气，同时也五脏俱全、功能丰富，这正是 Keep 主题的开发理念。\n一路走来，辗转各类博客框架，也曾尝试过花里胡哨，发现不仅搭建繁琐、配置复杂、文档混乱，而且容易审美疲劳，背驰了自己写博客的初衷。\n直至后来，在频繁选择和折腾博客工具上耗费过多精力，致使文章产出稀少，内容不佳，终于豁然大悟，明白应该把时间放在内容创作上，记录生活、分享技术、展示文字，可能这才是搭建博客网站的最终追求，为此 Keep 主题应运而生。\n\n\n简约轻快、返璞归真、化繁为简、配置精简、突出内容、高度定制、运行稳定、文档详细、长期维护，如果你也喜欢或认可 Keep 主题的这些特点，那就一起来探索吧。\n文档 | Documents\nKeep 主题 - 官方文档\n\nKeep 主题 - 快速开始\n\nKeep 主题 - 配置指南\n\nKeep 主题 - 进阶使用\n\n\n贡献 | ContributionKeep 目前还是很年轻的 Hexo 主题，有着很大的提升空间，欢迎小伙伴们各种形式的贡献，包括但不限于：美化样式、增加功能、改进代码、提升性能、修复 Bug、完善文档等。\nKeep 主题贡献指南\n致谢这个项目的存在多亏了所有的贡献者，在此表示感谢。\n\n\n\n反馈 | Feedback您在使用 Keep 主题过程中，绝大部分的问题都能在 官方文档 和 历史 Issues 中找到相应的参考。\n如果遇到难于解决的问题、Bug 或有新的需求建议，请在 GitHub 新开 Issue 。\n交流 | exchanges微信交流群欢迎小伙伴们加入 Keep 主题微信交流群，可以获得最及时的问题解答和技术支持。\n群二维码时效只有七天，因此需要你关注公众号《自由程序猿》，添加作者微信，由作者邀请进群。\n\n添加微信时，注意填写备注 Keep 主题交流群\n\n\n\n赞赏Keep 主题日常的更新迭代依靠作者工作之外的时间，维护不易，如果对你有帮助，欢迎微信扫码赞赏作者，支持开源。\n\n\n版权 | Copyright\nKeep 主题的版权归作者所有，任何人不得滥用、非法使用或者侵犯版权。\n\nKeep 主题采用 AGPL-3.0 许可证，基于 Keep 主题进行修改或者二次开发的软件产品，须继续沿用 AGPL-3.0，并且将源代码公开。\n\n任何使用 Keep 主题衍生出来的产品都不能直接用于商业目的，如果想要商业使用 Keep 主题，必须征得作者的同意和授权。\n\n敬请保留底部的 Keep 主题版本信息，这应该是你对开源项目最微小地支持，对移除底部版本信息的用户，作者不提供问题解决和技术支持。示例：Powered by Hexo &amp; Theme Keep v4.1.0\n\n\n","categories":["Keep 教程"],"tags":["Hexo","Keep"]},{"title":"macOS 使用数据库可视化工具管理 MySQL","url":"/post/5356324a42d0/","content":"安装 MySQL官网下载安装最简单的方式是直接从 MySQL 官网 下载安装包进行安装。\nHomebrew 下载安装在 macOS 上也可以在终端使用 Homebrew 的命令来安装 MySQL。\n\n安装 Homebrew\n /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n\n使用 Homebrew 安装 MySQL\n brew install mysql\n\n启动 MySQL 服务验证 MySQL 是否安装成功在终端使用命令 mysql --version 查看 MySQL 版本，如下图，出现具体的版本号，表示 MySQL 成功安装。\nmysql --version\n\n\n启动 MySQL 服务在终端使用命令 bash mysql.server start 来打开 MySQL 服务。\nbash mysql.server start\n如下图，表示 MySQL 服务启动成功。\n\n\n\n在使用数据库可视化工具连接本地 MySQL 时，需要先启动 MySQL 服务。\n\n\n查看 MySQL 服务状态bash mysql.server status\n\n停止 MySQL 服务bash mysql.server stop\n\n登录 MySQL使用 root 账户登录MySQL 默认的 root 账户不带密码，使用命令 mysql -uroot 可直接登录，如下图，表示登录成功。\nmysql -uroot\n\n\n设置 root 账户密码因为默认的 root 账户不带密码，安全起见，我们给 root 账户设置密码。（例如设置密码：123456）\nset password for &#x27;root&#x27;@&#x27;localhost&#x27;=&#x27;123456&#x27;;\n\n\n密码设置成功后，再次登录时需要输入密码，如下命令。\nmysql -uroot -p&#x27;123456&#x27;\n\n\nMySQL 常用命令\n注意：在终端使用以下命令需要登录到 MySQL。\n\n\n查看当前数据库列表\n show databases;\n\n创建数据库\n create database test123;\n\n选择数据库\n use 数据库名;\n\n查看当前数据库下的表\n show tables;\n\n查看当前数据库下的表结构\n desc 表名;\n\n删除表\ndrop table 表名;\n\n删除数据库\n drop database 数据库名;\n\n使用 Navicat 管理Navicat 连接 MySQL点击 Navicat Premium 左上角的”连接”，选择” MySQL “，新建一个 MySQL 连接，参数如下，默认端口 3306。\n\n注意：\n\n可使用命令 lsof -i:3306 查看 3306 端口是否被占用。\n\n如果点击 “测试连接“ 发现连接不上，出现报错信息：\n2059 - Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded: dlopen(../Frameworks/caching_.......\n错误原因是因为 MySQL 5.7 版本之后，默认验证方式由原来的 mysql_native_password 改成了 caching_sha2_password。只需把验证方式修改成原来的，就能连接上了。\n修改方法：登录 MySQL，执行命令：\nALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;\n\n使用 DBeaver 管理https://github.com/dbeaver/dbeaver\nhttps://dbeaver.io/\nDBeaver 连接 MySQL持续更新…\n","categories":["通用教程"],"tags":["数据库","macOS","MySQL"]},{"title":"macOS 配置多个 Git 账户的 SSH Key","url":"/post/f18df6b19c3d/","content":"准备工作首先确保在你的 Mac 上已安装 Git。\n在终端输入命令git --version，能打印出具体的版本号，表示 Git 正确安装。\n\n开始配置本文以配置 GitHub 和 GitLab 为案例，生成两个公共&#x2F;私有 rsa 密钥对：rsa_github 和 rsa_gitlab。\n创建 rsa 密钥对\n进入到当前用户目录\n cd ~\n\n创建 .ssh 目录\n mkdir .ssh\n\n\n如果 .ssh 目录已经存在，则忽略这一步。\n\n\n进入到 .ssh 目录\n cd ~/.ssh\n\n生成公共&#x2F;私有 rsa 密钥对\n ssh-keygen -t rsa -C &quot;i@xpoet.cn&quot;\n\n 此时会看到终端提示输入要保存密钥的文件名，为了做区分，我们给文件名加个后缀，本例第一个 rsa 密钥对：rsa_github。\n 接着会看到终端提示输入密码，敲两次 Enter 回车键 跳过输入密码。\n \n 最终会在 .ssh 目录 里生成 rsa_github 和 rsa_github.pub 密钥对。\n \n\n参照第 4 步，创建本例的第二个 rsa 密钥对，rsa_gitlab。\n ssh-keygen -t rsa -C &quot;a@xpoet.cn&quot;\n  \n\n\n配置 rsa 密钥对\n进入到 .ssh 目录\n cd ~/.ssh\n\n创建 config 配置文件\n touch config\n\n配置 rsa\nconfig 文件创建好之后，将其内容修改为：\n Host github.com  User XPoet_github  IdentityFile ~/.ssh/rsa_githubHost gitlab.com  User XPoet_gitlab  IdentityFile ~/.ssh/rsa_gitlab\n User 填写你的 Git 账号名称IdentityFile 填写 rsa 路径\n    \n\n\n配置 Git\n进入到用户目录下，创建 .gitconfig 文件（Git 的配置文件）：\n cd ~touch .gitconfig\n\n\n如果 .gitconfig 文件已存在，则忽略这一步。\n\n\n在 .gitconfig 配置文件追加以下内容：\n [user]    name = XPoet_github    email = i@xpoet.cn[user]    name = XPoet_gitlab    email = a@xpoet.cn\n\n使用 SSH Key按照上面步骤，成功创建并且配置 rsa 密钥对，接下来就可以在对应的 Git 平台网站使用 SSH Key，完成和自己 Git 账号的关联。\nGitHubGitHub 添加 SSH Key 流程：\nsettings --&gt; SSH and GPG keys --&gt; New SSH Key\n\n打开 rsa_github.pub，将里面的内容复制到 Key 输入框中。\n\nGitLabGitLab 添加 SSH Key 流程：\nProfile --&gt; SSH keys\n\n打开 rsa_gitlab.pub，将里面的内容复制到 Key 输入框中。\n\n测试 SSH 连接以上操作完成后，我们以 GitHub 为例，测试一下 SSH 是否能连接成功。\n打开终端，输入如下命令，即可测试连接：\nssh -T git@github.com\n\n如下图，表示 SSH 连接成功。\n\n至此，完成在 macOS 下配置多个 Git 账户的 SSH 连接。同理，我们还可以配置 Coding、Gitee 等。\n","categories":["通用教程"],"tags":["Git","macOS"]}]